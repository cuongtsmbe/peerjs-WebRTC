{"version":3,"file":"flicking.pkgd.js","sources":["../src/core/FlickingError.ts","../src/const/error.ts","../src/const/external.ts","../src/utils.ts","../src/core/Viewport.ts","../src/const/axes.ts","../src/control/states/State.ts","../src/control/states/IdleState.ts","../src/control/states/HoldingState.ts","../src/control/states/DraggingState.ts","../src/control/states/AnimatingState.ts","../src/control/states/DisabledState.ts","../src/control/StateMachine.ts","../src/control/AxesController.ts","../src/control/Control.ts","../src/control/SnapControl.ts","../src/control/FreeControl.ts","../src/control/index.ts","../src/core/AnchorPoint.ts","../src/camera/Camera.ts","../src/camera/LinearCamera.ts","../src/camera/CircularCamera.ts","../src/camera/BoundCamera.ts","../src/camera/index.ts","../src/renderer/RenderingStrategy/RawRenderingStrategy.ts","../src/renderer/Renderer.ts","../src/core/panel/Panel.ts","../src/core/panel/ElementPanel.ts","../src/renderer/VanillaRenderer.ts","../src/renderer/ExternalRenderer.ts","../src/renderer/RenderingStrategy/VisibleRenderingStrategy.ts","../src/renderer/index.ts","../src/Flicking.ts","../src/core/panel/ExternalPanel.ts","../src/core/index.ts","../src/index.umd.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * Special type of known error that {@link Flicking} throws.\n * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러\n * @property {number} code Error code<ko>에러 코드</ko>\n * @property {string} message Error message<ko>에러 메시지</ko>\n * @see {@link Constants.ERROR_CODE ERROR_CODE}\n * @example\n * ```ts\n * import Flicking, { FlickingError, ERROR_CODES } from \"@egjs/flicking\";\n * try {\n *   const flicking = new Flicking(\".flicking-viewport\")\n * } catch (e) {\n *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {\n *     console.error(\"Element not found\")\n *   }\n * }\n * ```\n */\nclass FlickingError extends Error {\n  /**\n   * @param message Error message<ko>에러 메시지</ko>\n   * @param code Error code<ko>에러 코드</ko>\n   */\n  public constructor(\n    public message: string,\n    public code: number) {\n    super(message);\n    Object.setPrototypeOf(this, FlickingError.prototype);\n    this.name = \"FlickingError\";\n  }\n}\n\nexport default FlickingError;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n/**\n * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.\n * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.\n * @name ERROR_CODE\n * @constant\n * @type object\n * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>\n * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>\n * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>\n * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>\n * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>\n * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>\n * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>\n * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>\n * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>\n * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>\n * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>\n * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)\n * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>\n * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>\n * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>\n */\nexport const CODE = {\n  WRONG_TYPE: 0,\n  ELEMENT_NOT_FOUND: 1,\n  VAL_MUST_NOT_NULL: 2,\n  NOT_ATTACHED_TO_FLICKING: 3,\n  WRONG_OPTION: 4,\n  INDEX_OUT_OF_RANGE: 5,\n  POSITION_NOT_REACHABLE: 6,\n  TRANSFORM_NOT_SUPPORTED: 7,\n  STOP_CALLED_BY_USER: 8,\n  ANIMATION_INTERRUPTED: 9,\n  ANIMATION_ALREADY_PLAYING: 10,\n  NOT_ALLOWED_IN_FRAMEWORK: 11,\n  NOT_INITIALIZED: 12,\n  NO_ACTIVE: 13\n} as const;\n\nexport const MESSAGE = {\n  WRONG_TYPE: (wrongVal: any, correctTypes: string[]) => `${wrongVal}(${typeof wrongVal}) is not a ${correctTypes.map(type => `\"${type}\"`).join(\" or \")}.`,\n  ELEMENT_NOT_FOUND: (selector: string) => `Element with selector \"${selector}\" not found.`,\n  VAL_MUST_NOT_NULL: (val: any, name: string) => `${name} should be provided. Given: ${val}`,\n  NOT_ATTACHED_TO_FLICKING: (name: string) => `${name} is not attached to the Flicking instance. \"init()\" should be called first.`,\n  WRONG_OPTION: (optionName: string, val: any) => `Option \"${optionName}\" is not in correct format, given: ${val}`,\n  INDEX_OUT_OF_RANGE: (val: number, min: number, max: number) => `Index \"${val}\" is out of range: should be between ${min} and ${max}.`,\n  POSITION_NOT_REACHABLE: (position: number) => `Position \"${position}\" is not reachable.`,\n  TRANSFORM_NOT_SUPPORTED: \"Browser does not support CSS transform.\",\n  STOP_CALLED_BY_USER: \"Event stop() is called by user.\",\n  ANIMATION_INTERRUPTED: \"Animation is interrupted by user input.\",\n  ANIMATION_ALREADY_PLAYING: \"Animation is already playing.\",\n  NOT_ALLOWED_IN_FRAMEWORK: \"This behavior is not allowed in the frameworks like React, Vue, or Angular.\",\n  NOT_INITIALIZED: \"Flicking is not initialized yet, call init() first.\",\n  NO_ACTIVE: \"There's no active panel that Flicking has selected. This may be due to the absence of any panels.\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nexport { CODE as ERROR_CODE } from \"./error\";\n\n/**\n * Event type object with event name strings of {@link Flicking}\n * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체\n * @type {object}\n * @property {\"holdStart\"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>\n * @property {\"holdEnd\"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>\n * @property {\"moveStart\"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>\n * @property {\"move\"} MOVE move event<ko>move 이벤트</ko>\n * @property {\"moveEnd\"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>\n * @property {\"willChange\"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>\n * @property {\"changed\"} CHANGED changed event<ko>changed 이벤트</ko>\n * @property {\"willRestore\"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>\n * @property {\"restored\"} RESTORED restored event<ko>restored 이벤트</ko>\n * @property {\"select\"} SELECT select event<ko>select 이벤트</ko>\n * @property {\"needPanel\"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>\n * @example\n * ```ts\n * import { EVENTS } from \"@egjs/flicking\";\n * EVENTS.MOVE_START; // \"moveStart\"\n * ```\n */\nexport const EVENTS = {\n  READY: \"ready\",\n  BEFORE_RESIZE: \"beforeResize\",\n  AFTER_RESIZE: \"afterResize\",\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  WILL_CHANGE: \"willChange\",\n  CHANGED: \"changed\",\n  WILL_RESTORE: \"willRestore\",\n  RESTORED: \"restored\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  REACH_EDGE: \"reachEdge\"\n} as const;\n\n/**\n * An object with all possible predefined literal string for the {@link Flicking#align align} option\n * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체\n * @type {object}\n * @property {\"prev\"} PREV left/top align<ko>좌/상 정렬</ko>\n * @property {\"center\"} CENTER center align<ko>중앙 정렬</ko>\n * @property {\"next\"} NEXT right/bottom align<ko>우/하 정렬</ko>\n */\nexport const ALIGN = {\n  PREV: \"prev\",\n  CENTER: \"center\",\n  NEXT: \"next\"\n} as const;\n\n/**\n * An object of directions\n * @ko 방향을 나타내는 값들을 담고 있는 객체\n * @type {object}\n * @property {\"PREV\"} PREV \"left\" when {@link Flicking#horizontal horizontal} is true, and \"top\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>\n * @property {\"NEXT\"} NEXT \"right\" when {@link Flicking#horizontal horizontal} is true, and \"bottom\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>\n * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>\n */\nexport const DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n  NONE: null\n} as const;\n\n/**\n * An object with all possible {@link Flicking#moveType moveType}s\n * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체\n * @type {object}\n * @property {\"snap\"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"freeScroll\"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n */\nexport const MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking, { FlickingOptions } from \"./Flicking\";\nimport FlickingError from \"./core/FlickingError\";\nimport * as ERROR from \"./const/error\";\nimport { ALIGN, DIRECTION } from \"./const/external\";\nimport { LiteralUnion, Merged, ValueOf } from \"./type/internal\";\nimport { ElementLike } from \"./type/external\";\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const merge = <From extends object, To extends object>(target: From, ...sources: To[]): Merged<From, To> => {\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      target[key] = source[key] as unknown;\n    });\n  });\n\n  return target as Merged<From, To>;\n};\n\nexport const getElement = (el: HTMLElement | string | null, parent?: HTMLElement): HTMLElement => {\n  let targetEl: HTMLElement | null = null;\n\n  if (isString(el)) {\n    const parentEl = parent ? parent : document;\n    const queryResult = parentEl.querySelector(el);\n    if (!queryResult) {\n      throw new FlickingError(ERROR.MESSAGE.ELEMENT_NOT_FOUND(el), ERROR.CODE.ELEMENT_NOT_FOUND);\n    }\n    targetEl = queryResult as HTMLElement;\n  } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n    targetEl = el;\n  }\n\n  if (!targetEl) {\n    throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n  }\n\n  return targetEl;\n};\n\nexport const checkExistence = (value: any, nameOnErrMsg: string) => {\n  if (value == null) {\n    throw new FlickingError(ERROR.MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), ERROR.CODE.VAL_MUST_NOT_NULL);\n  }\n};\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\n\nexport const getFlickingAttached = (val: Flicking | null, nameToThrowOnError: string): Flicking => {\n  if (!val) {\n    throw new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING(nameToThrowOnError), ERROR.CODE.NOT_ATTACHED_TO_FLICKING);\n  }\n\n  return val;\n};\n\nexport const toArray = <T>(iterable: ArrayLike<T>): T[] => [].slice.call(iterable) as T[];\n\nexport const parseAlign = (align: LiteralUnion<ValueOf<typeof ALIGN>> | number, size: number): number => {\n  let alignPoint: number | null;\n  if (isString(align)) {\n    switch (align) {\n      case ALIGN.PREV:\n        alignPoint = 0;\n        break;\n      case ALIGN.CENTER:\n        alignPoint = 0.5 * size;\n        break;\n      case ALIGN.NEXT:\n        alignPoint = size;\n        break;\n      default:\n        alignPoint = parseArithmeticExpression(align, size);\n        if (alignPoint == null) {\n          throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"align\", align), ERROR.CODE.WRONG_OPTION);\n        }\n    }\n  } else {\n    alignPoint = align as number;\n  }\n\n  return alignPoint;\n};\n\nexport const parseBounce = (bounce: FlickingOptions[\"bounce\"], size: number): number[] => {\n  let parsedBounce: Array<number | null>;\n\n  if (Array.isArray(bounce)) {\n    parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, size));\n  } else {\n    const parsedVal = parseArithmeticExpression(bounce, size);\n\n    parsedBounce = [parsedVal, parsedVal];\n  }\n\n  return parsedBounce.map(val => {\n    if (val == null) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"bounce\", bounce), ERROR.CODE.WRONG_OPTION);\n    }\n    return val;\n  });\n};\n\nexport const parseArithmeticExpression = (cssValue: number | string, base: number): number | null => {\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return cssValue;\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return null;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return null;\n  }\n\n  return calculatedValue;\n};\n\nexport const parseCSSSizeValue = (val: string | number): string => isString(val) ? val : `${val}px`;\n\nexport const getDirection = (start: number, end: number): ValueOf<typeof DIRECTION> => {\n  if (start === end) return DIRECTION.NONE;\n  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;\n};\n\nexport const parseElement = (element: ElementLike | ElementLike[]): HTMLElement[] => {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n      elements.push(el);\n    } else {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n    }\n  });\n\n  return elements;\n};\n\nexport const getMinusCompensatedIndex = (idx: number, max: number) => idx < 0 ? clamp(idx + max, 0, max) : clamp(idx, 0, max);\n\nexport const includes = <T>(array: T[], target: any): target is T => {\n  for (const val of array) {\n    if (val === target) return true;\n  }\n  return false;\n};\n\nexport const isString = (val: any): val is string => typeof val === \"string\";\n\nexport const circulatePosition = (pos: number, min: number, max: number) => {\n  const size = max - min;\n\n  if (pos < min) {\n    const offset = (min - pos) % size;\n    pos = max - offset;\n  } else if (pos > max) {\n    const offset = (pos - max) % size;\n    pos = min + offset;\n  }\n\n  return pos;\n};\n\nexport const find = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (const val of array) {\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findRight = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (let idx = array.length - 1; idx >= 0; idx--) {\n    const val = array[idx];\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findIndex = <T>(array: T[], checker: (val: T) => boolean): number => {\n  for (let idx = 0; idx < array.length; idx++) {\n    if (checker(array[idx])) {\n      return idx;\n    }\n  }\n\n  return -1;\n};\n\nexport const getProgress = (pos: number, prev: number, next: number) => (pos - prev) / (next - prev);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nexport const getStyle = (el: HTMLElement): CSSStyleDeclaration => window.getComputedStyle(el) || (el as any).currentStyle as CSSStyleDeclaration;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getStyle, isString } from \"../utils\";\n\n/**\n * A component that manages viewport size\n * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n */\nclass Viewport {\n  private _el: HTMLElement;\n  private _width: number;\n  private _height: number;\n  private _isBorderBoxSizing: boolean;\n  private _padding: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n\n  /**\n   * A viewport(root) element\n   * @ko 뷰포트(root) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  /**\n   * Viewport width, without paddings\n   * @ko 뷰포트 너비\n   * @type {number}\n   * @readonly\n   */\n  public get width() { return this._width - this._padding.left - this._padding.right; }\n  /**\n   * Viewport height, without paddings\n   * @ko 뷰포트 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height - this._padding.top - this._padding.bottom; }\n  /**\n   * Viewport paddings\n   * @ko 뷰포트 CSS padding 값\n   * @type {object}\n   * @property {number} left CSS `padding-left`\n   * @property {number} right CSS `padding-right`\n   * @property {number} top CSS `padding-top`\n   * @property {number} bottom CSS `padding-bottom`\n   * @readonly\n   */\n  public get padding() { return this._padding; }\n\n  /**\n   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>\n   */\n  public constructor(el: HTMLElement) {\n    this._el = el;\n    this._width = 0;\n    this._height = 0;\n    this._padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this._isBorderBoxSizing = false;\n  }\n\n  /**\n   * Change viewport's size.\n   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property\n   * @ko 뷰포트 크기를 변경합니다.\n   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   */\n  public setSize({\n    width,\n    height\n  }: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    const el = this._el;\n    const padding = this._padding;\n    const isBorderBoxSizing = this._isBorderBoxSizing;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        const newWidth = isBorderBoxSizing\n          ? width + padding.left + padding.right\n          : width;\n        el.style.width = `${newWidth}px`;\n      }\n    }\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        const newHeight = isBorderBoxSizing\n          ? height + padding.top + padding.bottom\n          : height;\n        el.style.height = `${newHeight}px`;\n      }\n    }\n    this.resize();\n  }\n\n  /**\n   * Update width/height to the current viewport element's size\n   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다\n   */\n  public resize() {\n    const el = this._el;\n    const elStyle = getStyle(el);\n\n    this._width = el.offsetWidth;\n    this._height = el.offsetHeight;\n    this._padding = {\n      left: parseFloat(elStyle.paddingLeft),\n      right: parseFloat(elStyle.paddingRight),\n      top: parseFloat(elStyle.paddingTop),\n      bottom: parseFloat(elStyle.paddingBottom)\n    };\n    this._isBorderBoxSizing = elStyle.boxSizing === \"border-box\";\n  }\n}\n\nexport default Viewport;\n","/**\n * All possible @egjs/axes event keys\n * @internal\n */\nexport const EVENT = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n} as const;\n\n/**\n * An Axis key that Flicking uses\n * @internal\n */\nexport const POSITION_KEY = \"flick\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { OnAnimationEnd, OnChange, OnFinish, OnHold, OnRelease } from \"@egjs/axes\";\n\nimport Flicking from \"../../Flicking\";\n\nexport enum STATE_TYPE {\n  IDLE,\n  HOLDING,\n  DRAGGING,\n  ANIMATING,\n  DISABLED\n}\n\n/**\n * A component that shows the current status of the user input or the animation\n * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트\n * @internal\n */\nabstract class State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly holding: boolean;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly animating: boolean;\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onHold(ctx: {\n    flicking: Flicking;\n    axesEvent: OnHold;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onChange(ctx: {\n    flicking: Flicking;\n    axesEvent: OnChange;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onRelease(ctx: {\n    flicking: Flicking;\n    axesEvent: OnRelease;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onAnimationEnd(ctx: {\n    flicking: Flicking;\n    axesEvent: OnAnimationEnd;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onFinish(ctx: {\n    flicking: Flicking;\n    axesEvent: OnFinish;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A default state when there's no user input and no animation's playing\n * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태\n * @internal\n */\nclass IdleState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    // Shouldn't do any action until any panels on flicking area\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (flicking.renderer.panelCount <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent\n    });\n\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.HOLDING);\n    }\n  }\n\n  // By methods call\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);\n    }\n  }\n}\n\nexport default IdleState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's holding the Flicking area, but not moved a single pixel yet\n * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태\n * @internal\n */\nclass HoldingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  private _releaseEvent: OnRelease | null = null;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const inputEvent = axesEvent.inputEvent as { offsetX: number; offsetY: number };\n\n    const offset = flicking.horizontal\n      ? inputEvent.offsetX\n      : inputEvent.offsetY;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, -offset),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);\n    }\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, { axesEvent }));\n\n    if (axesEvent.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      axesEvent.setTo({ flick: flicking.camera.position }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this._releaseEvent = axesEvent;\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]): void {\n    const { flicking, transitTo } = ctx;\n\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this._releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this._releaseEvent;\n\n    // Static click\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    /* eslint-enable */\n\n    const panels = flicking.renderer.panels;\n    let clickedPanel: Panel | null = null;\n\n    for (const panel of panels) {\n      if (panel.contains(clickedElement)) {\n        clickedPanel = panel;\n        break;\n      }\n    }\n\n    if (clickedPanel) {\n      const cameraPosition = flicking.camera.position;\n      const clickedPanelPosition = clickedPanel.position;\n\n      flicking.trigger(new ComponentEvent(EVENTS.SELECT, {\n        index: clickedPanel.index,\n        panel: clickedPanel,\n        // Direction to the clicked panel\n        direction: getDirection(cameraPosition, clickedPanelPosition)\n      }));\n    }\n  }\n}\n\nexport default HoldingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's dragging the Flicking area\n * @ko 사용자가 드래깅중인 상태\n * @internal\n */\nclass DraggingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (!axesEvent.delta[AXES.POSITION_KEY]) {\n      return;\n    }\n\n    const camera = flicking.camera;\n    const prevPosition = camera.position;\n\n    void camera.lookAt(axesEvent.pos[AXES.POSITION_KEY]);\n\n    const moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta[AXES.POSITION_KEY]),\n      axesEvent\n    });\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      void camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent\n    }));\n\n    if (flicking.renderer.panelCount <= 0) {\n      // There're no panels\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    transitTo(STATE_TYPE.ANIMATING);\n\n    const control = flicking.control;\n    const position = axesEvent.destPos[AXES.POSITION_KEY];\n    const duration = Math.max(axesEvent.duration, flicking.duration);\n\n    void control.moveToPosition(position, duration, axesEvent);\n  }\n}\n\nexport default DraggingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking's animating by user input or method call\n * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태\n * @internal\n */\nclass AnimatingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, { axesEvent });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.DRAGGING);\n    }\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (!axesEvent.delta.flick) {\n      return;\n    }\n\n    const camera = flicking.camera;\n    const prevPosition = camera.position;\n\n    void camera.lookAt(axesEvent.pos.flick);\n\n    const moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta.flick),\n      axesEvent\n    });\n\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      void flicking.camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]) {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    flicking.trigger(new ComponentEvent(EVENTS.MOVE_END, {\n      isTrusted: axesEvent.isTrusted,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    }));\n  }\n}\n\nexport default AnimatingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking is stopped by event's `stop` method\n * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태\n * @internal\n */\nclass DisabledState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onAnimationEnd(ctx: Parameters<State[\"onAnimationEnd\"]>[0]): void {\n    const { transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // Can stop Axes's change event\n    axesEvent.stop();\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // This is needed when stopped hold start event\n    if (axesEvent.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { AxesEvents } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport * as AXES from \"../const/axes\";\n\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport State, { STATE_TYPE } from \"./states/State\";\n\n/**\n * @internal\n */\nclass StateMachine {\n  private _state: State;\n\n  public get state(): State { return this._state; }\n\n  public constructor() {\n    this._state = new IdleState();\n  }\n\n  public fire(eventType: keyof AxesEvents, externalCtx: {\n    flicking: Flicking;\n    axesEvent: any;\n  }) {\n    const currentState = this._state;\n    const ctx = { ...externalCtx, transitTo: this.transitTo };\n\n    switch (eventType) {\n      case AXES.EVENT.HOLD:\n        currentState.onHold(ctx);\n        break;\n      case AXES.EVENT.CHANGE:\n        currentState.onChange(ctx);\n        break;\n      case AXES.EVENT.RELEASE:\n        currentState.onRelease(ctx);\n        break;\n      case AXES.EVENT.ANIMATION_END:\n        currentState.onAnimationEnd(ctx);\n        break;\n      case AXES.EVENT.FINISH:\n        currentState.onFinish(ctx);\n        break;\n    }\n  }\n\n  public transitTo = (nextStateType: STATE_TYPE): State => {\n    let nextState: State;\n\n    switch (nextStateType) {\n      case STATE_TYPE.IDLE:\n        nextState = new IdleState();\n        break;\n      case STATE_TYPE.HOLDING:\n        nextState = new HoldingState();\n        break;\n      case STATE_TYPE.DRAGGING:\n        nextState = new DraggingState();\n        break;\n      case STATE_TYPE.ANIMATING:\n        nextState = new AnimatingState();\n        break;\n      case STATE_TYPE.DISABLED:\n        nextState = new DisabledState();\n        break;\n    }\n\n    this._state = nextState;\n\n    return this._state;\n  };\n}\n\nexport default StateMachine;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput, AxesEvents, OnRelease } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached, parseBounce } from \"../utils\";\n\nimport StateMachine from \"./StateMachine\";\n\n/**\n * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n * @internal\n */\nclass AxesController {\n  private _flicking: Flicking | null;\n  private _axes: Axes | null;\n  private _panInput: PanInput | null;\n  private _stateMachine: StateMachine;\n\n  private _animatingContext: { start: number; end: number; offset: number };\n\n  /**\n   * An {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}의 인스턴스\n   * @type {Axes}\n   * @see https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html\n   * @readonly\n   */\n  public get axes() { return this._axes; }\n  /**\n   * A activated {@link State} that shows the current status of the user input or the animation\n   * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다\n   * @type {State}\n   */\n  public get state() { return this._stateMachine.state; }\n  /**\n   * A context of the current animation playing\n   * @ko 현재 재생중인 애니메이션 정보\n   * @type {object}\n   * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>\n   * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>\n   * @property {number} offset camera offset<ko>카메라 오프셋</ko>\n   * @readonly\n   */\n  public get animatingContext() { return this._animatingContext; }\n  /**\n   * A Boolean indicating whether the user input is enabled\n   * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get enabled() { return this._panInput?.isEnable() ?? false; }\n  /**\n   * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._axes?.get([AXES.POSITION_KEY])[AXES.POSITION_KEY] ?? 0; }\n  /**\n   * Actual bounce size(px)\n   * @ko 적용된 bounce 크기(px 단위)\n   * @type {number[]}\n   * @readonly\n   */\n  public get bounce() { return this._axes?.axis[AXES.POSITION_KEY].bounce as number[] | undefined; }\n\n  /** */\n  public constructor() {\n    this._resetInternalValues();\n    this._stateMachine = new StateMachine();\n  }\n\n  /**\n   * Initialize AxesController\n   * @ko AxesController를 초기화합니다\n   * @param {Flicking} flicking An instance of Flicking\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    this._axes = new Axes({\n      [AXES.POSITION_KEY]: {\n        range: [0, 0],\n        circular: false,\n        bounce: [0, 0]\n      }\n    }, {\n      deceleration: flicking.deceleration,\n      interruptable: flicking.interruptable,\n      easing: flicking.easing\n    });\n    this._panInput = new PanInput(flicking.viewport.element, {\n      inputType: flicking.inputType,\n      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,\n      scale: flicking.horizontal ? [-1, 0] : [0, -1]\n    });\n\n    const axes = this._axes;\n\n    axes.connect(flicking.horizontal ? [AXES.POSITION_KEY, \"\"] : [\"\", AXES.POSITION_KEY], this._panInput);\n\n    for (const key in AXES.EVENT) {\n      const eventType = AXES.EVENT[key] as keyof AxesEvents;\n\n      axes.on(eventType, (e: AxesEvents[typeof eventType]) => {\n        this._stateMachine.fire(eventType, {\n          flicking,\n          axesEvent: e\n        });\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Destroy AxesController and return to initial state\n   * @ko AxesController를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._axes?.destroy();\n    this._panInput?.destroy();\n\n    this._resetInternalValues();\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._panInput?.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._panInput?.disable();\n\n    return this;\n  }\n\n  /**\n   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before\n   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public update(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const axes = this._axes!;\n    const controlParams = camera.controlParams;\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    axis.circular = [controlParams.circular, controlParams.circular];\n    axis.range = [controlParams.range.min, controlParams.range.max];\n    axis.bounce = parseBounce(flicking.bounce, camera.size);\n\n    axes.axm.set({ [AXES.POSITION_KEY]: controlParams.position });\n\n    return this;\n  }\n\n  /**\n   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다\n   * @param {number} position A position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public animateTo(position: number, duration: number, axesEvent?: OnRelease): Promise<void> {\n    const axes = this._axes;\n\n    if (!axes) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING(\"Control\"), ERROR.CODE.NOT_ATTACHED_TO_FLICKING));\n    }\n\n    const startPos = axes.get([AXES.POSITION_KEY])[AXES.POSITION_KEY];\n\n    if (startPos === position) {\n      const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n      return flicking.camera.lookAt(position);\n    }\n\n    this._animatingContext = {\n      start: startPos,\n      end: position,\n      offset: 0\n    };\n\n    const animate = () => {\n      const resetContext = () => {\n        this._animatingContext = { start: 0, end: 0, offset: 0 };\n      };\n\n      axes.once(AXES.EVENT.FINISH, resetContext);\n\n      if (axesEvent) {\n        axesEvent.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      } else {\n        axes.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      }\n    };\n\n    if (duration === 0) {\n      animate();\n      axes.axm.set({ [AXES.POSITION_KEY]: position });\n\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve, reject) => {\n        const animationFinishHandler = () => {\n          axes.off(AXES.EVENT.HOLD, interruptionHandler);\n          resolve();\n        };\n\n        const interruptionHandler = () => {\n          axes.off(AXES.EVENT.FINISH, animationFinishHandler);\n          reject(new FlickingError(ERROR.MESSAGE.ANIMATION_INTERRUPTED, ERROR.CODE.ANIMATION_INTERRUPTED));\n        };\n\n        axes.once(AXES.EVENT.FINISH, animationFinishHandler);\n\n        if (!axesEvent) {\n          axes.once(AXES.EVENT.HOLD, interruptionHandler);\n        }\n\n        animate();\n      });\n    }\n  }\n\n  protected _resetInternalValues() {\n    this._flicking = null;\n    this._axes = null;\n    this._panInput = null;\n    this._animatingContext = { start: 0, end: 0, offset: 0 };\n  }\n}\n\nexport default AxesController;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AxesController from \"../control/AxesController\";\nimport { DIRECTION, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getDirection, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\n/**\n * A component that manages inputs and animation of Flicking\n * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트\n */\nabstract class Control {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _controller: AxesController;\n  protected _activePanel: Panel | null;\n\n  /**\n   * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n   * @type {AxesController}\n   * @readonly\n   */\n  public get controller() { return this._controller; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get activeIndex() { return this._activePanel?.index ?? -1; }\n  /**\n   * An active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel | null}\n   * @readonly\n   */\n  public get activePanel() { return this._activePanel; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._controller.state.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._controller.state.holding; }\n\n  /** */\n  public constructor() {\n    this._flicking = null;\n    this._controller = new AxesController();\n    this._activePanel = null;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @method\n   * @abstract\n   * @memberof Control\n   * @instance\n   * @name moveToPosition\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public abstract moveToPosition(position: number, duration: number, axesEvent?: OnRelease): Promise<void>;\n\n  /**\n   * Initialize Control\n   * @ko Control을 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._controller.init(flicking);\n\n    return this;\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._controller.destroy();\n\n    this._flicking = null;\n    this._activePanel = null;\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._controller.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._controller.disable();\n\n    return this;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public async updatePosition(_progressInPanel: number): Promise<void> {   // eslint-disable-line @typescript-eslint/no-unused-vars\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      await camera.lookAt(camera.clampToReachablePosition(activePanel.position));\n    }\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    this._controller.update();\n\n    return this;\n  }\n\n  /**\n   * Reset {@link Control#activePanel activePanel} and {@link Control#activeAnchor activeAnchor} to `null`\n   * @ko {@link Control#activePanel activePanel}와 {@link Control#activeAnchor activeAnchor}를 `null`로 초기화합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetActive(): this {\n    this._activePanel = null;\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given panel\n   * @ko {@link Camera}를 해당 패널 위로 이동합니다\n   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPanel(panel: Panel, {\n    duration,\n    direction = DIRECTION.NONE,\n    axesEvent\n  }: {\n    duration: number;\n    direction?: ValueOf<typeof DIRECTION>;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n\n    let position = panel.position;\n    const nearestAnchor = camera.findNearestAnchor(position);\n\n    if (panel.removed || !nearestAnchor) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(panel.position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n    if (!camera.canReach(panel)) {\n      // Override position & panel if that panel is not reachable\n      position = nearestAnchor.position;\n      panel = nearestAnchor.panel;\n    } else if (flicking.circularEnabled) {\n      // Circular mode is enabled, find nearest distance to panel\n      const camPos = this._controller.position; // Actual position of the Axes\n      const camRangeDiff = camera.rangeDiff;\n      const possiblePositions = [position, position + camRangeDiff, position - camRangeDiff]\n        .filter(pos => {\n          if (direction === DIRECTION.NONE) return true;\n\n          return direction === DIRECTION.PREV\n            ? pos <= camPos\n            : pos >= camPos;\n        });\n\n      position = possiblePositions.reduce((nearestPosition, pos) => {\n        if (Math.abs(camPos - pos) < Math.abs(camPos - nearestPosition)) {\n          return pos;\n        } else {\n          return nearestPosition;\n        }\n      }, Infinity);\n    }\n\n    this._triggerIndexChangeEvent(panel, panel.position, axesEvent);\n\n    return this._animateToPosition({ position, duration, newActivePanel: panel, axesEvent });\n  }\n\n  protected _triggerIndexChangeEvent(panel: Panel, position: number, axesEvent?: OnRelease): void {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const event = new ComponentEvent(triggeringEvent, {\n      index: panel.index,\n      panel,\n      isTrusted: axesEvent?.isTrusted || false,\n      direction: getDirection(activePanel?.position ?? camera.position, position)\n    });\n    flicking.trigger(event);\n\n    if (event.isCanceled()) {\n      throw new FlickingError(ERROR.MESSAGE.STOP_CALLED_BY_USER, ERROR.CODE.STOP_CALLED_BY_USER);\n    }\n  }\n\n  protected async _animateToPosition({\n    position,\n    duration,\n    newActivePanel,\n    axesEvent\n  }: {\n    position: number;\n    duration: number;\n    newActivePanel: Panel;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const currentPanel = this._activePanel;\n    const animate = () => this._controller.animateTo(position, duration, axesEvent);\n    const isTrusted = axesEvent?.isTrusted || false;\n\n    if (duration <= 0) {\n      const animation = animate();\n      this._setActive(newActivePanel, currentPanel, isTrusted);\n      return animation;\n    } else {\n      return animate().then(async () => {\n        this._setActive(newActivePanel, currentPanel, isTrusted);\n        await flicking.renderer.render();\n      });\n    }\n  }\n\n  protected _setActive = (newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) => {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n    this._activePanel = newActivePanel;\n\n    flicking.camera.updateAdaptiveHeight();\n\n    if (newActivePanel !== prevActivePanel) {\n      flicking.trigger(new ComponentEvent(EVENTS.CHANGED, {\n        index: newActivePanel.index,\n        panel: newActivePanel,\n        prevIndex: prevActivePanel?.index ?? -1,\n        prevPanel: prevActivePanel,\n        isTrusted,\n        direction: prevActivePanel ? getDirection(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE\n      }));\n    } else {\n      flicking.trigger(new ComponentEvent(EVENTS.RESTORED, {\n        isTrusted\n      }));\n    }\n  };\n}\n\nexport default Control;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport Panel from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { getFlickingAttached } from \"../utils\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n\n/**\n * A {@link Control} that uses a release momentum to choose destination panel\n * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}\n */\nclass SnapControl extends Control {\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const clampedPosition = camera.clampToReachablePosition(position);\n    const anchorAtPosition = camera.findNearestAnchor(clampedPosition);\n\n    if (!anchorAtPosition || !activePanel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const prevPos = activePanel.position;\n\n    const isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n    const adjacentAnchor = (position > prevPos)\n      ? camera.getNextAnchor(anchorAtPosition)\n      : camera.getPrevAnchor(anchorAtPosition);\n\n    let targetPos: number;\n    let targetPanel: Panel;\n\n    if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n      // Move to anchor at position\n      targetPanel = anchorAtPosition.panel;\n      targetPos = anchorAtPosition.position;\n    } else if (isOverThreshold && adjacentAnchor) {\n      // Move to adjacent anchor\n      targetPanel = adjacentAnchor.panel;\n      targetPos = adjacentAnchor.position;\n    } else {\n      // Restore to active panel\n      targetPos = camera.clampToReachablePosition(activePanel.position);\n      targetPanel = activePanel;\n    }\n\n    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: targetPos,\n      duration,\n      newActivePanel: targetPanel,\n      axesEvent\n    });\n  }\n}\n\nexport default SnapControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link FreeControl}\n * @ko {@link FreeControl} 생성시 사용되는 옵션\n * @interface\n * @property {boolean} stopAtEdge Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n * <ko>스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다</ko>\n */\nexport interface FreeControlOptions {\n  stopAtEdge: boolean;\n}\n\n/**\n * A {@link Control} that can be scrolled freely without alignment\n * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}\n */\nclass FreeControl extends Control {\n  private _stopAtEdge: FreeControlOptions[\"stopAtEdge\"];\n\n  /**\n   * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n   * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get stopAtEdge() { return this._stopAtEdge; }\n\n  public set stopAtEdge(val: FreeControlOptions[\"stopAtEdge\"]) { this._stopAtEdge = val; }\n\n  /** */\n  public constructor({\n    stopAtEdge = true\n  }: Partial<FreeControlOptions> = {}) {\n    super();\n\n    this._stopAtEdge = stopAtEdge;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public async updatePosition(progressInPanel: number): Promise<void> {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      const panelRange = activePanel.range;\n      const newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      await camera.lookAt(camera.clampToReachablePosition(newPosition));\n    }\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking, \"Control\");\n\n    const camera = flicking.camera;\n    const targetPos = camera.clampToReachablePosition(position);\n\n    const anchorAtPosition = camera.findAnchorIncludePosition(targetPos);\n\n    if (!anchorAtPosition) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const targetPanel = anchorAtPosition.panel;\n\n    // Trigger only change event\n    if (targetPanel !== this._activePanel) {\n      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n    }\n\n    return this._animateToPosition({ position: this._stopAtEdge ? targetPos : position, duration, newActivePanel: targetPanel, axesEvent });\n  }\n}\n\nexport default FreeControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Control from \"./Control\";\nimport SnapControl from \"./SnapControl\";\nimport FreeControl from \"./FreeControl\";\nimport AxesController from \"./AxesController\";\nimport State from \"./states/State\";\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport StateMachine from \"./StateMachine\";\n\nexport {\n  Control,\n  SnapControl,\n  FreeControl,\n  AxesController,\n  State,\n  IdleState,\n  HoldingState,\n  DraggingState,\n  AnimatingState,\n  DisabledState,\n  StateMachine\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"./panel/Panel\";\n\n/**\n * A data component that has actual position where the camera should be stopped at\n * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트\n */\nclass AnchorPoint {\n  private _index: number;\n  private _pos: number;\n  private _panel: Panel;\n\n  /**\n   * Index of AnchorPoint\n   * @ko AnchorPoint의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of AnchorPoint\n   * @ko AnchorPoint의 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos; }\n  /**\n   * A {@link Panel} instance AnchorPoint is referencing to\n   * @ko AnchorPoint가 참조하고 있는 {@link Panel}\n   * @type {Panel}\n   * @readonly\n   */\n  public get panel() { return this._panel; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 객체</ko>\n   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>\n   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>\n   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>\n   */\n  public constructor({\n    index,\n    position,\n    panel\n  }: {\n    index: number;\n    position: number;\n    panel: Panel;\n  }) {\n    this._index = index;\n    this._pos = position;\n    this._panel = panel;\n  }\n}\n\nexport default AnchorPoint;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport * as ERROR from \"../const/error\";\nimport { ALIGN, DIRECTION, EVENTS } from \"../const/external\";\nimport { checkExistence, clamp, getFlickingAttached, getProgress, includes, parseAlign } from \"../utils\";\n\nexport interface CameraOptions {\n  align: FlickingOptions[\"align\"];\n}\n\n/**\n * A component that manages actual movement inside the viewport\n * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트\n */\nabstract class Camera {\n  // Options\n  protected _align: FlickingOptions[\"align\"];\n\n  // Internal states\n  protected _flicking: Flicking | null;\n  protected _el: HTMLElement;\n  protected _transform: string;\n  protected _position: number;\n  protected _alignPos: number;\n  protected _offset: number;\n  protected _range: { min: number; max: number };\n  protected _visiblePanels: Panel[];\n  protected _anchors: AnchorPoint[];\n  protected _needPanelTriggered: { prev: boolean; next: boolean };\n\n  // Internal states getter\n  /**\n   * The camera(`.flicking-camera`) element\n   * @ko 카메라(`.flicking-camera`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n  /**\n   * Current position of the camera\n   * @ko Camera의 현재 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._position; }\n  /**\n   * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at\n   * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option\n   * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get offset() { return this._offset; }\n  /**\n   * A range that Camera's {@link Camera#position position} can reach\n   * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get range() { return this._range; }\n  /**\n   * A difference between Camera's minimum and maximum position that can reach\n   * @ko Camera가 도달 가능한 최소/최대 좌표의 차이\n   * @type {number}\n   * @readonly\n   */\n  public get rangeDiff() { return this._range.max - this._range.min; }\n  /**\n   * An array of visible panels from the current position\n   * @ko 현재 보이는 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   */\n  public get visiblePanels() { return this._visiblePanels; }\n  /**\n   * A range of the visible area from the current position\n   * @ko 현재 위치에서 보이는 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get visibleRange() { return { min: this._position - this._alignPos, max: this._position - this._alignPos + this.size }; }\n  /**\n   * An array of {@link AnchorPoint}s that Camera can be stopped at\n   * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록\n   * @type {AnchorPoint[]}\n   * @readonly\n   */\n  public get anchorPoints() { return this._anchors; }\n  /**\n   * A current parameters of the Camera for updating {@link AxesController}\n   * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들\n   * @type {object}\n   * @property {object} range Camera {@link Camera#range range}<ko>Camera가 도달 가능한 범위({@link Camera#range range})</ko>\n   * @property {number} position Current position<ko>현재 좌표</ko>\n   * @property {boolean} circular A Boolean indicating whether the {@link Flicking#circular circular} option is enabled<ko>{@link Flicking#circular circular}옵션 활성화 여부</ko>\n   * @readonly\n   */\n  public get controlParams() { return { range: this._range, position: this._position, circular: false }; }\n  /**\n   * A Boolean value indicating whether Camera's over the minimum or maximum position reachable\n   * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다\n   * @type {boolean}\n   * @readonly\n   */\n  public get atEdge() { return this._position <= this._range.min || this._position >= this._range.max; }\n  /**\n   * Return the size of the viewport\n   * @ko 뷰포트 크기를 반환합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() {\n    const flicking = this._flicking;\n    return flicking\n      ? flicking.horizontal\n        ? flicking.viewport.width\n        : flicking.viewport.height\n      : 0;\n  }\n\n  /**\n   * Return the camera's position progress from the first panel to last panel\n   * Range is from 0 to last panel's index\n   * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다\n   * 범위는 0부터 마지막 패널의 인덱스까지입니다\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n    const position = this._position + this._offset;\n    const nearestAnchor = this.findNearestAnchor(this._position);\n\n    if (!flicking || !nearestAnchor) {\n      return NaN;\n    }\n\n    const nearestPanel = nearestAnchor.panel;\n    const panelPos = nearestPanel.position + nearestPanel.offset;\n    const bounceSize = flicking.control.controller.bounce!;\n\n    const { min: prevRange, max: nextRange } = this.range;\n    const rangeDiff = this.rangeDiff;\n\n    if (position === panelPos) {\n      return nearestPanel.index;\n    }\n\n    if (position < panelPos) {\n      const prevPanel = nearestPanel.prev();\n      let prevPosition = prevPanel\n        ? prevPanel.position + prevPanel.offset\n        : prevRange - bounceSize[0];\n\n      // Looped\n      if (prevPosition > panelPos) {\n        prevPosition -= rangeDiff;\n      }\n\n      return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);\n    } else {\n      const nextPanel = nearestPanel.next();\n      let nextPosition = nextPanel\n        ? nextPanel.position + nextPanel.offset\n        : nextRange + bounceSize[1];\n\n      // Looped\n      if (nextPosition < panelPos) {\n        nextPosition += rangeDiff;\n      }\n\n      return nearestPanel.index + getProgress(position, panelPos, nextPosition);\n    }\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element\n   * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n  }\n\n  /** */\n  public constructor({\n    align = ALIGN.CENTER\n  }: Partial<CameraOptions> = {}) {\n    this._flicking = null;\n    this._resetInternalValues();\n\n    // Options\n    this._align = align;\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @method\n   * @abstract\n   * @memberof Camera\n   * @instance\n   * @name updateRange\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public abstract updateRange(): this;\n\n  /**\n   * Initialize Camera\n   * @ko Camera를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element\n   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    const viewportEl = flicking.viewport.element;\n\n    checkExistence(viewportEl.firstElementChild, \"First element child of the viewport element\");\n    this._el = viewportEl.firstElementChild as HTMLElement;\n    this._checkTranslateSupport();\n\n    return this;\n  }\n\n  /**\n   * Destroy Camera and return to initial state\n   * @ko Camera를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): this {\n    this._flicking = null;\n    this._resetInternalValues();\n    return this;\n  }\n\n  /**\n   * Move to the given position and apply CSS transform\n   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다\n   * @param {number} pos A new position<ko>움직일 위치</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public async lookAt(pos: number): Promise<void> {\n    const prevPos = this._position;\n\n    this._position = pos;\n    await this._refreshVisiblePanels();\n    this._checkNeedPanel();\n    this._checkReachEnd(prevPos, pos);\n    this._applyTransform();\n  }\n\n  /**\n   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>\n   */\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    return this._anchors[anchor.index - 1] || null;\n  }\n\n  /**\n   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>\n   */\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    return this._anchors[anchor.index + 1] || null;\n  }\n\n  /**\n   * Return the camera's position progress in the panel below\n   * Value is from 0 to 1 when the camera's inside panel\n   * Value can be lower than 0 or bigger than 1 when it's in the margin area\n   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다\n   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다\n   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다\n   */\n  public getProgressInPanel(panel: Panel) {\n    const panelRange = panel.range;\n\n    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);\n  }\n\n  /**\n   * Return {@link AnchorPoint} that includes given position\n   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead\n   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다\n   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>\n   */\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n    const anchorsIncludingPosition = anchors.filter(anchor => anchor.panel.includePosition(position, true));\n\n    return anchorsIncludingPosition.reduce((nearest: AnchorPoint | null, anchor) => {\n      if (!nearest) return anchor;\n\n      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n        ? nearest\n        : anchor;\n    }, null);\n  }\n\n  /**\n   * Return {@link AnchorPoint} nearest to given position\n   * If there're no {@link AnchorPoint}s, return `null` instead\n   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다\n   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>\n   */\n  public findNearestAnchor(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (anchors.length <= 0) return null;\n\n    let prevDist = Infinity;\n    for (let anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {\n      const anchor = anchors[anchorIdx];\n      const dist = Math.abs(anchor.position - position);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return anchors[anchorIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return anchors[anchors.length - 1];\n  }\n\n  /**\n   * Clamp the given position between camera's range\n   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다\n   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>\n   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>\n   */\n  public clampToReachablePosition(position: number): number {\n    const range = this._range;\n    return clamp(position, range.min, range.max);\n  }\n\n  /**\n   * Check whether the given panel is inside of the Camera's range\n   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>\n   */\n  public canReach(panel: Panel): boolean {\n    const range = this._range;\n\n    if (panel.removed) return false;\n\n    const panelPos = panel.position;\n\n    return panelPos >= range.min && panelPos <= range.max;\n  }\n\n  /**\n   * Check whether the given panel element is visible at the current position\n   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>\n   */\n  public canSee(panel: Panel): boolean {\n    const visibleRange = this.visibleRange;\n    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.\n    return panel.includeRange(visibleRange.min, visibleRange.max, false);\n  }\n\n  /**\n   * Update Camera's {@link Camera#alignPosition alignPosition}\n   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateAlignPos(): this {\n    const align = this._align;\n\n    const alignVal = typeof align === \"object\"\n      ? (align as { camera: string | number }).camera\n      : align;\n\n    this._alignPos = parseAlign(alignVal, this.size);\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#anchorPoints anchorPoints}\n   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAnchors(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    this._anchors = panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n\n    return this;\n  }\n\n  /**\n   * Update Viewport's height to active panel's height\n   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAdaptiveHeight() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const activePanel = flicking.control.activePanel;\n\n    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;\n\n    flicking.viewport.setSize({\n      height: activePanel.height\n    });\n  }\n\n  public updateOffset() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const unRenderedPanels = flicking.panels.filter(panel => !panel.rendered);\n    const position = this._position;\n\n    this._offset = unRenderedPanels\n      .filter(panel => panel.position + panel.offset < position)\n      .reduce((offset, panel) => offset + panel.sizeIncludingMargin, 0);\n\n    this._applyTransform();\n  }\n\n  /**\n   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again\n   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetNeedPanelHistory(): this {\n    this._needPanelTriggered = { prev: false, next: false };\n    return this;\n  }\n\n  protected _resetInternalValues() {\n    this._position = 0;\n    this._alignPos = 0;\n    this._offset = 0;\n    this._range = { min: 0, max: 0 };\n    this._visiblePanels = [];\n    this._anchors = [];\n    this._needPanelTriggered = { prev: false, next: false };\n  }\n\n  protected async _refreshVisiblePanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    const newVisiblePanels = panels.filter(panel => this.canSee(panel));\n    const prevVisiblePanels = this._visiblePanels;\n    this._visiblePanels = newVisiblePanels;\n\n    const added: Panel[] = newVisiblePanels.filter(panel => !includes(prevVisiblePanels, panel));\n    const removed: Panel[] = prevVisiblePanels.filter(panel => !includes(newVisiblePanels, panel));\n\n    if (added.length > 0 || removed.length > 0) {\n      await flicking.renderer.render();\n\n      flicking.trigger(new ComponentEvent(EVENTS.VISIBLE_CHANGE, {\n        added,\n        removed,\n        visiblePanels: newVisiblePanels\n      }));\n    }\n  }\n\n  protected _checkNeedPanel(): void {\n    const needPanelTriggered = this._needPanelTriggered;\n\n    if (needPanelTriggered.prev && needPanelTriggered.next) return;\n\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      if (!needPanelTriggered.prev) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n      if (!needPanelTriggered.next) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n\n      return;\n    }\n\n    const cameraPosition = this._position;\n    const cameraSize = this.size;\n    const cameraRange = this._range;\n    const needPanelThreshold = flicking.needPanelThreshold;\n\n    const cameraPrev = cameraPosition - this._alignPos;\n    const cameraNext = cameraPrev + cameraSize;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    if (!needPanelTriggered.prev) {\n      const firstPanelPrev = firstPanel.range.min;\n\n      if (cameraPrev <= (firstPanelPrev + needPanelThreshold) || cameraPosition <= (cameraRange.min + needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n    }\n\n    if (!needPanelTriggered.next) {\n      const lastPanelNext = lastPanel.range.max;\n\n      if (cameraNext >= (lastPanelNext - needPanelThreshold) || cameraPosition >= (cameraRange.max - needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n    }\n  }\n\n  protected _checkReachEnd(prevPos: number, newPos: number): void {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const range = this._range;\n\n    const wasBetweenRange = prevPos > range.min && prevPos < range.max;\n    const isBetweenRange = newPos > range.min && newPos < range.max;\n\n    if (!wasBetweenRange || isBetweenRange) return;\n\n    const direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;\n\n    flicking.trigger(new ComponentEvent(EVENTS.REACH_EDGE, {\n      direction\n    }));\n  }\n\n  protected _applyTransform(): void {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n\n    const actualPosition = this._position - this._alignPos - this._offset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n  }\n\n  protected _checkTranslateSupport = () => {\n    const transforms = [\"webkitTransform\", \"msTransform\", \"MozTransform\", \"OTransform\", \"transform\"];\n\n    const supportedStyle = document.documentElement.style;\n    let transformName = \"\";\n    for (const prefixedTransform of transforms) {\n      if (prefixedTransform in supportedStyle) {\n        transformName = prefixedTransform;\n      }\n    }\n\n    if (!transformName) {\n      throw new FlickingError(ERROR.MESSAGE.TRANSFORM_NOT_SUPPORTED, ERROR.CODE.TRANSFORM_NOT_SUPPORTED);\n    }\n\n    this._transform = transformName;\n  };\n}\n\nexport default Camera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached } from \"../utils\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A {@link Camera} that can move from the position of the first panel to the position of the last panel\n * @ko 첫번째 패널의 좌표로부터 마지막 패널의 좌표로까지 이동할 수 있는 종류의 {@link Camera}\n */\nclass LinearCamera extends Camera {\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    this._range = { min: firstPanel?.position ?? 0, max: lastPanel?.position ?? 0 };\n    return this;\n  }\n}\n\nexport default LinearCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { DIRECTION } from \"../const/external\";\nimport { circulatePosition, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A data of the position that changes order of the panel elements\n * @ko 패널 엘리먼트 순서가 변경되는 좌표의 데이터\n * @interface\n * @property {Panel} panel Toggling panel<ko>순서를 변경할 패널</ko>\n * @property {DIRECTION} direction Toggling position<ko>순서를 변경할 방향</ko>\n * @property {boolean} toggled Whether the panel has toggled its position to `direction`<ko>`direction` 방향으로 패널 위치를 변경했는지 여부를 나타내는 값</ko>\n */\nexport interface TogglePoint {\n  panel: Panel;\n  direction: ValueOf<typeof DIRECTION>;\n  toggled: boolean;\n}\n\n/**\n * A {@link Camera} that connects the last panel and the first panel, enabling continuous loop\n * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera}\n */\nclass CircularCamera extends Camera {\n  private _circularOffset: number = 0;\n  private _circularEnabled: boolean = false;\n\n  public get offset() { return this._offset - this._circularOffset; }\n  public get controlParams() { return { range: this._range, position: this._position, circular: this._circularEnabled }; }\n\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    if (!this._circularEnabled || anchor.index !== 0) return super.getPrevAnchor(anchor);\n\n    const anchors = this._anchors;\n    const rangeDiff = this.rangeDiff;\n    const lastAnchor = anchors[anchors.length - 1];\n\n    return new AnchorPoint({\n      index: lastAnchor.index,\n      position: lastAnchor.position - rangeDiff,\n      panel: lastAnchor.panel\n    });\n  }\n\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (!this._circularEnabled || anchor.index !== anchors.length - 1) return super.getNextAnchor(anchor);\n\n    const rangeDiff = this.rangeDiff;\n    const firstAnchor = anchors[0];\n\n    return new AnchorPoint({\n      index: firstAnchor.index,\n      position: firstAnchor.position + rangeDiff,\n      panel: firstAnchor.panel\n    });\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    if (!this._circularEnabled) return super.findAnchorIncludePosition(position);\n\n    const range = this._range;\n    const positionInRange = circulatePosition(position, range.min, range.max);\n    const anchorInRange = super.findAnchorIncludePosition(positionInRange);\n\n    if (!anchorInRange) return null;\n\n    const rangeDiff = this.rangeDiff;\n\n    if (position < range.min) {\n      const loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    } else if (position > range.max) {\n      const loopCount = Math.floor((position - range.max) / rangeDiff) + 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    }\n\n    return anchorInRange;\n  }\n\n  public clampToReachablePosition(position: number): number {\n    // Basically all position is reachable for circular camera\n    return this._circularEnabled\n      ? position\n      : super.clampToReachablePosition(position);\n  }\n\n  public canReach(panel: Panel): boolean {\n    if (panel.removed) return false;\n\n    return this._circularEnabled\n      // Always reachable on circular mode\n      ? true\n      : super.canReach(panel);\n  }\n\n  public canSee(panel: Panel): boolean {\n    const range = this._range;\n    const rangeDiff = this.rangeDiff;\n    const visibleRange = this.visibleRange;\n    const visibleInCurrentRange = super.canSee(panel);\n\n    if (!this._circularEnabled) {\n      return visibleInCurrentRange;\n    }\n\n    // Check looped visible area for circular case\n    if (visibleRange.min < range.min) {\n      return visibleInCurrentRange || panel.includeRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff, false);\n    } else if (visibleRange.max > range.max) {\n      return visibleInCurrentRange || panel.includeRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff, false);\n    }\n\n    return visibleInCurrentRange;\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n\n    const panels = renderer.panels;\n    if (panels.length <= 0) {\n      this._resetInternalValues();\n      return this;\n    }\n\n    const firstPanel = panels[0]!;\n    const lastPanel = panels[panels.length - 1]!;\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    const visibleSize = this.size;\n    const panelSizeSum = lastPanelNext - firstPanelPrev;\n\n    const canSetCircularMode = panels\n      .every(panel => panelSizeSum - panel.size >= visibleSize);\n    this._circularEnabled = canSetCircularMode;\n\n    if (canSetCircularMode) {\n      this._range = { min: firstPanelPrev, max: lastPanelNext };\n\n      panels.forEach(panel => panel.updateCircularToggleDirection());\n    } else {\n      this._range = { min: firstPanel.position, max: lastPanel.position };\n    }\n\n    this._updateCircularOffset();\n\n    return this;\n  }\n\n  public async lookAt(pos: number) {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const prevPos = this._position;\n\n    if (pos === prevPos) return await super.lookAt(pos);\n\n    const panels = flicking.renderer.panels;\n    const toggled = panels.map(panel => panel.toggle(prevPos, pos));\n\n    this._position = pos;\n\n    if (toggled.some(isToggled => isToggled)) {\n      this._updateCircularOffset();\n      await flicking.renderer.render();\n    }\n\n    return await super.lookAt(pos);\n  }\n\n  protected _applyTransform(): void {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n\n    const actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n  }\n\n  protected _resetInternalValues() {\n    super._resetInternalValues();\n    this._circularOffset = 0;\n    this._circularEnabled = false;\n  }\n\n  private _calcPanelAreaSum(panels: Panel[]) {\n    return panels.reduce((sum: number, panel: Panel) => sum + panel.sizeIncludingMargin, 0);\n  }\n\n  private _updateCircularOffset() {\n    if (!this._circularEnabled) {\n      this._circularOffset = 0;\n      return;\n    }\n\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const toggledPrev: Panel[] = [];\n    const toggledNext: Panel[] = [];\n\n    flicking.panels\n      .filter(panel => panel.toggled)\n      .forEach(panel => {\n        if (panel.toggleDirection === DIRECTION.PREV) {\n          toggledPrev.push(panel);\n        } else {\n          toggledNext.push(panel);\n        }\n      });\n\n    this._circularOffset = this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);\n  }\n}\n\nexport default CircularCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Camera from \"./Camera\";\n\n/**\n * A {@link Camera} that set range not to go out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n * @ko 첫번째와 마지막 패널 밖으로 넘어가지 못하도록 범위를 설정하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 종류의 {@link Camera}\n */\nclass BoundCamera extends Camera {\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const renderer = flicking.renderer;\n    const alignPos = this._alignPos;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      this._range = { min: 0, max: 0 };\n      return this;\n    }\n\n    const viewportSize = this.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const canSetBoundMode = viewportSize < panelAreaSize;\n\n    if (canSetBoundMode) {\n      this._range = { min: firstPanelPrev + alignPos, max: lastPanelNext - viewportSize + alignPos };\n    } else {\n      this._range = { min: firstPanel.position, max: lastPanel.position };\n    }\n\n    return this;\n  }\n\n  public updateAnchors(): this {\n    const flicking = getFlickingAttached(this._flicking, \"Camera\");\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      this._anchors = [];\n      return this;\n    }\n\n    const range = this._range;\n    const reachablePanels = panels.filter(panel => this.canReach(panel));\n\n    if (reachablePanels.length > 0) {\n      const shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;\n      const shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;\n      const indexOffset = shouldPrependBoundAnchor ? 1 : 0;\n\n      const newAnchors = reachablePanels.map((panel, idx) => new AnchorPoint({\n        index: idx + indexOffset,\n        position: panel.position,\n        panel\n      }));\n\n      if (shouldPrependBoundAnchor) {\n        newAnchors.splice(0, 0, new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panels[reachablePanels[0].index - 1]\n        }));\n      }\n\n      if (shouldAppendBoundAnchor) {\n        newAnchors.push(new AnchorPoint({\n          index: newAnchors.length,\n          position: range.max,\n          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]\n        }));\n      }\n\n      this._anchors = newAnchors;\n    } else if (range.min !== range.max) {\n      // There're more than 2 panels\n      const nearestPanelAtMin = this._findNearestPanel(range.min, panels);\n      const panelAtMin = nearestPanelAtMin.index === panels.length - 1\n        ? nearestPanelAtMin.prev()!\n        : nearestPanelAtMin;\n      const panelAtMax = panelAtMin.next()!;\n\n      this._anchors = [\n        new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panelAtMin\n        }),\n        new AnchorPoint({\n          index: 1,\n          position: range.max,\n          panel: panelAtMax\n        })\n      ];\n    } else {\n      this._anchors = [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: this._findNearestPanel(range.min, panels)\n      })];\n    }\n\n    return this;\n  }\n\n  private _findNearestPanel(pos: number, panels: Panel[]): Panel {\n    let prevDist = Infinity;\n    for (let panelIdx = 0; panelIdx < panels.length; panelIdx++) {\n      const panel = panels[panelIdx];\n      const dist = Math.abs(panel.position - pos);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return panels[panelIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return panels[panels.length - 1];\n  }\n}\n\nexport default BoundCamera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Camera, { CameraOptions } from \"./Camera\";\nimport LinearCamera from \"./LinearCamera\";\nimport CircularCamera from \"./CircularCamera\";\nimport BoundCamera from \"./BoundCamera\";\n\nexport {\n  Camera,\n  LinearCamera,\n  CircularCamera,\n  BoundCamera\n};\n\nexport type {\n  CameraOptions\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nclass RawRenderingStrategy implements RenderingStrategy {\n  public updateRenderingPanels(flicking: Flicking) {\n    // RawRenderingStrategy always renders all panel elements\n    flicking.panels.forEach(panel => panel.markForShow());\n  }\n}\n\nexport default RawRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport { ALIGN } from \"../const/external\";\nimport { getFlickingAttached, getMinusCompensatedIndex, includes } from \"../utils\";\n\nimport RenderingStrategy from \"./RenderingStrategy/RenderingStrategy\";\nimport RawRenderingStrategy from \"./RenderingStrategy/RawRenderingStrategy\";\n\nexport interface RendererOptions {\n  align: FlickingOptions[\"align\"];\n  strategy: RenderingStrategy;\n}\n\n/**\n * A component that manages {@link Panel} and its elements\n * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트\n */\nabstract class Renderer {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _panels: Panel[];\n  protected _renderingStrategy: RenderingStrategy;\n\n  // Options\n  protected _align: RendererOptions[\"align\"];\n\n  // Internal states Getter\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._panels.length; }\n\n  // Options Getter\n  /**\n   * A {@link Panel}'s {@link Panel#align align} value that applied to all panels\n   * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: RendererOptions[\"align\"]) {\n    this._align = val;\n\n    const panelAlign = this._getPanelAlign();\n    this._panels.forEach(panel => { panel.align = panelAlign; });\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>\n   */\n  public constructor({\n    align = ALIGN.CENTER,\n    strategy = new RawRenderingStrategy()\n  }: Partial<RendererOptions> = {}) {\n    this._align = align;\n    this._flicking = null;\n    this._renderingStrategy = strategy;\n    this._panels = [];\n  }\n\n  /**\n   * Render panel elements inside the camera element\n   * @ko 패널 엘리먼트들을 카메라 엘리먼트 내부에 렌더링합니다\n   * @method\n   * @abstract\n   * @memberof Renderer\n   * @instance\n   * @name render\n   * @chainable\n   * @return {this}\n   */\n  public abstract render(): Promise<void>;\n  public abstract forceRenderAllPanels(): Promise<void>;\n\n  protected abstract _collectPanels(): void;\n  protected abstract _createPanel(el: any, options: PanelOptions): Panel;\n  protected abstract _insertPanelElements(panels: Panel[], nextSibling: Panel | null): void;\n  protected abstract _removePanelElements(panels: Panel[]): void;\n\n  /**\n   * Initialize Renderer\n   * @ko Renderer를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._collectPanels();\n\n    return this;\n  }\n\n  /**\n   * Destroy Renderer and return to initial state\n   * @ko Renderer를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._flicking = null;\n    this._panels = [];\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   */\n  public getPanel(index: number): Panel | null {\n    return this._panels[index] || null;\n  }\n\n  /**\n   * Update all panel sizes\n   * @ko 모든 패널의 크기를 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updatePanelSize(): this {\n    this._panels.forEach(panel => panel.resize());\n    return this;\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {any[]} elements An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   */\n  public batchInsert(...items: Array<{\n    index: number;\n    elements: any[];\n  }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const { control } = flicking;\n    const align = this._getPanelAlign();\n\n    const allPanelsInserted = items.reduce((addedPanels, item) => {\n      const insertingIdx = getMinusCompensatedIndex(item.index, panels.length);\n      const panelsPushed = panels.slice(insertingIdx);\n      const panelsInserted = item.elements.map(el => this._createPanel(el, { index: insertingIdx, align, flicking }));\n\n      panels.splice(insertingIdx, 0, ...panelsInserted);\n\n      // Resize the newly added panels\n      panelsInserted.forEach(panel => panel.resize());\n\n      const insertedSize = this._getPanelSizeSum(panelsInserted);\n\n      // Update panel indexes & positions\n      panelsPushed.forEach(panel => {\n        panel.increaseIndex(panelsInserted.length);\n        panel.increasePosition(insertedSize);\n      });\n\n      // Insert the actual elements as camera element's children\n      this._insertPanelElements(panelsInserted, panelsPushed[0] ?? null);\n\n      return [...addedPanels, ...panelsInserted];\n    }, []);\n\n    if (allPanelsInserted.length <= 0) return [];\n\n    // Update camera & control\n    this._updateCameraAndControl();\n\n    void this.render();\n\n    // Move to the first panel added if no panels existed\n    // FIXME: fix for animating case\n    if (allPanelsInserted.length > 0 && !control.animating) {\n      void control.moveToPanel(control.activePanel || allPanelsInserted[0], {\n        duration: 0\n      }).catch(() => void 0);\n    }\n\n    flicking.camera.updateOffset();\n\n    return allPanelsInserted;\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public batchRemove(...items: Array<{ index: number; deleteCount: number }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const { camera, control } = flicking;\n    const activePanel = control.activePanel;\n    const activeIndex = control.activeIndex;\n\n    const allPanelsRemoved = items.reduce((removed, item) => {\n      const { index, deleteCount } = item;\n      const removingIdx = getMinusCompensatedIndex(index, panels.length);\n\n      const panelsPulled = panels.slice(removingIdx + deleteCount);\n      const panelsRemoved = panels.splice(removingIdx, deleteCount);\n\n      if (panelsRemoved.length <= 0) return [];\n\n      // Update panel indexes & positions\n      const removedSize = this._getPanelSizeSum(panelsRemoved);\n      panelsPulled.forEach(panel => {\n        panel.decreaseIndex(panelsRemoved.length);\n        panel.decreasePosition(removedSize);\n      });\n\n      this._removePanelElements(panelsRemoved);\n\n      // Remove panel elements\n      panelsRemoved.forEach(panel => panel.destroy());\n\n      // Update camera & control\n      this._updateCameraAndControl();\n\n      if (includes(panelsRemoved, activePanel)) {\n        control.resetActive();\n      }\n\n      return [...removed, ...panelsRemoved];\n    }, []);\n\n    void this.render();\n\n    // FIXME: fix for animating case\n    if (allPanelsRemoved.length > 0 && !control.animating) {\n      const targetPanel = includes(allPanelsRemoved, activePanel)\n        ? (panels[activeIndex] || panels[panels.length - 1])\n        : activePanel;\n\n      if (targetPanel) {\n        void control.moveToPanel(targetPanel, {\n          duration: 0\n        }).catch(() => void 0);\n      } else {\n        // All panels removed\n        void camera.lookAt(0);\n      }\n    }\n\n    flicking.camera.updateOffset();\n\n    return allPanelsRemoved;\n  }\n\n  protected _getPanelAlign() {\n    const align = this._align;\n\n    return typeof align === \"object\"\n      ? (align as { panel: string | number }).panel\n      : align;\n  }\n\n  protected _getPanelSizeSum(panels: Panel[]): number {\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    const marginDiff = lastPanel.margin.next - firstPanel.margin.prev;\n\n    return (lastPanel.range.max - firstPanel.range.min) + marginDiff;\n  }\n\n  protected _updateCameraAndControl() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const { camera, control } = flicking;\n\n    camera.updateRange();\n    camera.updateAnchors();\n    camera.resetNeedPanelHistory();\n    control.updateInput();\n  }\n}\n\nexport default Renderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { getProgress, getStyle, parseAlign } from \"../../utils\";\nimport { ALIGN, DIRECTION } from \"../../const/external\";\nimport { LiteralUnion, ValueOf } from \"../../type/internal\";\n\nexport interface PanelOptions {\n  index: number;\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number;\n  flicking: Flicking;\n}\n\nabstract class Panel {\n  // Internal States\n  protected _flicking: Flicking;\n  protected _index: number;\n  protected _pos: number;\n  protected _size: number;\n  protected _height: number;\n  protected _margin: { prev: number; next: number };\n  protected _alignPos: number; // Actual align pos\n  protected _removed: boolean;\n  protected _toggleDirection: ValueOf<typeof DIRECTION>;\n  protected _toggled: boolean;\n  protected _togglePosition: number;\n\n  // Options\n  protected _align: PanelOptions[\"align\"];\n\n  // Internal States Getter\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  abstract get element(): HTMLElement;\n  /**\n   * Index of the panel\n   * @ko 패널의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of the panel, including {@link Panel#alignPosition alignPosition}\n   * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos + this._alignPos; }\n  /**\n   * Cached size of the panel element\n   * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else\n   * @ko 패널 엘리먼트의 캐시된 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() { return this._size; }\n  /**\n   * Panel's size including CSS `margin`\n   * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else\n   * @ko CSS `margin`을 포함한 패널의 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다\n   * @type {number}\n   * @readonly\n   */\n  public get sizeIncludingMargin() { return this._size + this._margin.prev + this._margin.next; }\n  /**\n   * Height of the panel element\n   * @ko 패널 엘리먼트의 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height; }\n  /**\n   * Cached CSS `margin` value of the panel element\n   * @ko 패널 엘리먼트의 CSS `margin` 값\n   * @type {object}\n   * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>\n   * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>\n   * @readonly\n   */\n  public get margin() { return this._margin; }\n  /**\n   * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at\n   * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * A value indicating whether the panel's {@link Flicking#remove remove}d\n   * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get removed() { return this._removed; }\n  /**\n   * A value indicating whether the panel's element is being rendered on the screen\n   * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract get rendered();\n  /**\n   * Panel element's range of the bounding box\n   * @ko 패널 엘리먼트의 Bounding box 범위\n   * @type {object}\n   * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)\n   * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)\n   * @readonly\n   */\n  public get range() { return { min: this._pos, max: this._pos + this._size }; }\n  /**\n   * A value indicating whether the panel's position is toggled by circular behavior\n   * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get toggled() { return this._toggled; }\n  /**\n   * A direction where the panel's position is toggled\n   * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향\n   * @type {DIRECTION}\n   * @readonly\n   */\n  public get toggleDirection() { return this._toggleDirection; }\n  /**\n   * Actual position offset determined by {@link Panel#order}\n   * @ko {@link Panel#order}에 의한 실제 위치 변경값\n   * @type {number}\n   * @readonly\n   */\n  public get offset() {\n    const toggleDirection = this._toggleDirection;\n    const cameraRangeDiff = this._flicking.camera.rangeDiff;\n\n    return toggleDirection === DIRECTION.NONE || !this._toggled\n      ? 0\n      : toggleDirection === DIRECTION.PREV\n        ? -cameraRangeDiff\n        : cameraRangeDiff;\n  }\n\n  /**\n   * Progress of movement between previous or next panel relative to current panel\n   * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n\n    return this.index - flicking.camera.progress;\n  }\n\n  /**\n   * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)\n   * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)\n   * @type {number}\n   * @readonly\n   */\n  public get outsetProgress() {\n    const position = this.position + this.offset;\n    const alignPosition = this._alignPos;\n    const camera = this._flicking.camera;\n    const camPos = camera.position;\n\n    if (camPos === position) {\n      return 0;\n    }\n\n    if (camPos < position) {\n      const disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;\n\n      return -getProgress(camPos, position, disappearPosNext);\n    } else {\n      const disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);\n\n      return 1 - getProgress(camPos, disappearPosPrev, position);\n    }\n  }\n\n  /**\n   * Percentage of area where panel is visible in the viewport\n   * @ko 뷰포트 안에서 패널이 보이는 영역의 비율\n   * @type {number}\n   * @readonly\n   */\n  public get visibleRatio() {\n    const range = this.range;\n    const size = this._size;\n    const offset = this.offset;\n    const visibleRange = this._flicking.camera.visibleRange;\n\n    const checkingRange = {\n      min: range.min + offset,\n      max: range.max + offset\n    };\n\n    if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {\n      return 0;\n    }\n\n    let visibleSize = size;\n\n    if (visibleRange.min > checkingRange.min) {\n      visibleSize -= visibleRange.min - checkingRange.min;\n    }\n    if (visibleRange.max < checkingRange.max) {\n      visibleSize -= checkingRange.max - visibleRange.max;\n    }\n\n    return visibleSize / size;\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element\n   * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Getter\n  public set align(val: PanelOptions[\"align\"]) { this._align = val; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor({\n    index,\n    align,\n    flicking\n  }: PanelOptions) {\n    this._index = index;\n    this._flicking = flicking;\n\n    this._align = align;\n\n    this._removed = false;\n    this._resetInternalStates();\n  }\n\n  /**\n   * Mark panel element to be appended on the camera element\n   * @internal\n   */\n  public abstract markForShow();\n\n  /**\n   * Mark panel element to be removed from the camera element\n   * @internal\n   */\n  public abstract markForHide();\n\n  /**\n   * Update size of the panel\n   * @ko 패널의 크기를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public resize(): this {\n    const el = this.element;\n    const elStyle = getStyle(el);\n    const flicking = this._flicking;\n    const horizontal = flicking.horizontal;\n    const prevPanel = flicking.renderer.panels[this._index - 1];\n\n    this._size = horizontal ? el.offsetWidth : el.offsetHeight;\n\n    this._margin = horizontal\n      ? {\n        prev: parseFloat(elStyle.marginLeft || \"0\"),\n        next: parseFloat(elStyle.marginRight || \"0\")\n      } : {\n        prev: parseFloat(elStyle.marginTop || \"0\"),\n        next: parseFloat(elStyle.marginBottom || \"0\")\n      };\n\n    this._pos = prevPanel\n      ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev\n      : this._margin.prev;\n\n    this._height = horizontal ? el.offsetHeight : this._size;\n\n    this._updateAlignPos();\n\n    return this;\n  }\n\n  /**\n   * Check whether the given element is inside of this panel's {@link Panel#element element}\n   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다\n   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>\n   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>\n   */\n  public contains(element: HTMLElement): boolean {\n    return this.element.contains(element);\n  }\n\n  /**\n   * Reset internal state and set {@link Panel#removed removed} to `true`\n   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.\n   * @return {void}\n   */\n  public destroy(): void {\n    this._resetInternalStates();\n    this._removed = true;\n  }\n\n  /**\n   * Check whether the given position is inside of this panel's {@link Panel#range range}\n   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.\n   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>\n   */\n  public includePosition(pos: number, includeMargin: boolean = false): boolean {\n    return this.includeRange(pos, pos, includeMargin);\n  }\n\n  /**\n   * Check whether the given range is fully included in this panel's area\n   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>\n   */\n  public includeRange(min: number, max: number, includeMargin: boolean = false): boolean {\n    const margin = this._margin;\n    const panelRange = this.range;\n\n    if (includeMargin) {\n      panelRange.min -= margin.prev;\n      panelRange.max += margin.next;\n    }\n\n    return max >= panelRange.min && min <= panelRange.max;\n  }\n\n  /**\n   * Move {@link Camera} to this panel\n   * @ko {@link Camera}를 이 패널로 이동합니다\n   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>\n   */\n  public focus(duration?: number) {\n    return this._flicking.moveTo(this._index, duration);\n  }\n\n  /**\n   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel\n   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>\n   */\n  public prev(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1)\n      : renderer.getPanel(index - 1);\n  }\n\n  /**\n   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel\n   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>\n   */\n  public next(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1)\n      : renderer.getPanel(index + 1);\n  }\n\n  /**\n   * Increase panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increaseIndex(val: number): this {\n    this._index += Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Decrease panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreaseIndex(val: number): this {\n    this._index -= Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Increase panel's position by the given value\n   * @ko 패널의 위치를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increasePosition(val: number): this {\n    this._moveBy(Math.max(val, 0));\n    return this;\n  }\n\n  /**\n   * Decrease panel's position by the given value\n   * @ko 패널의위치를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreasePosition(val: number): this {\n    this._moveBy(-Math.max(val, 0));\n    return this;\n  }\n\n  /**\n   * @internal\n   * @return {boolean} toggled\n   */\n  public toggle(prevPos: number, newPos: number): boolean {\n    const toggleDirection = this._toggleDirection;\n    const togglePosition = this._togglePosition;\n\n    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;\n\n    const prevToggled = this._toggled;\n\n    if (newPos > prevPos) {\n      if (togglePosition >= prevPos && togglePosition <= newPos) {\n        this._toggled = toggleDirection === DIRECTION.NEXT;\n      }\n    } else {\n      if (togglePosition <= prevPos && togglePosition >= newPos) {\n        this._toggled = toggleDirection !== DIRECTION.NEXT;\n      }\n    }\n\n    return prevToggled !== this._toggled;\n  }\n\n  /**\n   * @internal\n   */\n  public updateCircularToggleDirection(): this {\n    const flicking = this._flicking;\n\n    if (!flicking.circularEnabled) {\n      this._toggleDirection = DIRECTION.NONE;\n      this._toggled = false;\n      return this;\n    }\n\n    const camera = flicking.camera;\n    const camRange = camera.range;\n    const camAlignPosition = camera.alignPosition;\n    const camVisibleRange = camera.visibleRange;\n    const camVisibleSize = camVisibleRange.max - camVisibleRange.min;\n\n    const minimumVisible = camRange.min - camAlignPosition;\n    const maximumVisible = camRange.max - camAlignPosition + camVisibleSize;\n\n    const shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);\n    const shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);\n\n    this._toggled = false;\n    if (shouldBeVisibleAtMin) {\n      this._toggleDirection = DIRECTION.PREV;\n      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;\n      this.toggle(Infinity, camera.position);\n    } else if (shouldBeVisibleAtMax) {\n      this._toggleDirection = DIRECTION.NEXT;\n      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;\n      this.toggle(-Infinity, camera.position);\n    } else {\n      this._toggleDirection = DIRECTION.NONE;\n      this._togglePosition = 0;\n    }\n\n    return this;\n  }\n\n  private _moveBy(val: number): this {\n    this._pos += val;\n\n    return this;\n  }\n\n  private _updateAlignPos() {\n    this._alignPos = parseAlign(this._align, this._size);\n  }\n\n  private _resetInternalStates() {\n    this._size = 0;\n    this._pos = 0;\n    this._margin = { prev: 0, next: 0 };\n    this._height = 0;\n    this._alignPos = 0;\n    this._toggled = false;\n    this._togglePosition = 0;\n    this._toggleDirection = DIRECTION.NONE;\n  }\n}\n\nexport default Panel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel, { PanelOptions } from \"./Panel\";\n\nexport interface ElementPanelOptions extends PanelOptions {\n  el: HTMLElement;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass ElementPanel extends Panel {\n  private _el: HTMLElement;\n  private _rendered: boolean;\n\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  public get rendered() { return this._rendered; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {HTMLElement} [options.el] A `HTMLElement` panel's referencing<ko>패널이 참조하는 `HTMLElement`</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: ElementPanelOptions) {\n    super(options);\n\n    this._el = options.el;\n    this._rendered = true;\n  }\n\n  public markForShow() {\n    this._rendered = true;\n  }\n\n  public markForHide() {\n    this._rendered = false;\n  }\n}\n\nexport default ElementPanel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached, toArray } from \"../utils\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport ElementPanel from \"../core/panel/ElementPanel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nclass VanillaRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async render() {\n    const strategy = this._renderingStrategy;\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraEl = flicking.camera.element;\n    const wasRenderedPanels = this._panels.filter(panel => panel.element.parentElement === cameraEl);\n\n    strategy.updateRenderingPanels(flicking);\n    const renderingPanels = this._getRenderingPanelsByOrder();\n\n    this._removePanelElements(wasRenderedPanels.filter(panel => !panel.rendered));\n    this._insertPanelElements(renderingPanels.filter(panel => panel.element.parentElement !== cameraEl), null);\n    this._resetPanelElementOrder(renderingPanels);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async forceRenderAllPanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const fragment = document.createDocumentFragment();\n\n    this._panels.forEach(panel => fragment.appendChild(panel.element));\n\n    this._removeAllChildsFromCamera();\n\n    cameraElement.appendChild(fragment);\n  }\n\n  protected _collectPanels() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n\n    const cameraElement = flicking.camera.element;\n\n    // Remove all text nodes in the camera element\n    toArray(cameraElement.childNodes).forEach(node => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        cameraElement.removeChild(node);\n      }\n    });\n\n    const align = this._getPanelAlign();\n    const cameraChilds = toArray(cameraElement.children);\n\n    this._panels = cameraChilds.map(\n      (el: HTMLElement, index: number) => new ElementPanel({ flicking, el, index, align })\n    );\n  }\n\n  protected _createPanel(el: HTMLElement, options: PanelOptions): ElementPanel {\n    return new ElementPanel({ el, ...options });\n  }\n\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null) {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const nextSiblingElement = nextSibling?.element || null;\n    const fragment = document.createDocumentFragment();\n\n    panels.forEach(panel => fragment.appendChild(panel.element));\n    cameraElement.insertBefore(fragment, nextSiblingElement);\n\n    return this;\n  }\n\n  protected _removePanelElements(panels: Panel[]): this {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraElement = flicking.camera.element;\n\n    panels.forEach(panel => {\n      cameraElement.removeChild(panel.element);\n    });\n\n    return this;\n  }\n\n  private _resetPanelElementOrder(panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraEl = flicking.camera.element;\n\n    // We're using reversed panels here as last panel should be the last element of camera element\n    const reversedPanels = [...panels].reverse();\n    reversedPanels.forEach((panel, idx) => {\n      const nextPanel = reversedPanels[idx - 1];\n      const nextPanelEl = nextPanel ? nextPanel.element : null;\n\n      if (panel.element.nextElementSibling !== nextPanelEl) {\n        cameraEl.insertBefore(panel.element, nextPanelEl);\n      }\n    });\n  }\n\n  private _removeAllChildsFromCamera() {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const cameraElement = flicking.camera.element;\n\n    // Remove other elements\n    while (cameraElement.firstChild) {\n      cameraElement.removeChild(cameraElement.firstChild);\n    }\n  }\n\n  private _getRenderingPanelsByOrder(): Panel[] {\n    const flicking = getFlickingAttached(this._flicking, \"Renderer\");\n    const panels = flicking.renderer.panels;\n\n    return panels.filter(panel => panel.rendered)\n      .sort((a, b) => (a.position + a.offset) - (b.position + b.offset));\n  }\n}\n\nexport default VanillaRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nabstract class ExternalRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null): void {\n    // DO NOTHING\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _removePanelElements(panels: Panel[]): void {\n    // DO NOTHING\n  }\n}\n\nexport default ExternalRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nclass VisibleRenderingStrategy implements RenderingStrategy {\n  public updateRenderingPanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n}\n\nexport default VisibleRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Renderer, { RendererOptions } from \"./Renderer\";\nimport VanillaRenderer from \"./VanillaRenderer\";\nimport ExternalRenderer from \"./ExternalRenderer\";\n\n\nexport {\n  Renderer,\n  VanillaRenderer,\n  ExternalRenderer\n};\n\nexport * from \"./RenderingStrategy\";\n\nexport type {\n  RendererOptions\n};\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component, { ComponentEvent } from \"@egjs/component\";\n\nimport FlickingError from \"./core/FlickingError\";\nimport Viewport from \"./core/Viewport\";\nimport { Panel } from \"./core/panel\";\nimport { Control, FreeControl, SnapControl } from \"./control\";\nimport { BoundCamera, Camera, CircularCamera, LinearCamera } from \"./camera\";\nimport { Renderer, VanillaRenderer, ExternalRenderer, RawRenderingStrategy, VisibleRenderingStrategy } from \"./renderer\";\nimport { EVENTS, ALIGN, MOVE_TYPE, DIRECTION } from \"./const/external\";\nimport * as ERROR from \"./const/error\";\nimport { findIndex, getElement, includes, parseElement } from \"./utils\";\nimport { HoldStartEvent, HoldEndEvent, MoveStartEvent, SelectEvent, MoveEvent, MoveEndEvent, WillChangeEvent, WillRestoreEvent, NeedPanelEvent, VisibleChangeEvent, ReachEdgeEvent, ReadyEvent, AfterResizeEvent, BeforeResizeEvent, ChangedEvent, RestoredEvent } from \"./type/event\";\nimport { LiteralUnion, ValueOf } from \"./type/internal\";\nimport { ElementLike, Plugin, Status, MoveTypeOptions } from \"./type/external\";\n\n/**\n * @interface\n */\nexport interface FlickingEvents {\n  [EVENTS.READY]: ReadyEvent;\n  [EVENTS.BEFORE_RESIZE]: BeforeResizeEvent;\n  [EVENTS.AFTER_RESIZE]: AfterResizeEvent;\n  [EVENTS.HOLD_START]: HoldStartEvent;\n  [EVENTS.HOLD_END]: HoldEndEvent;\n  [EVENTS.MOVE_START]: MoveStartEvent;\n  [EVENTS.MOVE]: MoveEvent;\n  [EVENTS.MOVE_END]: MoveEndEvent;\n  [EVENTS.WILL_CHANGE]: WillChangeEvent;\n  [EVENTS.CHANGED]: ChangedEvent;\n  [EVENTS.WILL_RESTORE]: WillRestoreEvent;\n  [EVENTS.RESTORED]: RestoredEvent;\n  [EVENTS.SELECT]: SelectEvent;\n  [EVENTS.NEED_PANEL]: NeedPanelEvent;\n  [EVENTS.VISIBLE_CHANGE]: VisibleChangeEvent;\n  [EVENTS.REACH_EDGE]: ReachEdgeEvent;\n}\n\n/**\n * @interface\n */\nexport interface FlickingOptions {\n  // UI / LAYOUT\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number | { panel: number | string; camera: number | string };\n  defaultIndex: number;\n  horizontal: boolean;\n  circular: boolean;\n  bound: boolean;\n  adaptive: boolean;\n  // EVENT\n  needPanelThreshold: number;\n  // ANIMATION\n  deceleration: number;\n  duration: number;\n  easing: (x: number) => number;\n  // INPUT\n  inputType: string[];\n  moveType: ValueOf<typeof MOVE_TYPE> | MoveTypeOptions<ValueOf<typeof MOVE_TYPE>>;\n  threshold: number;\n  interruptable: boolean;\n  bounce: number | string | [number | string, number | string];\n  iOSEdgeSwipeThreshold: number;\n  preventClickOnDrag: boolean;\n  disableOnInit: boolean;\n  // PERFORMANCE\n  renderOnlyVisible: boolean;\n  // OTHERS\n  autoInit: boolean;\n  autoResize: boolean;\n  renderExternal: {\n    renderer: typeof ExternalRenderer;\n    rendererOptions: {[key: string]: any};\n  } | null;\n}\n\n/**\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|@egjs/component}\n * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}\n */\nclass Flicking extends Component<FlickingEvents> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @type {string}\n   * @readonly\n   * @example\n   * ```ts\n   * Flicking.VERSION;  // ex) 4.0.0\n   * ```\n   */\n  public static VERSION = \"#__VERSION__#\";\n\n  // Core components\n  private _viewport: Viewport;\n  private _camera: Camera;\n  private _control: Control;\n  private _renderer: Renderer;\n\n  // Options\n  private _align: FlickingOptions[\"align\"];\n  private _defaultIndex: FlickingOptions[\"defaultIndex\"];\n  private _horizontal: FlickingOptions[\"horizontal\"];\n  private _circular: FlickingOptions[\"circular\"];\n  private _bound: FlickingOptions[\"bound\"];\n  private _adaptive: FlickingOptions[\"adaptive\"];\n  private _needPanelThreshold: FlickingOptions[\"needPanelThreshold\"];\n  private _deceleration: FlickingOptions[\"deceleration\"];\n  private _duration: FlickingOptions[\"duration\"];\n  private _easing: FlickingOptions[\"easing\"];\n  private _inputType: FlickingOptions[\"inputType\"];\n  private _moveType: FlickingOptions[\"moveType\"];\n  private _threshold: FlickingOptions[\"threshold\"];\n  private _interruptable: FlickingOptions[\"interruptable\"];\n  private _bounce: FlickingOptions[\"bounce\"];\n  private _iOSEdgeSwipeThreshold: FlickingOptions[\"iOSEdgeSwipeThreshold\"];\n  private _preventClickOnDrag: FlickingOptions[\"preventClickOnDrag\"];\n  private _disableOnInit: FlickingOptions[\"disableOnInit\"];\n  private _renderOnlyVisible: FlickingOptions[\"renderOnlyVisible\"];\n  private _autoResize: FlickingOptions[\"autoResize\"];\n  private _autoInit: FlickingOptions[\"autoInit\"];\n  private _renderExternal: FlickingOptions[\"renderExternal\"];\n\n  // Internal State\n  private _initialized: boolean;\n  private _plugins: Plugin[];\n\n  // Components\n  /**\n   * {@link Control} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스\n   * @type {Control}\n   * @default SnapControl\n   * @readonly\n   * @see Control\n   * @see SnapControl\n   * @see FreeControl\n   */\n  public get control() { return this._control; }\n  /**\n   * {@link Camera} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스\n   * @type {Camera}\n   * @default LinearCamera\n   * @readonly\n   * @see Camera\n   * @see LinearCamera\n   * @see BoundCamera\n   * @see CircularCamera\n   */\n  public get camera() { return this._camera; }\n  /**\n   * {@link Renderer} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스\n   * @type {Renderer}\n   * @default VanillaRenderer\n   * @readonly\n   * @see Renderer\n   * @see VanillaRenderer\n   * @see ExternalRenderer\n   */\n  public get renderer() { return this._renderer; }\n  /**\n   * A component that manages viewport size\n   * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n   * @type {Viewport}\n   * @readonly\n   * @see Viewport\n   */\n  public get viewport() { return this._viewport; }\n  // Internal States\n  /**\n   * Whether Flicking's {@link Flicking#init init()} is called.\n   * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.\n   * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.\n   * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get initialized() { return this._initialized; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._camera.controlParams.circular; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get index() { return this._control.activeIndex; }\n  /**\n   * The root(`.flicking-viewport`) element\n   * @ko root(`.flicking-viewport`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._viewport.element; }\n  /**\n   * Currently active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel}\n   * @readonly\n   * @see Panel\n   */\n  public get currentPanel() { return this._control.activePanel; }\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._renderer.panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._renderer.panelCount; }\n  /**\n   * Array of panels that is visible at the current position\n   * @ko 현재 보이는 패널의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get visiblePanels() { return this._camera.visiblePanels; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._control.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._control.holding; }\n  /**\n   * A current list of activated plugins\n   * @ko 현재 활성화된 플러그인 목록\n   * @type {Plugin[]}\n   * @readonly\n   */\n  public get activePlugins() { return this._plugins; }\n\n  // Options Getter\n  // UI / LAYOUT\n  /**\n   * Align position of the panels within viewport. You can set different values each for the panel and camera\n   * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다\n   * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}\n   * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>\n   * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>\n   * @default \"center\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // Literal strings\n   *   \"prev\", \"center\", \"next\",\n   *   // % values, applied to both panel & camera\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000,\n   *   // Setting a different value for panel & camera\n   *   { panel: \"10%\", camera: \"25%\" }\n   * ];\n   *\n   * possibleOptions.forEach(align => {\n   *   new Flicking(\"#el\", { align });\n   * });\n   * ```\n   */\n  public get align() { return this._align; }\n  /**\n   * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer\n   * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다\n   * @type {number}\n   * @default 0\n   */\n  public get defaultIndex() { return this._defaultIndex; }\n  /**\n   * Direction of panel movement (true: horizontal, false: vertical)\n   * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)\n   * @type {boolean}\n   * @default true\n   */\n  public get horizontal() { return this._horizontal; }\n  /**\n   * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.\n   * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get circular() { return this._circular; }\n  /**\n   * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n   * Only can be enabled when `circular=false`\n   * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다\n   * `circular=false`인 경우에만 사용할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get bound() { return this._bound; }\n  /**\n   * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`\n   * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get adaptive() { return this._adaptive; }\n  // EVENTS\n  /**\n   * A Threshold from viewport edge before triggering `needPanel` event\n   * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리\n   * @type {number}\n   * @default 0\n   */\n  public get needPanelThreshold() { return this._needPanelThreshold; }\n  // ANIMATION\n  /**\n   * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time\n   * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다\n   * @type {number}\n   * @default 0.0075\n   */\n  public get deceleration() { return this._deceleration; }\n  /**\n   * An easing function applied to the panel movement animation. Default value is `easeOutCubic`\n   * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다\n   * @type {function}\n   * @default x => 1 - Math.pow(1 - x, 3)\n   * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n   */\n  public get easing() { return this._easing; }\n  /**\n   * Default duration of the animation (ms)\n   * @ko 디폴트 애니메이션 재생 시간 (ms)\n   * @type {number}\n   * @default 500\n   */\n  public get duration() { return this._duration; }\n  // INPUT\n  /**\n   * Types of input devices to enable\n   * @ko 활성화할 입력 장치 종류\n   * @type {string[]}\n   * @default [\"touch\", \"mouse\"]\n   * @see {@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Possible values (PanInputOption#inputType)}\n   * <ko>{@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 가능한 값들 (PanInputOption#inputType)}</ko>\n   */\n  public get inputType() { return this._inputType; }\n  /**\n   * Movement style by user input. This will change instance type of {@link Flicking#control}\n   * You can use the values of the constant {@link MOVE_TYPE}\n   * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다\n   * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다\n   * @type {MOVE_TYPE | Pair<string, object>}\n   * @default \"snap\"\n   * @example\n   * |moveType|control|options|\n   * |:---:|:---:|:---:|\n   * |\"snap\"|{@link SnapControl}||\n   * |\"freeScroll\"|{@link FreeControl}|{@link FreeControlOptions}|\n   *\n   * ```ts\n   * import Flicking, { MOVE_TYPE } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking({\n   *   moveType: MOVE_TYPE.SNAP\n   * });\n   * ```\n   *\n   * ```ts\n   * const flicking = new Flicking({\n   *   // If you want more specific settings for the moveType\n   *   // [moveType, options for that moveType]\n   *   // In this case, it's [\"freeScroll\", FreeControlOptions]\n   *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]\n   * });\n   * ```\n   */\n  public get moveType() { return this._moveType; }\n  /**\n   * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.\n   * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.\n   * @type {number}\n   * @default 40\n   */\n  public get threshold() { return this._threshold; }\n  /**\n   * Set animation to be interruptable by click/touch.\n   * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get interruptable() { return this._interruptable; }\n  /**\n   * The size value of the bounce area. Only can be enabled when `circular=false`.\n   * You can set different bounce value for prev/next direction by using array.\n   * `number` for px value, and `string` for px, and % value relative to viewport size.\n   * You have to call {@link Control#updateInput} after changing this to take effect.\n   * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.\n   * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.\n   * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.\n   * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.\n   * @type {string | number | Array<string | number>}\n   * @default \"20%\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // % values, relative to viewport element(\".flicking-viewport\")'s size\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000\n   * ];\n   * ```\n   *\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#el\", { bounce: \"20%\" });\n   *\n   * flicking.bounce = \"100%\";\n   * flicking.control.updateInput(); // Call this to update!\n   * ```\n   */\n  public get bounce() { return this._bounce; }\n  /**\n   * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward\n   * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)\n   * @type {number}\n   * @default 30\n   */\n  public get iOSEdgeSwipeThreshold() { return this._iOSEdgeSwipeThreshold; }\n  /**\n   * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element\n   * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get preventClickOnDrag() { return this._preventClickOnDrag; }\n  /**\n   * Automatically call {@link Flicking#disableInput disableInput()} on initialization\n   * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다\n   * @type {boolean}\n   * @default false\n   */\n  public get disableOnInit() { return this._disableOnInit; }\n  // PERFORMANCE\n  /**\n   * Whether to render visible panels only. This can dramatically increase performance when there're many panels.\n   * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get renderOnlyVisible() { return this._renderOnlyVisible; }\n  // OTHERS\n  /**\n   * Call {@link Flicking#init init()} automatically when creating Flicking's instance\n   * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다\n   * @type {boolean}\n   * @default true\n   * @readonly\n   */\n  public get autoInit() { return this._autoInit; }\n  /**\n   * Attach Flicking's {@link Flicking#resize resize} method to window's resize event.\n   * Flicking will automatically call {@link Flicking#resize resize} window size and orientation change.\n   * @ko Flicking의 {@link Flicking#resize resize} 메소드를 window의 resize 이벤트 핸들러로 등록합니다.\n   * 설정시 window 창 크기 및 orientation 변경에 의해 자동으로 {@link Flicking#resize resize}를 호출합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get autoResize() { return this._autoResize; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @type {boolean}\n   * @default false\n   * @internal\n   * @readonly\n   */\n  public get renderExternal() { return this._renderExternal; }\n\n  // Options Setter\n  // UI / LAYOUT\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n    this._renderer.align = val;\n    this._camera.align = val;\n  }\n\n  public set defaultIndex(val: FlickingOptions[\"defaultIndex\"]) { this._defaultIndex = val; }\n  public set horizontal(val: FlickingOptions[\"horizontal\"]) { this._horizontal = val; }\n  public set circular(val: FlickingOptions[\"circular\"]) { this._circular = val; }\n  public set bound(val: FlickingOptions[\"bound\"]) { this._bound = val; }\n  public set adaptive(val: FlickingOptions[\"adaptive\"]) { this._adaptive = val; }\n  // ANIMATION\n  public set deceleration(val: FlickingOptions[\"deceleration\"]) { this._deceleration = val; }\n  public set easing(val: FlickingOptions[\"easing\"]) { this._easing = val; }\n  public set duration(val: FlickingOptions[\"duration\"]) { this._duration = val; }\n  // INPUT\n  public set inputType(val: FlickingOptions[\"inputType\"]) { this._inputType = val; }\n  public set moveType(val: FlickingOptions[\"moveType\"]) { this._moveType = val; }\n  public set threshold(val: FlickingOptions[\"threshold\"]) { this._threshold = val; }\n  public set interruptable(val: FlickingOptions[\"interruptable\"]) { this._interruptable = val; }\n  public set bounce(val: FlickingOptions[\"bounce\"]) { this._bounce = val; }\n  public set iOSEdgeSwipeThreshold(val: FlickingOptions[\"iOSEdgeSwipeThreshold\"]) { this._iOSEdgeSwipeThreshold = val; }\n  public set preventClickOnDrag(val: FlickingOptions[\"preventClickOnDrag\"]) { this._preventClickOnDrag = val; }\n  public set disableOnInit(val: FlickingOptions[\"disableOnInit\"]) { this._disableOnInit = val; }\n  // PERFORMANCE\n  public set renderOnlyVisible(val: FlickingOptions[\"renderOnlyVisible\"]) { this._renderOnlyVisible = val; }\n  // OTHERS\n  public set autoResize(val: FlickingOptions[\"autoResize\"]) { this._autoResize = val; }\n\n  /**\n   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string\n   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>\n   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|\n   * <ko>\n   *\n   * |code|조건|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|\n   *\n   * </ko>\n   * @example\n   * ```ts\n   * import Flicking from \"@egjs/flicking\";\n   *\n   * // Creating new instance of Flicking with HTMLElement\n   * const flicking = new Flicking(document.querySelector(\".flicking-viewport\"), { circular: true });\n   *\n   * // Creating new instance of Flicking with CSS selector\n   * const flicking2 = new Flicking(\".flicking-viewport\", { circular: true });\n   * ```\n   */\n  public constructor(root: HTMLElement | string, {\n    align = ALIGN.CENTER,\n    defaultIndex = 0,\n    horizontal = true,\n    circular = false,\n    bound = false,\n    adaptive = false,\n    needPanelThreshold = 0,\n    deceleration = 0.0075,\n    duration = 500,\n    easing = x => 1 - Math.pow(1 - x, 3),\n    inputType = [\"mouse\", \"touch\"],\n    moveType = \"snap\",\n    threshold = 40,\n    interruptable = true,\n    bounce = \"20%\",\n    iOSEdgeSwipeThreshold = 30,\n    preventClickOnDrag = true,\n    disableOnInit = false,\n    renderOnlyVisible = false,\n    autoInit = true,\n    autoResize = true,\n    renderExternal = null\n  }: Partial<FlickingOptions> = {}) {\n    super();\n\n    // Internal states\n    this._initialized = false;\n    this._plugins = [];\n\n    // Bind options\n    this._align = align;\n    this._defaultIndex = defaultIndex;\n    this._horizontal = horizontal;\n    this._circular = circular;\n    this._bound = bound;\n    this._adaptive = adaptive;\n    this._needPanelThreshold = needPanelThreshold;\n    this._deceleration = deceleration;\n    this._duration = duration;\n    this._easing = easing;\n    this._inputType = inputType;\n    this._moveType = moveType;\n    this._threshold = threshold;\n    this._interruptable = interruptable;\n    this._bounce = bounce;\n    this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;\n    this._preventClickOnDrag = preventClickOnDrag;\n    this._disableOnInit = disableOnInit;\n    this._renderOnlyVisible = renderOnlyVisible;\n    this._autoResize = autoResize;\n    this._autoInit = autoInit;\n    this._renderExternal = renderExternal;\n\n    // Create core components\n    this._viewport = new Viewport(getElement(root));\n    this._renderer = this._createRenderer();\n    this._camera = this._createCamera();\n    this._control = this._createControl();\n\n    if (this._autoInit) {\n      void this.init();\n    }\n  }\n\n  /**\n   * Initialize Flicking and move to the default index\n   * This is automatically called on Flicking's constructor when `autoInit` is true(default)\n   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다\n   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다\n   * @fires Flicking#ready\n   * @return {this}\n   */\n  public async init(): Promise<void> {\n    if (this._initialized) return;\n\n    const camera = this._camera;\n    const renderer = this._renderer;\n    const control = this._control;\n    const viewport = this._viewport;\n\n    camera.init(this);\n    renderer.init(this);\n    control.init(this);\n\n    await this.resize();\n\n    // Look at initial panel\n    this._moveToInitialPanel();\n\n    if (this._autoResize) {\n      window.addEventListener(\"resize\", this.resize);\n    }\n    if (this._preventClickOnDrag) {\n      viewport.element.addEventListener(\"click\", this._preventClickWhenDragged);\n    }\n    if (this._disableOnInit) {\n      this.disableInput();\n    }\n\n    this._plugins.forEach(plugin => plugin.init(this));\n\n    // Done initializing & emit ready event\n    this._initialized = true;\n    this.trigger(new ComponentEvent(EVENTS.READY));\n\n    return;\n  }\n\n  /**\n   * Destroy Flicking and remove all event handlers\n   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다\n   * @return {void}\n   */\n  public destroy(): void {\n    if (!this._initialized) return;\n\n    this.off();\n    window.removeEventListener(\"resize\", this.resize);\n    this._viewport.element.removeEventListener(\"click\", this._preventClickWhenDragged);\n\n    this._control.destroy();\n    this._camera.destroy();\n    this._renderer.destroy();\n\n    this._plugins.forEach(plugin => plugin.destroy());\n\n    this._initialized = false;\n  }\n\n  /**\n   * Move to the previous panel (current index - 1)\n   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public prev(duration: number = this._duration): Promise<void> {\n    return this.moveTo(this._control.activePanel?.prev()?.index ?? -1, duration, DIRECTION.PREV);\n  }\n\n  /**\n   * Move to the next panel (current index + 1)\n   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public next(duration: number = this._duration) {\n    return this.moveTo(this._control.activePanel?.next()?.index ?? this._renderer.panelCount, duration, DIRECTION.NEXT);\n  }\n\n  /**\n   * Move to the panel with given index\n   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다\n   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public moveTo(index: number, duration: number = this._duration, direction: ValueOf<typeof DIRECTION> = DIRECTION.NONE) {\n    const renderer = this._renderer;\n    const panelCount = renderer.panelCount;\n\n    const panel = renderer.getPanel(index);\n\n    if (!panel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), ERROR.CODE.INDEX_OUT_OF_RANGE));\n    }\n\n    if (this._control.animating) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.ANIMATION_ALREADY_PLAYING, ERROR.CODE.ANIMATION_ALREADY_PLAYING));\n    }\n\n    return this._control.moveToPanel(panel, {\n      duration,\n      direction\n    });\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   * @example\n   * ```ts\n   * const panel = flicking.getPanel(0);\n   * // Which is a shorthand to...\n   * const samePanel = flicking.panels[0];\n   * ```\n   */\n  public getPanel(index: number): Panel | null {\n    return this._renderer.getPanel(index);\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @return {this}\n   */\n  public enableInput(): this {\n    this._control.enable();\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @return {this}\n   */\n  public disableInput(): this {\n    this._control.disable();\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}\n   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다\n   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>\n   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>\n   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>\n   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>\n   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true\n   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>\n   * @return {Partial<Status>} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus({\n    index = true,\n    position = true,\n    includePanelHTML = false,\n    visiblePanelsOnly = false\n  }: Partial<{\n    index: boolean;\n    position: boolean;\n    includePanelHTML: boolean;\n    visiblePanelsOnly: boolean;\n  }> = {}): Status {\n    const camera = this._camera;\n    const panels = visiblePanelsOnly ? this.visiblePanels : this.panels;\n\n    const status: Status = {\n      panels: panels.map(panel => {\n        const panelInfo: Status[\"panels\"][0] = { index: panel.index };\n\n        if (includePanelHTML) {\n          panelInfo.html = panel.element.outerHTML;\n        }\n\n        return panelInfo;\n      })\n    };\n\n    if (index) {\n      status.index = this.index;\n    }\n    if (position) {\n      const nearestAnchor = camera.findNearestAnchor(camera.position);\n\n      if (nearestAnchor) {\n        status.position = {\n          panel: nearestAnchor.panel.index,\n          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)\n        };\n      }\n\n    }\n\n    if (visiblePanelsOnly) {\n      const visiblePanels = this.visiblePanels;\n\n      status.visibleOffset = visiblePanels[0]?.index ?? 0;\n    }\n\n    return status;\n  }\n\n  /**\n   * Restore to the state of the given {@link Status}\n   * @ko 주어진 {@link Status}의 상태로 복원합니다\n   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>\n   * @return {void}\n   */\n  public setStatus(status: Status): void {\n    if (!this._initialized) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_INITIALIZED, ERROR.CODE.NOT_INITIALIZED);\n    }\n\n    const {\n      index,\n      position,\n      visibleOffset,\n      panels\n    } = status;\n\n    const renderer = this._renderer;\n    const control = this._control;\n\n    // Can't add/remove panels on external rendering\n    if (panels[0]?.html && !this._renderExternal) {\n      renderer.batchRemove({ index: 0, deleteCount: this.panels.length });\n      renderer.batchInsert({ index: 0, elements: parseElement(panels.map(panel => panel.html!)) });\n    }\n\n    if (index) {\n      const panelIndex = visibleOffset\n        ? index - visibleOffset\n        : index;\n\n      void this.moveTo(panelIndex, 0).catch(() => void 0);\n    }\n\n    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {\n      const { panel, progressInPanel } = position;\n      const panelIndex = visibleOffset\n        ? panel - visibleOffset\n        : panel;\n      const panelRange = renderer.panels[panelIndex].range;\n      const newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      void control.moveToPosition(newCameraPos, 0).catch(() => void 0);\n    }\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다\n   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public addPlugins(...plugins: Plugin[]) {\n    if (this._initialized) {\n      plugins.forEach(item => item.init(this));\n    }\n\n    this._plugins.push(...plugins);\n\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거합니다.\n   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public removePlugins(...plugins: Plugin[]) {\n    plugins.forEach(item => {\n      const foundIndex = findIndex(this._plugins, val => val === item);\n\n      if (foundIndex >= 0) {\n        item.destroy();\n        this._plugins.splice(foundIndex, 1);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Update viewport/panel sizes\n   * @ko 패널 및 뷰포트의 크기를 갱신합니다\n   * @method\n   * @fires Flicking#beforeResize\n   * @fires Flicking#afterResize\n   * @return {this}\n   */\n  public resize = async (): Promise<void> => {\n    const viewport = this._viewport;\n    const renderer = this._renderer;\n    const camera = this._camera;\n    const control = this._control;\n\n    const activePanel = control.activePanel;\n    const prevWidth = viewport.width;\n    const prevHeight = viewport.height;\n    const prevProgressInPanel = activePanel\n      ? camera.getProgressInPanel(activePanel)\n      : 0;\n\n    this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n      width: prevWidth,\n      height: prevHeight,\n      element: viewport.element\n    }));\n\n    viewport.resize();\n    await renderer.forceRenderAllPanels(); // Render all panel elements, to update sizes\n    renderer.updatePanelSize();\n    await renderer.render();\n    camera.updateAlignPos();\n    camera.updateRange();\n    camera.updateAnchors();\n\n    if (control.animating) {\n      // TODO:\n    } else {\n      await control.updatePosition(prevProgressInPanel);\n      control.updateInput();\n    }\n\n    const newWidth = viewport.width;\n    const newHeight = viewport.height;\n    const sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;\n\n    this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n      width: viewport.width,\n      height: viewport.height,\n      prev: {\n        width: prevWidth,\n        height: prevHeight\n      },\n      sizeChanged,\n      element: viewport.element\n    }));\n  };\n\n  /**\n   * Add new panels after the last panel\n   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#flick\");\n   * // These are possible parameters\n   * flicking.append(document.createElement(\"div\"));\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public append(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(this._renderer.panelCount, element);\n  }\n\n  /**\n   * Add new panels before the first panel\n   * This will increase index of panels after by the number of panels added\n   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다\n   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.prepend(document.createElement(\"div\"));\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.prepend(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public prepend(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(0, element);\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.insert(0, document.createElement(\"div\"));\n   * flicking.insert(2, \"\\<div\\>Panel\\</div\\>\");\n   * flicking.insert(1, [\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.insert(3, \"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public insert(index: number, element: ElementLike | ElementLike[]): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchInsert({ index, elements: parseElement(element) });\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchRemove({ index, deleteCount });\n  }\n\n  private _createControl(): Control {\n    const moveType = this._moveType;\n    const moveTypes = Object.keys(MOVE_TYPE).map(key => MOVE_TYPE[key] as ValueOf<typeof MOVE_TYPE>);\n\n    const moveTypeStr = Array.isArray(moveType)\n      ? moveType[0]\n      : moveType;\n\n    const moveTypeOptions = Array.isArray(moveType)\n      ? moveType[1] ?? {}\n      : {};\n\n    if (!includes(moveTypes, moveTypeStr)) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"moveType\", JSON.stringify(moveType)), ERROR.CODE.WRONG_OPTION);\n    }\n\n    switch (moveTypeStr) {\n      case MOVE_TYPE.SNAP:\n        return new SnapControl();\n      case MOVE_TYPE.FREE_SCROLL:\n        return new FreeControl(moveTypeOptions);\n    }\n  }\n\n  private _createCamera(): Camera {\n    const cameraOption = { align: this._align };\n\n    if (this._circular) {\n      if (this._bound) {\n        // eslint-disable-next-line no-console\n        console.warn(\"\\\"circular\\\" and \\\"bound\\\" option cannot be used together, ignoring bound.\");\n      }\n      return new CircularCamera(cameraOption);\n    } else if (this._bound) {\n      return new BoundCamera(cameraOption);\n    } else {\n      return new LinearCamera(cameraOption);\n    }\n  }\n\n  private _createRenderer(): Renderer {\n    const renderingStrategy = this._renderOnlyVisible\n      ? new VisibleRenderingStrategy()\n      : new RawRenderingStrategy();\n\n    const rendererOptions = {\n      align: this._align,\n      strategy: renderingStrategy\n    };\n\n    const renderExternal = this._renderExternal;\n\n    return renderExternal\n      ? new (renderExternal.renderer as any)({ ...rendererOptions, ...renderExternal.rendererOptions })\n      : new VanillaRenderer(rendererOptions);\n  }\n\n  private _moveToInitialPanel(): void {\n    const renderer = this._renderer;\n    const control = this._control;\n    const initialPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);\n\n    if (!initialPanel) return;\n\n    void control.moveToPanel(initialPanel, {\n      duration: 0\n    });\n  }\n\n  private _preventClickWhenDragged = (e: MouseEvent) => {\n    if (this._control.animating) {\n      e.preventDefault();\n    }\n  };\n}\n\nexport default Flicking;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel, { PanelOptions } from \"./Panel\";\n\nexport interface ExternalPanelOptions<T> extends PanelOptions {\n  externalComponent: T;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nabstract class ExternalPanel<T = any> extends Panel {\n  protected _externalComponent: T;\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {HTMLElement} [options.el] A `HTMLElement` panel's referencing<ko>패널이 참조하는 `HTMLElement`</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: ExternalPanelOptions<T>) {\n    super(options);\n\n    this._externalComponent = options.externalComponent;\n  }\n}\n\nexport default ExternalPanel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Viewport from \"./Viewport\";\nimport FlickingError from \"./FlickingError\";\nimport AnchorPoint from \"./AnchorPoint\";\n\nexport {\n  Viewport,\n  FlickingError,\n  AnchorPoint\n};\n\nexport * from \"./panel\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\nimport * as Core from \"./core\";\nimport * as Camera from \"./camera\";\nimport * as Control from \"./control\";\nimport * as Renderer from \"./renderer\";\nimport * as Constants from \"./const/external\";\nimport { merge } from \"./utils\";\n\nmerge(Flicking, Core);\nmerge(Flicking, Camera);\nmerge(Flicking, Control);\nmerge(Flicking, Renderer);\nmerge(Flicking, Constants);\n\nexport default Flicking;\n"],"names":["__extends","message","code","_super","_this","Object","setPrototypeOf","FlickingError","prototype","name","Error","CODE","WRONG_TYPE","ELEMENT_NOT_FOUND","VAL_MUST_NOT_NULL","NOT_ATTACHED_TO_FLICKING","WRONG_OPTION","INDEX_OUT_OF_RANGE","POSITION_NOT_REACHABLE","TRANSFORM_NOT_SUPPORTED","STOP_CALLED_BY_USER","ANIMATION_INTERRUPTED","ANIMATION_ALREADY_PLAYING","NOT_ALLOWED_IN_FRAMEWORK","NOT_INITIALIZED","NO_ACTIVE","MESSAGE","wrongVal","correctTypes","map","type","join","selector","val","optionName","min","max","position","EVENTS","READY","BEFORE_RESIZE","AFTER_RESIZE","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","WILL_CHANGE","CHANGED","WILL_RESTORE","RESTORED","SELECT","NEED_PANEL","VISIBLE_CHANGE","REACH_EDGE","ALIGN","PREV","CENTER","NEXT","DIRECTION","NONE","MOVE_TYPE","SNAP","FREE_SCROLL","merge","target","_i","sources","forEach","source","keys","key","getElement","el","parent","targetEl","isString","parentEl","document","queryResult","querySelector","ERROR","nodeType","Node","ELEMENT_NODE","checkExistence","value","nameOnErrMsg","clamp","x","Math","getFlickingAttached","nameToThrowOnError","toArray","iterable","slice","call","parseAlign","align","size","alignPoint","parseArithmeticExpression","parseBounce","bounce","parsedBounce","Array","isArray","parsedVal","cssValue","base","cssRegex","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","getDirection","start","end","parseElement","element","elements","tempDiv","createElement","innerHTML","push","children","firstChild","removeChild","getMinusCompensatedIndex","includes","array","array_1","__values","circulatePosition","pos","offset","findIndex","checker","length","getProgress","prev","next","getStyle","window","getComputedStyle","currentStyle","_el","_width","_height","_padding","left","right","top","bottom","_isBorderBoxSizing","_a","width","height","padding","isBorderBoxSizing","style","newWidth","newHeight","resize","elStyle","offsetWidth","offsetHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","boxSizing","EVENT","HOLD","CHANGE","RELEASE","ANIMATION_END","FINISH","POSITION_KEY","STATE_TYPE","ctx","flicking","axesEvent","transitTo","renderer","panelCount","DISABLED","holdStartEvent","ComponentEvent","trigger","isCanceled","HOLDING","controller","control","animatingContext","moveStartEvent","isTrusted","holding","direction","ANIMATING","onChange","State","inputEvent","horizontal","offsetX","offsetY","DRAGGING","delta","flick","setTo","camera","IDLE","_releaseEvent","releaseEvent","srcEvent","clickedElement","touchEvent","touch","changedTouches","elementFromPoint","clientX","clientY","panels","clickedPanel","panels_1","panel","contains","cameraPosition","clickedPanelPosition","index","AXES","prevPosition","lookAt","moveEvent","destPos","duration","moveToPosition","stop","nextStateType","nextState","IdleState","HoldingState","DraggingState","AnimatingState","DisabledState","_state","eventType","externalCtx","currentState","onHold","onRelease","onAnimationEnd","onFinish","_resetInternalValues","_stateMachine","StateMachine","_axes","state","_animatingContext","_panInput","isEnable","get","axis","_flicking","Axes","range","circular","deceleration","interruptable","easing","PanInput","viewport","inputType","iOSEdgeSwipeThreshold","scale","axes","connect","on","e","fire","destroy","enable","disable","controlParams","axm","set","Promise","reject","startPos","animate","resetContext","once","_b","resolve","animationFinishHandler","off","interruptionHandler","newActivePanel","prevActivePanel","_activePanel","updateAdaptiveHeight","prevIndex","prevPanel","_controller","AxesController","animating","init","_progressInPanel","activePanel","clampToReachablePosition","update","nearestAnchor","findNearestAnchor","removed","canReach","circularEnabled","camPos_1","camRangeDiff","rangeDiff","possiblePositions","filter","reduce","nearestPosition","abs","Infinity","_triggerIndexChangeEvent","_animateToPosition","triggeringEvent","event","currentPanel","animateTo","animation","_setActive","then","render","clampedPosition","anchorAtPosition","prevPos","isOverThreshold","threshold","adjacentAnchor","getNextAnchor","getPrevAnchor","targetPanel","targetPos","Control","_c","stopAtEdge","_stopAtEdge","progressInPanel","panelRange","newPosition","findAnchorIncludePosition","_index","_pos","_panel","transforms","supportedStyle","documentElement","transformName","transforms_1","prefixedTransform","_transform","_align","_position","_alignPos","_offset","_range","_visiblePanels","_anchors","NaN","nearestPanel","panelPos","bounceSize","prevRange","nextRange","nextPanel","nextPosition","viewportEl","firstElementChild","_checkTranslateSupport","_refreshVisiblePanels","_checkNeedPanel","_checkReachEnd","_applyTransform","anchor","anchors","anchorsIncludingPosition","includePosition","nearest","prevDist","anchorIdx","dist","visibleRange","includeRange","alignVal","AnchorPoint","adaptive","setSize","unRenderedPanels","rendered","sizeIncludingMargin","_needPanelTriggered","newVisiblePanels","canSee","prevVisiblePanels","added","visiblePanels","needPanelTriggered","cameraSize","cameraRange","needPanelThreshold","cameraPrev","cameraNext","firstPanel","lastPanel","firstPanelPrev","lastPanelNext","newPos","wasBetweenRange","isBetweenRange","actualPosition","getPanel","Camera","_circularOffset","_circularEnabled","lastAnchor","firstAnchor","positionInRange","anchorInRange","loopCount","floor","visibleInCurrentRange","margin","visibleSize","panelSizeSum","canSetCircularMode","every","updateCircularToggleDirection","_updateCircularOffset","toggled","toggle","some","isToggled","sum","toggledPrev","toggledNext","toggleDirection","_calcPanelAreaSum","alignPos","viewportSize","panelAreaSize","canSetBoundMode","reachablePanels","shouldPrependBoundAnchor","shouldAppendBoundAnchor","indexOffset_1","newAnchors","splice","nearestPanelAtMin","_findNearestPanel","panelAtMin","panelAtMax","panelIdx","markForShow","_d","strategy","RawRenderingStrategy","_renderingStrategy","_panels","panelAlign","_getPanelAlign","_collectPanels","items","allPanelsInserted","addedPanels","item","insertingIdx","panelsPushed","panelsInserted","_createPanel","insertedSize","_getPanelSizeSum","increaseIndex","increasePosition","_insertPanelElements","_updateCameraAndControl","moveToPanel","catch","updateOffset","activeIndex","allPanelsRemoved","deleteCount","removingIdx","panelsPulled","panelsRemoved","removedSize","decreaseIndex","decreasePosition","_removePanelElements","resetActive","marginDiff","updateRange","updateAnchors","resetNeedPanelHistory","updateInput","_removed","_resetInternalStates","_size","_margin","_toggled","_toggleDirection","cameraRangeDiff","progress","alignPosition","camPos","disappearPosNext","disappearPosPrev","checkingRange","marginLeft","marginRight","marginTop","marginBottom","_updateAlignPos","includeMargin","moveTo","_moveBy","togglePosition","_togglePosition","prevToggled","camRange","camAlignPosition","camVisibleRange","camVisibleSize","minimumVisible","maximumVisible","shouldBeVisibleAtMin","shouldBeVisibleAtMax","options","_rendered","Panel","cameraEl","wasRenderedPanels","parentElement","updateRenderingPanels","renderingPanels","_getRenderingPanelsByOrder","_resetPanelElementOrder","cameraElement","fragment","createDocumentFragment","appendChild","_removeAllChildsFromCamera","childNodes","node","TEXT_NODE","cameraChilds","ElementPanel","nextSibling","nextSiblingElement","insertBefore","reversedPanels","__spreadArray","reverse","nextPanelEl","nextElementSibling","sort","a","b","Renderer","visibleIndexes","visibles","markForHide","root","defaultIndex","_e","_f","_g","bound","_h","_j","_k","_l","_m","pow","_o","_p","moveType","_q","_r","_s","_t","_u","preventClickOnDrag","_v","disableOnInit","_w","renderOnlyVisible","_x","autoInit","_y","autoResize","_z","renderExternal","_viewport","_renderer","_camera","_control","prevWidth","prevHeight","prevProgressInPanel","getProgressInPanel","forceRenderAllPanels","updatePanelSize","updateAlignPos","updatePosition","sizeChanged","preventDefault","_initialized","_plugins","_defaultIndex","_horizontal","_circular","_bound","_adaptive","_needPanelThreshold","_deceleration","_duration","_easing","_inputType","_moveType","_threshold","_interruptable","_bounce","_iOSEdgeSwipeThreshold","_preventClickOnDrag","_disableOnInit","_renderOnlyVisible","_autoResize","_autoInit","_renderExternal","Viewport","_createRenderer","_createCamera","_createControl","_moveToInitialPanel","addEventListener","_preventClickWhenDragged","disableInput","plugin","removeEventListener","includePanelHTML","visiblePanelsOnly","status","panelInfo","html","outerHTML","visibleOffset","batchRemove","batchInsert","panelIndex","newCameraPos","plugins","foundIndex","insert","moveTypes","moveTypeStr","moveTypeOptions","JSON","stringify","SnapControl","FreeControl","cameraOption","console","warn","CircularCamera","BoundCamera","LinearCamera","renderingStrategy","VisibleRenderingStrategy","rendererOptions","VanillaRenderer","initialPanel","Flicking","Component","_externalComponent","externalComponent","Core","Constants"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICVA;;;;IAIO,IAAMC,KAAK,GAAG;IACnBC,EAAAA,IAAI,EAAE,MADa;IAEnBC,EAAAA,MAAM,EAAE,QAFW;IAGnBC,EAAAA,OAAO,EAAE,SAHU;IAInBC,EAAAA,aAAa,EAAE,cAJI;IAKnBC,EAAAA,MAAM,EAAE;IALW,CAAd;IAQP;;;;;IAIO,IAAMC,YAAY,GAAG,OAArB;;ICPP,IAAYC,UAAZ;;IAAA,WAAYA;IACVA,EAAAA,kCAAA,SAAA;IACAA,EAAAA,qCAAA,YAAA;IACAA,EAAAA,sCAAA,aAAA;IACAA,EAAAA,uCAAA,cAAA;IACAA,EAAAA,sCAAA,aAAA;IACD,CAND,EAAYA,UAAU,KAAVA,UAAU,KAAA,CAAtB;IAQA;;;;;;;IAKA;;;IAAA,gBAAA;IAgBE;;;;;;;;;;;;;;IAUO,gBAAA,GAAP,UAAcC,GAAd;IAMC,GANM;IAQP;;;;;;;;;;;;IAUO,kBAAA,GAAP,UAAgBA,GAAhB;IAMC,GANM;IAQP;;;;;;;;;;;;IAUO,mBAAA,GAAP,UAAiBA,GAAjB;IAMC,GANM;IAQP;;;;;;;;;;;;IAUO,wBAAA,GAAP,UAAsBA,GAAtB;IAMC,GANM;IAQP;;;;;;;;;;;IASO,kBAAA,GAAP,UAAgBA,GAAhB;IAMC,GANM;;IAOT,cAAA;IAAC,GAxGD;;ICXA;;;;;;IAKA;;;IAAwBxL,EAAAA,8BAAA;;IAAxB,oBAAA;IAAA,wEAAA;IACE;;;;;;;;IAMgBI,IAAAA,aAAA,GAAU,KAAV;IAChB;;;;;;;IAMgBA,IAAAA,eAAA,GAAY,KAAZ;;IA6CjB;;;;IA3CQ,gBAAA,GAAP,UAAcoL,GAAd;IACE;IACQ,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;;IAER,QAAIC,QAAQ,CAACG,QAAT,CAAkBC,UAAlB,IAAgC,CAApC,EAAuC;IACrCF,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACA;IACD;;IAED,QAAMC,cAAc,GAAG,IAAIC,gBAAJ,CAAmB1J,MAAM,CAACI,UAA1B,EAAsC;IAC3DgJ,MAAAA,SAAS;IADkD,KAAtC,CAAvB;IAIAD,IAAAA,QAAQ,CAACQ,OAAT,CAAiBF,cAAjB;;IAEA,QAAIA,cAAc,CAACG,UAAf,EAAJ,EAAiC;IAC/BP,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACD,KAFD,MAEO;IACLH,MAAAA,SAAS,CAACJ,UAAU,CAACY,OAAZ,CAAT;IACD;IACF,GApBM;;;IAuBA,kBAAA,GAAP,UAAgBX,GAAhB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;IACR,QAAMY,UAAU,GAAGX,QAAQ,CAACY,OAAT,CAAiBD,UAApC;IACA,QAAME,gBAAgB,GAAGF,UAAU,CAACE,gBAApC;IAEA,QAAMC,cAAc,GAAG,IAAIP,gBAAJ,CAAmB1J,MAAM,CAACM,UAA1B,EAAsC;IAC3D4J,MAAAA,SAAS,EAAEd,SAAS,CAACc,SADsC;IAE3DC,MAAAA,OAAO,EAAE,KAAKA,OAF6C;IAG3DC,MAAAA,SAAS,EAAEnF,cAAY,CAAC+E,gBAAgB,CAAC9E,KAAlB,EAAyB8E,gBAAgB,CAAC7E,GAA1C,CAHoC;IAI3DiE,MAAAA,SAAS;IAJkD,KAAtC,CAAvB;IAMAD,IAAAA,QAAQ,CAACQ,OAAT,CAAiBM,cAAjB;;IAEA,QAAIA,cAAc,CAACL,UAAf,EAAJ,EAAiC;IAC/BP,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACD,KAFD,MAEO;IACL;IACAH,MAAAA,SAAS,CAACJ,UAAU,CAACoB,SAAZ,CAAT,CAAgCC,QAAhC,CAAyCpB,GAAzC;IACD;IACF,GAnBM;;IAoBT,kBAAA;IA3DA,EAAwBqB,MAAxB;;ICHA;;;;;;IAKA;;;IAA2B7M,EAAAA,iCAAA;;IAA3B,uBAAA;IAAA,wEAAA;IACE;;;;;;;;IAMgBI,IAAAA,aAAA,GAAU,IAAV;IAChB;;;;;;;IAMgBA,IAAAA,eAAA,GAAY,KAAZ;IAERA,IAAAA,mBAAA,GAAkC,IAAlC;;IAoGT;;;;IAlGQ,kBAAA,GAAP,UAAgBoL,GAAhB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;IAER,QAAMsB,UAAU,GAAGpB,SAAS,CAACoB,UAA7B;IAEA,QAAMnE,MAAM,GAAG8C,QAAQ,CAACsB,UAAT,GACXD,UAAU,CAACE,OADA,GAEXF,UAAU,CAACG,OAFf;IAIA,QAAMV,cAAc,GAAG,IAAIP,gBAAJ,CAAmB1J,MAAM,CAACM,UAA1B,EAAsC;IAC3D4J,MAAAA,SAAS,EAAEd,SAAS,CAACc,SADsC;IAE3DC,MAAAA,OAAO,EAAE,KAAKA,OAF6C;IAG3DC,MAAAA,SAAS,EAAEnF,cAAY,CAAC,CAAD,EAAI,CAACoB,MAAL,CAHoC;IAI3D+C,MAAAA,SAAS;IAJkD,KAAtC,CAAvB;IAMAD,IAAAA,QAAQ,CAACQ,OAAT,CAAiBM,cAAjB;;IAEA,QAAIA,cAAc,CAACL,UAAf,EAAJ,EAAiC;IAC/BP,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACD,KAFD,MAEO;IACL;IACAH,MAAAA,SAAS,CAACJ,UAAU,CAAC2B,QAAZ,CAAT,CAA+BN,QAA/B,CAAwCpB,GAAxC;IACD;IACF,GAvBM;;IAyBA,mBAAA,GAAP,UAAiBA,GAAjB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;IAERC,IAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACK,QAA1B,EAAoC;IAAE+I,MAAAA,SAAS;IAAX,KAApC,CAAjB;;IAEA,QAAIA,SAAS,CAACyB,KAAV,CAAgBC,KAAhB,KAA0B,CAA9B,EAAiC;IAC/B;IACA;IACA;IAEA;IACA;IACA1B,MAAAA,SAAS,CAAC2B,KAAV,CAAgB;IAAED,QAAAA,KAAK,EAAE3B,QAAQ,CAAC6B,MAAT,CAAgBjL;IAAzB,OAAhB,EAAqD,CAArD;IACAsJ,MAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;IACA;IACD;IAGD;;;IACA,SAAKC,aAAL,GAAqB9B,SAArB;IACD,GApBM;;IAsBA,kBAAA,GAAP,UAAgBF,GAAhB;;;IACU,QAAAC,QAAQ,GAAgBD,GAAG,SAA3B;IAAA,QAAUG,SAAS,GAAKH,GAAG,UAA3B;IAGR;;IACAG,IAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;;IAEA,QAAI,CAAC,KAAKC,aAAV,EAAyB;IACvB;IACD;IAGD;;;IACA,QAAMC,YAAY,GAAG,KAAKD,aAA1B;;IAGA;;IACA,QAAME,QAAQ,GAAGD,YAAY,CAACX,UAAb,CAAwBY,QAAzC;IAEA,QAAIC,cAAJ;;IACA,QAAID,QAAQ,CAAC5L,IAAT,KAAkB,UAAtB,EAAkC;IAChC,UAAM8L,UAAU,GAAGF,QAAnB;IACA,UAAMG,KAAK,GAAGD,UAAU,CAACE,cAAX,CAA0B,CAA1B,CAAd;IACAH,MAAAA,cAAc,GAAG7I,QAAQ,CAACiJ,gBAAT,CAA0BF,KAAK,CAACG,OAAhC,EAAyCH,KAAK,CAACI,OAA/C,CAAjB;IACD,KAJD,MAIO;IACLN,MAAAA,cAAc,GAAGD,QAAQ,CAACzJ,MAA1B;IACD;IACD;;;IAEA,QAAMiK,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAAjC;IACA,QAAIC,YAAY,GAAiB,IAAjC;;;IAEA,WAAoB,IAAAC,WAAA5F,WAAA0F,OAAA,8BAApB,kBAAA,8BAAA,EAA4B;IAAvB,YAAMG,KAAK,mBAAX;;IACH,YAAIA,KAAK,CAACC,QAAN,CAAeX,cAAf,CAAJ,EAAoC;IAClCQ,UAAAA,YAAY,GAAGE,KAAf;IACA;IACD;IACF;;;;;;;;;;;;;IAED,QAAIF,YAAJ,EAAkB;IAChB,UAAMI,cAAc,GAAG9C,QAAQ,CAAC6B,MAAT,CAAgBjL,QAAvC;IACA,UAAMmM,oBAAoB,GAAGL,YAAY,CAAC9L,QAA1C;IAEAoJ,MAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACa,MAA1B,EAAkC;IACjDsL,QAAAA,KAAK,EAAEN,YAAY,CAACM,KAD6B;IAEjDJ,QAAAA,KAAK,EAAEF,YAF0C;IAGjD;IACAzB,QAAAA,SAAS,EAAEnF,cAAY,CAACgH,cAAD,EAAiBC,oBAAjB;IAJ0B,OAAlC,CAAjB;IAMD;IACF,GAlDM;;IAmDT,qBAAA;IApHA,EAA2B3B,MAA3B;;ICNA;;;;;;IAKA;;;IAA4B7M,EAAAA,kCAAA;;IAA5B,wBAAA;IAAA,wEAAA;IACE;;;;;;;;IAMgBI,IAAAA,aAAA,GAAU,IAAV;IAChB;;;;;;;IAMgBA,IAAAA,eAAA,GAAY,IAAZ;;IAoDjB;;;;IAlDQ,kBAAA,GAAP,UAAgBoL,GAAhB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;;IAER,QAAI,CAACE,SAAS,CAACyB,KAAV,CAAgBuB,YAAhB,CAAL,EAAyC;IACvC;IACD;;IAED,QAAMpB,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IACA,QAAMqB,YAAY,GAAGrB,MAAM,CAACjL,QAA5B;IAEA,SAAKiL,MAAM,CAACsB,MAAP,CAAclD,SAAS,CAAChD,GAAV,CAAcgG,YAAd,CAAd,CAAL;IAEA,QAAMG,SAAS,GAAG,IAAI7C,gBAAJ,CAAmB1J,MAAM,CAACO,IAA1B,EAAgC;IAChD2J,MAAAA,SAAS,EAAEd,SAAS,CAACc,SAD2B;IAEhDC,MAAAA,OAAO,EAAE,KAAKA,OAFkC;IAGhDC,MAAAA,SAAS,EAAEnF,cAAY,CAAC,CAAD,EAAImE,SAAS,CAACyB,KAAV,CAAgBuB,YAAhB,CAAJ,CAHyB;IAIhDhD,MAAAA,SAAS;IAJuC,KAAhC,CAAlB;IAMAD,IAAAA,QAAQ,CAACQ,OAAT,CAAiB4C,SAAjB;;IAEA,QAAIA,SAAS,CAAC3C,UAAV,EAAJ,EAA4B;IAC1B;IACA,WAAKoB,MAAM,CAACsB,MAAP,CAAcD,YAAd,CAAL;IACAhD,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACD;IACF,GAzBM;;IA2BA,mBAAA,GAAP,UAAiBN,GAAjB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;IAGR;;IACAC,IAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACK,QAA1B,EAAoC;IACnD+I,MAAAA,SAAS;IAD0C,KAApC,CAAjB;;IAIA,QAAID,QAAQ,CAACG,QAAT,CAAkBC,UAAlB,IAAgC,CAApC,EAAuC;IACrC;IACAF,MAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;IACA;IACD;;IAED5B,IAAAA,SAAS,CAACJ,UAAU,CAACoB,SAAZ,CAAT;IAEA,QAAMN,OAAO,GAAGZ,QAAQ,CAACY,OAAzB;IACA,QAAMhK,QAAQ,GAAGqJ,SAAS,CAACoD,OAAV,CAAkBJ,YAAlB,CAAjB;IACA,QAAMK,QAAQ,GAAGrJ,IAAI,CAACtD,GAAL,CAASsJ,SAAS,CAACqD,QAAnB,EAA6BtD,QAAQ,CAACsD,QAAtC,CAAjB;IAEA,SAAK1C,OAAO,CAAC2C,cAAR,CAAuB3M,QAAvB,EAAiC0M,QAAjC,EAA2CrD,SAA3C,CAAL;IACD,GAtBM;;IAuBT,sBAAA;IAlEA,EAA4BmB,MAA5B;;ICNA;;;;;;IAKA;;;IAA6B7M,EAAAA,mCAAA;;IAA7B,yBAAA;IAAA,wEAAA;IACE;;;;;;;;IAMgBI,IAAAA,aAAA,GAAU,KAAV;IAChB;;;;;;;IAMgBA,IAAAA,eAAA,GAAY,IAAZ;;IAyDjB;;;;IAvDQ,gBAAA,GAAP,UAAcoL,GAAd;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;IAER,QAAMO,cAAc,GAAG,IAAIC,gBAAJ,CAAmB1J,MAAM,CAACI,UAA1B,EAAsC;IAAEgJ,MAAAA,SAAS;IAAX,KAAtC,CAAvB;IACAD,IAAAA,QAAQ,CAACQ,OAAT,CAAiBF,cAAjB;;IAEA,QAAIA,cAAc,CAACG,UAAf,EAAJ,EAAiC;IAC/BP,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACD,KAFD,MAEO;IACLH,MAAAA,SAAS,CAACJ,UAAU,CAAC2B,QAAZ,CAAT;IACD;IACF,GAXM;;IAaA,kBAAA,GAAP,UAAgB1B,GAAhB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;;IAER,QAAI,CAACE,SAAS,CAACyB,KAAV,CAAgBC,KAArB,EAA4B;IAC1B;IACD;;IAED,QAAME,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IACA,QAAMqB,YAAY,GAAGrB,MAAM,CAACjL,QAA5B;IAEA,SAAKiL,MAAM,CAACsB,MAAP,CAAclD,SAAS,CAAChD,GAAV,CAAc0E,KAA5B,CAAL;IAEA,QAAMyB,SAAS,GAAG,IAAI7C,gBAAJ,CAAmB1J,MAAM,CAACO,IAA1B,EAAgC;IAChD2J,MAAAA,SAAS,EAAEd,SAAS,CAACc,SAD2B;IAEhDC,MAAAA,OAAO,EAAE,KAAKA,OAFkC;IAGhDC,MAAAA,SAAS,EAAEnF,cAAY,CAAC,CAAD,EAAImE,SAAS,CAACyB,KAAV,CAAgBC,KAApB,CAHyB;IAIhD1B,MAAAA,SAAS;IAJuC,KAAhC,CAAlB;IAOAD,IAAAA,QAAQ,CAACQ,OAAT,CAAiB4C,SAAjB;;IAEA,QAAIA,SAAS,CAAC3C,UAAV,EAAJ,EAA4B;IAC1B;IACA,WAAKT,QAAQ,CAAC6B,MAAT,CAAgBsB,MAAhB,CAAuBD,YAAvB,CAAL;IACAhD,MAAAA,SAAS,CAACJ,UAAU,CAACO,QAAZ,CAAT;IACD;IACF,GA1BM;;IA4BA,kBAAA,GAAP,UAAgBN,GAAhB;IACU,QAAAC,QAAQ,GAA2BD,GAAG,SAAtC;IAAA,QAAUE,SAAS,GAAgBF,GAAG,UAAtC;IAAA,QAAqBG,SAAS,GAAKH,GAAG,UAAtC;IAERG,IAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;IAEA,QAAMnB,UAAU,GAAGX,QAAQ,CAACY,OAAT,CAAiBD,UAApC;IACA,QAAME,gBAAgB,GAAGF,UAAU,CAACE,gBAApC;IAEAb,IAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACQ,QAA1B,EAAoC;IACnD0J,MAAAA,SAAS,EAAEd,SAAS,CAACc,SAD8B;IAEnDE,MAAAA,SAAS,EAAEnF,cAAY,CAAC+E,gBAAgB,CAAC9E,KAAlB,EAAyB8E,gBAAgB,CAAC7E,GAA1C,CAF4B;IAGnDiE,MAAAA,SAAS;IAH0C,KAApC,CAAjB;IAKD,GAbM;;IAcT,uBAAA;IAvEA,EAA6BmB,MAA7B;;ICVA;;;;;;IAKA;;;IAA4B7M,EAAAA,kCAAA;;IAA5B,wBAAA;IAAA,wEAAA;IACE;;;;;;;;IAMgBI,IAAAA,aAAA,GAAU,KAAV;IAChB;;;;;;;IAMgBA,IAAAA,eAAA,GAAY,IAAZ;;IAyBjB;;;;IAvBQ,wBAAA,GAAP,UAAsBoL,GAAtB;IACU,QAAAG,SAAS,GAAKH,GAAG,UAAjB;IAERG,IAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;IACD,GAJM;;IAMA,kBAAA,GAAP,UAAgB/B,GAAhB;IACU,QAAAE,SAAS,GAAgBF,GAAG,UAA5B;IAAA,QAAWG,SAAS,GAAKH,GAAG,UAA5B;;IAGRE,IAAAA,SAAS,CAACuD,IAAV;IAEAtD,IAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;IACD,GAPM;;IASA,mBAAA,GAAP,UAAiB/B,GAAjB;IACU,QAAAE,SAAS,GAAgBF,GAAG,UAA5B;IAAA,QAAWG,SAAS,GAAKH,GAAG,UAA5B;;IAGR,QAAIE,SAAS,CAACyB,KAAV,CAAgBC,KAAhB,KAA0B,CAA9B,EAAiC;IAC/BzB,MAAAA,SAAS,CAACJ,UAAU,CAACgC,IAAZ,CAAT;IACD;IACF,GAPM;;IAQT,sBAAA;IAvCA,EAA4BV,MAA5B;;ICKA;;;;IAGA;;;IAKE,uBAAA;IAAA,oBAAA;;IA8BO,kBAAA,GAAY,UAACqC,aAAD;IACjB,UAAIC,SAAJ;;IAEA,cAAQD,aAAR;IACE,aAAK3D,UAAU,CAACgC,IAAhB;IACE4B,UAAAA,SAAS,GAAG,IAAIC,SAAJ,EAAZ;IACA;;IACF,aAAK7D,UAAU,CAACY,OAAhB;IACEgD,UAAAA,SAAS,GAAG,IAAIE,YAAJ,EAAZ;IACA;;IACF,aAAK9D,UAAU,CAAC2B,QAAhB;IACEiC,UAAAA,SAAS,GAAG,IAAIG,aAAJ,EAAZ;IACA;;IACF,aAAK/D,UAAU,CAACoB,SAAhB;IACEwC,UAAAA,SAAS,GAAG,IAAII,cAAJ,EAAZ;IACA;;IACF,aAAKhE,UAAU,CAACO,QAAhB;IACEqD,UAAAA,SAAS,GAAG,IAAIK,aAAJ,EAAZ;IACA;IAfJ;;IAkBApP,MAAAA,KAAI,CAACqP,MAAL,GAAcN,SAAd;IAEA,aAAO/O,KAAI,CAACqP,MAAZ;IACD,KAxBM;;IA7BL,SAAKA,MAAL,GAAc,IAAIL,SAAJ,EAAd;IACD;;;IAJD/O,EAAAA,qBAAA,iBAAA;aAAA;IAA4B,aAAO,KAAKoP,MAAZ;IAAqB;;;OAAjD;;IAMO,cAAA,GAAP,UAAYC,SAAZ,EAAyCC,WAAzC;IAIE,QAAMC,YAAY,GAAG,KAAKH,MAA1B;;IACA,QAAMjE,GAAG,6BAAQmE;IAAahE,MAAAA,SAAS,EAAE,KAAKA;UAA9C;;IAEA,YAAQ+D,SAAR;IACE,WAAKhB,KAAA,CAAWzD,IAAhB;IACE2E,QAAAA,YAAY,CAACC,MAAb,CAAoBrE,GAApB;IACA;;IACF,WAAKkD,KAAA,CAAWxD,MAAhB;IACE0E,QAAAA,YAAY,CAAChD,QAAb,CAAsBpB,GAAtB;IACA;;IACF,WAAKkD,KAAA,CAAWvD,OAAhB;IACEyE,QAAAA,YAAY,CAACE,SAAb,CAAuBtE,GAAvB;IACA;;IACF,WAAKkD,KAAA,CAAWtD,aAAhB;IACEwE,QAAAA,YAAY,CAACG,cAAb,CAA4BvE,GAA5B;IACA;;IACF,WAAKkD,KAAA,CAAWrD,MAAhB;IACEuE,QAAAA,YAAY,CAACI,QAAb,CAAsBxE,GAAtB;IACA;IAfJ;IAiBD,GAxBM;;IAmDT,qBAAA;IAAC,GA5DD;;ICnBA;;;;IAcA;;;;;;IAKA;;;IAsDE;IACA,yBAAA;IACE,SAAKyE,oBAAL;;IACA,SAAKC,aAAL,GAAqB,IAAIC,YAAJ,EAArB;IACD;;;IA3CD9P,EAAAA,qBAAA,gBAAA;IAPA;;;;;;;aAOA;IAAoB,aAAO,KAAK+P,KAAZ;IAAoB;;;OAAxC;IAMA/P,EAAAA,qBAAA,iBAAA;IALA;;;;;aAKA;IAAqB,aAAO,KAAK6P,aAAL,CAAmBG,KAA1B;IAAkC;;;OAAvD;IAUAhQ,EAAAA,qBAAA,4BAAA;IATA;;;;;;;;;aASA;IAAgC,aAAO,KAAKiQ,iBAAZ;IAAgC;;;OAAhE;IAOAjQ,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;;;IAAuB,aAAO,MAAA,MAAA,KAAKkQ,SAAL,UAAA,iBAAA,SAAA,MAAgBC,UAAhB,UAAA,iBAAA,KAAA,GAA8B,KAArC;IAA6C;;;OAApE;IAOAnQ,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;;;IAAwB,aAAO,MAAA,MAAA,KAAK+P,KAAL,UAAA,iBAAA,SAAA,MAAYK,IAAI,CAAC/B,YAAD,GAAqBA,aAArC,UAAA,iBAAA,KAAA,GAA2D,CAAlE;IAAsE;;;OAA9F;IAOArO,EAAAA,qBAAA,kBAAA;IANA;;;;;;aAMA;;;IAAsB,aAAO,MAAA,KAAK+P,KAAL,UAAA,iBAAA,SAAA,MAAYM,KAAKhC,cAAmBnI,MAA3C;IAA4E;;;OAAlG;IAQA;;;;;;;;IAOO,cAAA,GAAP,UAAYkF,QAAZ;;;IAAA,oBAAA;;IACE,SAAKkF,SAAL,GAAiBlF,QAAjB;IAEA,SAAK2E,KAAL,GAAa,IAAIQ,IAAJ,WACX7G,GAAC2E,aAAD,GAAqB;IACnBmC,MAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,CADY;IAEnBC,MAAAA,QAAQ,EAAE,KAFS;IAGnBvK,MAAAA,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ;IAHW,SADV,GAMV;IACDwK,MAAAA,YAAY,EAAEtF,QAAQ,CAACsF,YADtB;IAEDC,MAAAA,aAAa,EAAEvF,QAAQ,CAACuF,aAFvB;IAGDC,MAAAA,MAAM,EAAExF,QAAQ,CAACwF;IAHhB,KANU,CAAb;IAWA,SAAKV,SAAL,GAAiB,IAAIW,QAAJ,CAAazF,QAAQ,CAAC0F,QAAT,CAAkBxJ,OAA/B,EAAwC;IACvDyJ,MAAAA,SAAS,EAAE3F,QAAQ,CAAC2F,SADmC;IAEvDC,MAAAA,qBAAqB,EAAE5F,QAAQ,CAAC4F,qBAFuB;IAGvDC,MAAAA,KAAK,EAAE7F,QAAQ,CAACsB,UAAT,GAAsB,CAAC,CAAC,CAAF,EAAK,CAAL,CAAtB,GAAgC,CAAC,CAAD,EAAI,CAAC,CAAL;IAHgB,KAAxC,CAAjB;IAMA,QAAMwE,IAAI,GAAG,KAAKnB,KAAlB;IAEAmB,IAAAA,IAAI,CAACC,OAAL,CAAa/F,QAAQ,CAACsB,UAAT,GAAsB,CAAC2B,YAAD,EAAoB,EAApB,CAAtB,GAAgD,CAAC,EAAD,EAAKA,YAAL,CAA7D,EAAsF,KAAK6B,SAA3F;;gCAEWhM;IACT,UAAMmL,SAAS,GAAGhB,KAAA,CAAWnK,GAAX,CAAlB;IAEAgN,MAAAA,IAAI,CAACE,EAAL,CAAQ/B,SAAR,EAAmB,UAACgC,CAAD;IACjBtR,QAAAA,KAAI,CAAC8P,aAAL,CAAmByB,IAAnB,CAAwBjC,SAAxB,EAAmC;IACjCjE,UAAAA,QAAQ,UADyB;IAEjCC,UAAAA,SAAS,EAAEgG;IAFsB,SAAnC;IAID,OALD;;;IAHF,SAAK,IAAMnN,GAAX,IAAkBmK,KAAlB;kBAAWnK;IASV;;IAED,WAAO,IAAP;IACD,GApCM;IAsCP;;;;;;;IAKO,iBAAA,GAAP;;;IACE,UAAA,KAAK6L,KAAL,UAAA,iBAAA,SAAA,MAAYwB,SAAZ;IACA,UAAA,KAAKrB,SAAL,UAAA,iBAAA,SAAA,MAAgBqB,SAAhB;;IAEA,SAAK3B,oBAAL;IACD,GALM;IAOP;;;;;;;;IAMO,gBAAA,GAAP;;;IACE,UAAA,KAAKM,SAAL,UAAA,iBAAA,SAAA,MAAgBsB,QAAhB;IAEA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;IAMO,iBAAA,GAAP;;;IACE,UAAA,KAAKtB,SAAL,UAAA,iBAAA,SAAA,MAAgBuB,SAAhB;IAEA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;;;;IASO,gBAAA,GAAP;;;IACE,QAAMrG,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAApC;IACA,QAAMrD,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IACA,QAAMiE,IAAI,GAAG,KAAKnB,KAAlB;IACA,QAAM2B,aAAa,GAAGzE,MAAM,CAACyE,aAA7B;IACA,QAAMrB,IAAI,GAAGa,IAAI,CAACb,IAAL,CAAUhC,YAAV,CAAb;IAEAgC,IAAAA,IAAI,CAACI,QAAL,GAAgB,CAACiB,aAAa,CAACjB,QAAf,EAAyBiB,aAAa,CAACjB,QAAvC,CAAhB;IACAJ,IAAAA,IAAI,CAACG,KAAL,GAAa,CAACkB,aAAa,CAAClB,KAAd,CAAoB1O,GAArB,EAA0B4P,aAAa,CAAClB,KAAd,CAAoBzO,GAA9C,CAAb;IACAsO,IAAAA,IAAI,CAACnK,MAAL,GAAcD,WAAW,CAACmF,QAAQ,CAAClF,MAAV,EAAkB+G,MAAM,CAACnH,IAAzB,CAAzB;IAEAoL,IAAAA,IAAI,CAACS,GAAL,CAASC,GAAT,WAAelI,GAAC2E,aAAD,GAAqBqD,aAAa,CAAC1P,YAAlD;IAEA,WAAO,IAAP;IACD,GAdM;IAgBP;;;;;;;;;;;;;;;;;;;;;;;IAqBO,mBAAA,GAAP,UAAiBA,QAAjB,EAAmC0M,QAAnC,EAAqDrD,SAArD;;;IAAA,oBAAA;;IACE,QAAM6F,IAAI,GAAG,KAAKnB,KAAlB;;IAEA,QAAI,CAACmB,IAAL,EAAW;IACT,aAAOW,OAAO,CAACC,MAAR,CAAe,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAclE,wBAAd,CAAuC,SAAvC,CAAlB,EAAqEkE,IAAA,CAAWlE,wBAAhF,CAAf,CAAP;IACD;;IAED,QAAMqR,QAAQ,GAAGb,IAAI,CAACd,GAAL,CAAS,CAAC/B,YAAD,CAAT,EAA8BA,YAA9B,CAAjB;;IAEA,QAAI0D,QAAQ,KAAK/P,QAAjB,EAA2B;IACzB,UAAMoJ,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAApC;IAEA,aAAOlF,QAAQ,CAAC6B,MAAT,CAAgBsB,MAAhB,CAAuBvM,QAAvB,CAAP;IACD;;IAED,SAAKiO,iBAAL,GAAyB;IACvB9I,MAAAA,KAAK,EAAE4K,QADgB;IAEvB3K,MAAAA,GAAG,EAAEpF,QAFkB;IAGvBsG,MAAAA,MAAM,EAAE;IAHe,KAAzB;;IAMA,QAAM0J,OAAO,GAAG;;;IACd,UAAMC,YAAY,GAAG;IACnBlS,QAAAA,KAAI,CAACkQ,iBAAL,GAAyB;IAAE9I,UAAAA,KAAK,EAAE,CAAT;IAAYC,UAAAA,GAAG,EAAE,CAAjB;IAAoBkB,UAAAA,MAAM,EAAE;IAA5B,SAAzB;IACD,OAFD;;IAIA4I,MAAAA,IAAI,CAACgB,IAAL,CAAU7D,KAAA,CAAWrD,MAArB,EAA6BiH,YAA7B;;IAEA,UAAI5G,SAAJ,EAAe;IACbA,QAAAA,SAAS,CAAC2B,KAAV,WAAkBtD,GAAC2E,aAAD,GAAqBrM,YAAvC,GAAmD0M,QAAnD;IACD,OAFD,MAEO;IACLwC,QAAAA,IAAI,CAAClE,KAAL,WAAamF,GAAC9D,aAAD,GAAqBrM,YAAlC,GAA8C0M,QAA9C;IACD;IACF,KAZD;;IAcA,QAAIA,QAAQ,KAAK,CAAjB,EAAoB;IAClBsD,MAAAA,OAAO;IACPd,MAAAA,IAAI,CAACS,GAAL,CAASC,GAAT,WAAelI,GAAC2E,aAAD,GAAqBrM,YAApC;IAEA,aAAO6P,OAAO,CAACO,OAAR,EAAP;IACD,KALD,MAKO;IACL,aAAO,IAAIP,OAAJ,CAAY,UAACO,OAAD,EAAUN,MAAV;IACjB,YAAMO,sBAAsB,GAAG;IAC7BnB,UAAAA,IAAI,CAACoB,GAAL,CAASjE,KAAA,CAAWzD,IAApB,EAA0B2H,mBAA1B;IACAH,UAAAA,OAAO;IACR,SAHD;;IAKA,YAAMG,mBAAmB,GAAG;IAC1BrB,UAAAA,IAAI,CAACoB,GAAL,CAASjE,KAAA,CAAWrD,MAApB,EAA4BqH,sBAA5B;IACAP,UAAAA,MAAM,CAAC,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAc5D,qBAAhC,EAAuD4D,IAAA,CAAW5D,qBAAlE,CAAD,CAAN;IACD,SAHD;;IAKAkQ,QAAAA,IAAI,CAACgB,IAAL,CAAU7D,KAAA,CAAWrD,MAArB,EAA6BqH,sBAA7B;;IAEA,YAAI,CAAChH,SAAL,EAAgB;IACd6F,UAAAA,IAAI,CAACgB,IAAL,CAAU7D,KAAA,CAAWzD,IAArB,EAA2B2H,mBAA3B;IACD;;IAEDP,QAAAA,OAAO;IACR,OAlBM,CAAP;IAmBD;IACF,GA7DM;;IA+DG,8BAAA,GAAV;IACE,SAAK1B,SAAL,GAAiB,IAAjB;IACA,SAAKP,KAAL,GAAa,IAAb;IACA,SAAKG,SAAL,GAAiB,IAAjB;IACA,SAAKD,iBAAL,GAAyB;IAAE9I,MAAAA,KAAK,EAAE,CAAT;IAAYC,MAAAA,GAAG,EAAE,CAAjB;IAAoBkB,MAAAA,MAAM,EAAE;IAA5B,KAAzB;IACD,GALS;;IAMZ,uBAAA;IAAC,GAhQD;;ICHA;;;;;IAIA;;;IA2CE;IACA,kBAAA;IAAA,oBAAA;;IAqRU,mBAAA,GAAa,UAACkK,cAAD,EAAwBC,eAAxB,EAAuDtG,SAAvD;;;IACrB,UAAMf,QAAQ,GAAG9F,mBAAmB,CAACvF,KAAI,CAACuQ,SAAN,EAAiB,SAAjB,CAApC;IAEAvQ,MAAAA,KAAI,CAAC2S,YAAL,GAAoBF,cAApB;IAEApH,MAAAA,QAAQ,CAAC6B,MAAT,CAAgB0F,oBAAhB;;IAEA,UAAIH,cAAc,KAAKC,eAAvB,EAAwC;IACtCrH,QAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACU,OAA1B,EAAmC;IAClDyL,UAAAA,KAAK,EAAEoE,cAAc,CAACpE,KAD4B;IAElDJ,UAAAA,KAAK,EAAEwE,cAF2C;IAGlDI,UAAAA,SAAS,EAAE,MAAAH,eAAe,SAAf,IAAAA,eAAe,WAAf,SAAA,GAAAA,eAAe,CAAErE,KAAjB,UAAA,iBAAA,KAAA,GAA0B,CAAC,CAHY;IAIlDyE,UAAAA,SAAS,EAAEJ,eAJuC;IAKlDtG,UAAAA,SAAS,WALyC;IAMlDE,UAAAA,SAAS,EAAEoG,eAAe,GAAGvL,cAAY,CAACuL,eAAe,CAACzQ,QAAjB,EAA2BwQ,cAAc,CAACxQ,QAA1C,CAAf,GAAqEsB,SAAS,CAACC;IANvD,SAAnC,CAAjB;IAQD,OATD,MASO;IACL6H,QAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACY,QAA1B,EAAoC;IACnDsJ,UAAAA,SAAS;IAD0C,SAApC,CAAjB;IAGD;IACF,KArBS;;IApRR,SAAKmE,SAAL,GAAiB,IAAjB;IACA,SAAKwC,WAAL,GAAmB,IAAIC,cAAJ,EAAnB;IACA,SAAKL,YAAL,GAAoB,IAApB;IACD;;;IApCD1S,EAAAA,qBAAA,sBAAA;IANA;;;;;;aAMA;IAA0B,aAAO,KAAK8S,WAAZ;IAA0B;;;OAApD;IAQA9S,EAAAA,qBAAA,uBAAA;IAPA;;;;;;;aAOA;;;IAA2B,aAAO,MAAA,MAAA,KAAK0S,YAAL,UAAA,iBAAA,SAAA,MAAmBtE,KAAnB,UAAA,iBAAA,KAAA,GAA4B,CAAC,CAApC;IAAwC;;;OAAnE;IAOApO,EAAAA,qBAAA,uBAAA;IANA;;;;;;aAMA;IAA2B,aAAO,KAAK0S,YAAZ;IAA2B;;;OAAtD;IAOA1S,EAAAA,qBAAA,qBAAA;IANA;;;;;;aAMA;IAAyB,aAAO,KAAK8S,WAAL,CAAiB9C,KAAjB,CAAuBgD,SAA9B;IAA0C;;;OAAnE;IAOAhT,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;IAAuB,aAAO,KAAK8S,WAAL,CAAiB9C,KAAjB,CAAuB5D,OAA9B;IAAwC;;;OAA/D;IAoDA;;;;;;;;IAOO,cAAA,GAAP,UAAYhB,QAAZ;IACE,SAAKkF,SAAL,GAAiBlF,QAAjB;;IACA,SAAK0H,WAAL,CAAiBG,IAAjB,CAAsB7H,QAAtB;;IAEA,WAAO,IAAP;IACD,GALM;IAOP;;;;;;;IAKO,iBAAA,GAAP;IACE,SAAK0H,WAAL,CAAiBvB,OAAjB;;IAEA,SAAKjB,SAAL,GAAiB,IAAjB;IACA,SAAKoC,YAAL,GAAoB,IAApB;IACD,GALM;IAOP;;;;;;;;IAMO,gBAAA,GAAP;IACE,SAAKI,WAAL,CAAiBtB,MAAjB;;IAEA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;IAMO,iBAAA,GAAP;IACE,SAAKsB,WAAL,CAAiBrB,OAAjB;;IAEA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;;;;;IAUa,wBAAA,GAAb,UAA4ByB,gBAA5B;;;;;;IACQ9H,YAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAA9B;IACArD,YAAAA,MAAM,GAAG7B,QAAQ,CAAC6B,MAAlB;IACAkG,YAAAA,WAAW,GAAG,KAAKT,YAAnB;qBAEFS,aAAA;;oBAAA;IACF;;kBAAMlG,MAAM,CAACsB,MAAP,CAActB,MAAM,CAACmG,wBAAP,CAAgCD,WAAW,CAACnR,QAA5C,CAAd,EAAN;;;IAAA0H,YAAAA,OAAA;;;;;;;;;;;IAEH,GARY;IAUb;;;;;;;;IAMO,qBAAA,GAAP;IACE,SAAKoJ,WAAL,CAAiBO,MAAjB;;IAEA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;IAMO,qBAAA,GAAP;IACE,SAAKX,YAAL,GAAoB,IAApB;IAEA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAsCa,qBAAA,GAAb,UAAyB1E,KAAzB,EAAuCtE,EAAvC;YACEgF,QAAQ;YACRyD;YAAA9F,SAAS,mBAAG/I,SAAS,CAACC;YACtB8H,SAAS;;;;IAMHD,QAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAA9B;IACArD,QAAAA,MAAM,GAAG7B,QAAQ,CAAC6B,MAAlB;IAEFjL,QAAAA,QAAQ,GAAGgM,KAAK,CAAChM,QAAjB;IACEsR,QAAAA,aAAa,GAAGrG,MAAM,CAACsG,iBAAP,CAAyBvR,QAAzB,CAAhB;;IAEN,YAAIgM,KAAK,CAACwF,OAAN,IAAiB,CAACF,aAAtB,EAAqC;IACnC;;gBAAOzB,OAAO,CAACC,MAAR,CAAe,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAc/D,sBAAd,CAAqCmN,KAAK,CAAChM,QAA3C,CAAlB,EAAwE4C,IAAA,CAAW/D,sBAAnF,CAAf,EAAP;IACD;;IACD,YAAI,CAACoM,MAAM,CAACwG,QAAP,CAAgBzF,KAAhB,CAAL,EAA6B;IAC3B;IACAhM,UAAAA,QAAQ,GAAGsR,aAAa,CAACtR,QAAzB;IACAgM,UAAAA,KAAK,GAAGsF,aAAa,CAACtF,KAAtB;IACD,SAJD,MAIO,IAAI5C,QAAQ,CAACsI,eAAb,EAA8B;IAE7BC,UAAAA,WAAS,KAAKb,WAAL,CAAiB9Q,QAA1B;IACA4R,UAAAA,YAAY,GAAG3G,MAAM,CAAC4G,SAAtB;IACAC,UAAAA,iBAAiB,GAAG,CAAC9R,QAAD,EAAWA,QAAQ,GAAG4R,YAAtB,EAAoC5R,QAAQ,GAAG4R,YAA/C,EACvBG,MADuB,CAChB,UAAA1L,GAAA;IACN,gBAAIgE,SAAS,KAAK/I,SAAS,CAACC,IAA5B,EAAkC,OAAO,IAAP;IAElC,mBAAO8I,SAAS,KAAK/I,SAAS,CAACH,IAAxB,GACHkF,GAAG,IAAIsL,QADJ,GAEHtL,GAAG,IAAIsL,QAFX;IAGD,WAPuB,CAApB;IASN3R,UAAAA,QAAQ,GAAG8R,iBAAiB,CAACE,MAAlB,CAAyB,UAACC,eAAD,EAAkB5L,GAAlB;IAClC,gBAAIhD,IAAI,CAAC6O,GAAL,CAASP,QAAM,GAAGtL,GAAlB,IAAyBhD,IAAI,CAAC6O,GAAL,CAASP,QAAM,GAAGM,eAAlB,CAA7B,EAAiE;IAC/D,qBAAO5L,GAAP;IACD,aAFD,MAEO;IACL,qBAAO4L,eAAP;IACD;IACF,WANU,EAMRE,QANQ,CAAX;IAOD;;IAED,aAAKC,wBAAL,CAA8BpG,KAA9B,EAAqCA,KAAK,CAAChM,QAA3C,EAAqDqJ,SAArD;;IAEA;;cAAO,KAAKgJ,kBAAL,CAAwB;IAAErS,UAAAA,QAAQ,UAAV;IAAY0M,UAAAA,QAAQ,UAApB;IAAsB8D,UAAAA,cAAc,EAAExE,KAAtC;IAA6C3C,UAAAA,SAAS;IAAtD,SAAxB,EAAP;;;IACD,GA/CY;;IAiDH,kCAAA,GAAV,UAAmC2C,KAAnC,EAAiDhM,QAAjD,EAAmEqJ,SAAnE;;;IACE,QAAMD,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAApC;IACA,QAAMgE,eAAe,GAAGtG,KAAK,KAAK,KAAK0E,YAAf,GAA8BzQ,MAAM,CAACS,WAArC,GAAmDT,MAAM,CAACW,YAAlF;IACA,QAAMqK,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IACA,QAAMkG,WAAW,GAAG,KAAKT,YAAzB;IAEA,QAAM6B,KAAK,GAAG,IAAI5I,gBAAJ,CAAmB2I,eAAnB,EAAoC;IAChDlG,MAAAA,KAAK,EAAEJ,KAAK,CAACI,KADmC;IAEhDJ,MAAAA,KAAK,OAF2C;IAGhD7B,MAAAA,SAAS,EAAE,CAAAd,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAEc,SAAX,KAAwB,KAHa;IAIhDE,MAAAA,SAAS,EAAEnF,cAAY,CAAC,MAAAiM,WAAW,SAAX,IAAAA,WAAW,WAAX,SAAA,GAAAA,WAAW,CAAEnR,QAAb,UAAA,iBAAA,KAAA,GAAyBiL,MAAM,CAACjL,QAAjC,EAA2CA,QAA3C;IAJyB,KAApC,CAAd;IAMAoJ,IAAAA,QAAQ,CAACQ,OAAT,CAAiB2I,KAAjB;;IAEA,QAAIA,KAAK,CAAC1I,UAAN,EAAJ,EAAwB;IACtB,YAAM,IAAI3L,aAAJ,CAAkB0E,OAAA,CAAc7D,mBAAhC,EAAqD6D,IAAA,CAAW7D,mBAAhE,CAAN;IACD;IACF,GAjBS;;IAmBM,4BAAA,GAAhB,UAAmC2I,EAAnC;YACE1H,QAAQ;YACR0M,QAAQ;YACR8D,cAAc;YACdnH,SAAS;;;;;;;IAOHD,QAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAA9B;IACAkE,QAAAA,YAAY,GAAG,KAAK9B,YAApB;;IACAV,QAAAA,OAAO,GAAG;IAAM,iBAAAjS,KAAI,CAAC+S,WAAL,CAAiB2B,SAAjB,CAA2BzS,QAA3B,EAAqC0M,QAArC,EAA+CrD,SAA/C,CAAA;IAAyD,SAAzE;;IACAc,QAAAA,SAAS,GAAG,CAAAd,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAEc,SAAX,KAAwB,KAApC;;IAEN,YAAIuC,QAAQ,IAAI,CAAhB,EAAmB;IACXgG,UAAAA,SAAS,GAAG1C,OAAO,EAAnB;;IACN,eAAK2C,UAAL,CAAgBnC,cAAhB,EAAgCgC,YAAhC,EAA8CrI,SAA9C;;IACA;;gBAAOuI,UAAP;IACD,SAJD,MAIO;IACL;;gBAAO1C,OAAO,GAAG4C,IAAV,CAAe;;;;;IACpB,yBAAKD,UAAL,CAAgBnC,cAAhB,EAAgCgC,YAAhC,EAA8CrI,SAA9C;;IACA;;0BAAMf,QAAQ,CAACG,QAAT,CAAkBsJ,MAAlB,GAAN;;;IAAAnL,oBAAAA,OAAA;;;;;;;;IACD,WAHM,EAAP;IAID;;;IACF,GA1Be;;IAkDlB,gBAAA;IAAC,GAvVD;;ICPA;;;;;IAIA;;;IAA0B/J,EAAAA,gCAAA;;IAA1B,sBAAA;;IAkFC;IAjFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAoCa,wBAAA,GAAb,UAA4BqC,QAA5B,EAA8C0M,QAA9C,EAAgErD,SAAhE;;;;IACQD,QAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAA9B;IACArD,QAAAA,MAAM,GAAG7B,QAAQ,CAAC6B,MAAlB;IACAkG,QAAAA,WAAW,GAAG,KAAKT,YAAnB;IAEAoC,QAAAA,eAAe,GAAG7H,MAAM,CAACmG,wBAAP,CAAgCpR,QAAhC,CAAlB;IACA+S,QAAAA,gBAAgB,GAAG9H,MAAM,CAACsG,iBAAP,CAAyBuB,eAAzB,CAAnB;;IAEN,YAAI,CAACC,gBAAD,IAAqB,CAAC5B,WAA1B,EAAuC;IACrC;;gBAAOtB,OAAO,CAACC,MAAR,CAAe,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAc/D,sBAAd,CAAqCmB,QAArC,CAAlB,EAAkE4C,IAAA,CAAW/D,sBAA7E,CAAf,EAAP;IACD;;IAEKmU,QAAAA,OAAO,GAAG7B,WAAW,CAACnR,QAAtB;IAEAiT,QAAAA,eAAe,GAAG5P,IAAI,CAAC6O,GAAL,CAASlS,QAAQ,GAAGgT,OAApB,KAAgC5J,QAAQ,CAAC8J,SAA3D;IACAC,QAAAA,cAAc,GAAInT,QAAQ,GAAGgT,OAAZ,GACnB/H,MAAM,CAACmI,aAAP,CAAqBL,gBAArB,CADmB,GAEnB9H,MAAM,CAACoI,aAAP,CAAqBN,gBAArB,CAFE;;IAON,YAAIE,eAAe,IAAIF,gBAAgB,CAAC/S,QAAjB,KAA8BmR,WAAW,CAACnR,QAAjE,EAA2E;IACzE;IACAsT,UAAAA,WAAW,GAAGP,gBAAgB,CAAC/G,KAA/B;IACAuH,UAAAA,SAAS,GAAGR,gBAAgB,CAAC/S,QAA7B;IACD,SAJD,MAIO,IAAIiT,eAAe,IAAIE,cAAvB,EAAuC;IAC5C;IACAG,UAAAA,WAAW,GAAGH,cAAc,CAACnH,KAA7B;IACAuH,UAAAA,SAAS,GAAGJ,cAAc,CAACnT,QAA3B;IACD,SAJM,MAIA;IACL;IACAuT,UAAAA,SAAS,GAAGtI,MAAM,CAACmG,wBAAP,CAAgCD,WAAW,CAACnR,QAA5C,CAAZ;IACAsT,UAAAA,WAAW,GAAGnC,WAAd;IACD;;IAED,aAAKiB,wBAAL,CAA8BkB,WAA9B,EAA2CtT,QAA3C,EAAqDqJ,SAArD;;IAEA;;cAAO,KAAKgJ,kBAAL,CAAwB;IAC7BrS,UAAAA,QAAQ,EAAEuT,SADmB;IAE7B7G,UAAAA,QAAQ,UAFqB;IAG7B8D,UAAAA,cAAc,EAAE8C,WAHa;IAI7BjK,UAAAA,SAAS;IAJoB,SAAxB,EAAP;;;IAMD,GA5CY;;IA6Cf,oBAAA;IAlFA,EAA0BmK,UAA1B;;ICMA;;;;;IAIA;;;IAA0B7V,EAAAA,gCAAA;IAaxB;;;IACA,sBAAA,CAAmB+J,EAAnB;YAAmByI,qBAEc;YAD/BsD;YAAAC,UAAU,mBAAG;;IADf,gBAGE5V,WAAA,KAAA,SAHF;;IAKEC,IAAAA,KAAI,CAAC4V,WAAL,GAAmBD,UAAnB;;IACD;;;IAXD1V,EAAAA,qBAAA,sBAAA;IANA;;;;;;aAMA;IAA0B,aAAO,KAAK2V,WAAZ;IAA0B;aAEpD,UAAsB/T,GAAtB;IAA+D,WAAK+T,WAAL,GAAmB/T,GAAnB;IAAyB;;;OAFxF;IAaA;;;;;;;;;;;IAUa,wBAAA,GAAb,UAA4BgU,eAA5B;;;;;;IACQxK,YAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAA9B;IACArD,YAAAA,MAAM,GAAG7B,QAAQ,CAAC6B,MAAlB;IACAkG,YAAAA,WAAW,GAAG,KAAKT,YAAnB;qBAEFS,aAAA;;oBAAA;IACI0C,YAAAA,UAAU,GAAG1C,WAAW,CAAC3C,KAAzB;IACAsF,YAAAA,WAAW,GAAGD,UAAU,CAAC/T,GAAX,GAAiB,CAAC+T,UAAU,CAAC9T,GAAX,GAAiB8T,UAAU,CAAC/T,GAA7B,IAAoC8T,eAAnE;IAEN;;kBAAM3I,MAAM,CAACsB,MAAP,CAActB,MAAM,CAACmG,wBAAP,CAAgC0C,WAAhC,CAAd,EAAN;;;IAAApM,YAAAA,OAAA;;;;;;;;;;;IAEH,GAXY;IAab;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAoCa,wBAAA,GAAb,UAA4B1H,QAA5B,EAA8C0M,QAA9C,EAAgErD,SAAhE;;;;IACQD,QAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,SAAjB,CAA9B;IAEArD,QAAAA,MAAM,GAAG7B,QAAQ,CAAC6B,MAAlB;IACAsI,QAAAA,SAAS,GAAGtI,MAAM,CAACmG,wBAAP,CAAgCpR,QAAhC,CAAZ;IAEA+S,QAAAA,gBAAgB,GAAG9H,MAAM,CAAC8I,yBAAP,CAAiCR,SAAjC,CAAnB;;IAEN,YAAI,CAACR,gBAAL,EAAuB;IACrB;;gBAAOlD,OAAO,CAACC,MAAR,CAAe,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAc/D,sBAAd,CAAqCmB,QAArC,CAAlB,EAAkE4C,IAAA,CAAW/D,sBAA7E,CAAf,EAAP;IACD;;IAEKyU,QAAAA,WAAW,GAAGP,gBAAgB,CAAC/G,KAA/B;;IAGN,YAAIsH,WAAW,KAAK,KAAK5C,YAAzB,EAAuC;IACrC,eAAK0B,wBAAL,CAA8BkB,WAA9B,EAA2CtT,QAA3C,EAAqDqJ,SAArD;IACD;;IAED;;cAAO,KAAKgJ,kBAAL,CAAwB;IAAErS,UAAAA,QAAQ,EAAE,KAAK2T,WAAL,GAAmBJ,SAAnB,GAA+BvT,QAA3C;IAAqD0M,UAAAA,QAAQ,UAA7D;IAA+D8D,UAAAA,cAAc,EAAE8C,WAA/E;IAA4FjK,UAAAA,SAAS;IAArG,SAAxB,EAAP;;;IACD,GApBY;;IAqBf,oBAAA;IAtGA,EAA0BmK,UAA1B;;IC3BA;;;;;;;;;;;;;;;;;;;;ICMA;;;;IAIA;;;IA2BE;;;;;;IAMA,sBAAA,CAAmB9L,EAAnB;YACE0E,KAAK;YACLpM,QAAQ;YACRgM,KAAK;IAML,SAAKgI,MAAL,GAAc5H,KAAd;IACA,SAAK6H,IAAL,GAAYjU,QAAZ;IACA,SAAKkU,MAAL,GAAclI,KAAd;IACD;;;IAlCDhO,EAAAA,qBAAA,iBAAA;IANA;;;;;;aAMA;IAAqB,aAAO,KAAKgW,MAAZ;IAAqB;;;OAA1C;IAOAhW,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IAAwB,aAAO,KAAKiW,IAAZ;IAAmB;;;OAA3C;IAOAjW,EAAAA,qBAAA,iBAAA;IANA;;;;;;aAMA;IAAqB,aAAO,KAAKkW,MAAZ;IAAqB;;;OAA1C;IAqBF,oBAAA;IAAC,GA9CD;;ICQA;;;;;IAIA;;;IAyLE;IACA,iBAAA,CAAmBxM,EAAnB;IAAA,oBAAA;;YAAmByI,qBAES;YAD1BsD;YAAA5P,KAAK,mBAAG3C,KAAK,CAACE;;IA8YN,+BAAA,GAAyB;;;IACjC,UAAM+S,UAAU,GAAG,CAAC,iBAAD,EAAoB,aAApB,EAAmC,cAAnC,EAAmD,YAAnD,EAAiE,WAAjE,CAAnB;IAEA,UAAMC,cAAc,GAAG3R,QAAQ,CAAC4R,eAAT,CAAyBtM,KAAhD;IACA,UAAIuM,aAAa,GAAG,EAApB;;;IACA,aAAgC,IAAAC,eAAApO,WAAAgO,WAAA,sCAAhC,sBAAA,sCAAA,EAA4C;IAAvC,cAAMK,iBAAiB,uBAAvB;;IACH,cAAIA,iBAAiB,IAAIJ,cAAzB,EAAyC;IACvCE,YAAAA,aAAa,GAAGE,iBAAhB;IACD;IACF;;;;;;;;;;;;;IAED,UAAI,CAACF,aAAL,EAAoB;IAClB,cAAM,IAAIpW,aAAJ,CAAkB0E,OAAA,CAAc9D,uBAAhC,EAAyD8D,IAAA,CAAW9D,uBAApE,CAAN;IACD;;IAEDf,MAAAA,KAAI,CAAC0W,UAAL,GAAkBH,aAAlB;IACD,KAhBS;;IA5YR,SAAKhG,SAAL,GAAiB,IAAjB;;IACA,SAAKV,oBAAL;;;IAGA,SAAK8G,MAAL,GAAc7Q,KAAd;IACD;;;IA3KD7F,EAAAA,qBAAA,mBAAA;IAPA;;IACA;;;;;;aAMA;IAAuB,aAAO,KAAKiJ,GAAZ;IAAkB;;;OAAzC;IAOAjJ,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IAAwB,aAAO,KAAK2W,SAAZ;IAAwB;;;OAAhD;IAOA3W,EAAAA,qBAAA,yBAAA;IANA;;;;;;aAMA;IAA6B,aAAO,KAAK4W,SAAZ;IAAwB;;;OAArD;IAQA5W,EAAAA,qBAAA,kBAAA;IAPA;;;;;;;aAOA;IAAsB,aAAO,KAAK6W,OAAZ;IAAsB;;;OAA5C;IASA7W,EAAAA,qBAAA,iBAAA;IARA;;;;;;;;aAQA;IAAqB,aAAO,KAAK8W,MAAZ;IAAqB;;;OAA1C;IAOA9W,EAAAA,qBAAA,qBAAA;IANA;;;;;;aAMA;IAAyB,aAAO,KAAK8W,MAAL,CAAY/U,GAAZ,GAAkB,KAAK+U,MAAL,CAAYhV,GAArC;IAA2C;;;OAApE;IAOA9B,EAAAA,qBAAA,yBAAA;IANA;;;;;;aAMA;IAA6B,aAAO,KAAK+W,cAAZ;IAA6B;;;OAA1D;IASA/W,EAAAA,qBAAA,wBAAA;IARA;;;;;;;;aAQA;IAA4B,aAAO;IAAE8B,QAAAA,GAAG,EAAE,KAAK6U,SAAL,GAAiB,KAAKC,SAA7B;IAAwC7U,QAAAA,GAAG,EAAE,KAAK4U,SAAL,GAAiB,KAAKC,SAAtB,GAAkC,KAAK9Q;IAApF,OAAP;IAAoG;;;OAAhI;IAOA9F,EAAAA,qBAAA,wBAAA;IANA;;;;;;aAMA;IAA4B,aAAO,KAAKgX,QAAZ;IAAuB;;;OAAnD;IAUAhX,EAAAA,qBAAA,yBAAA;IATA;;;;;;;;;aASA;IAA6B,aAAO;IAAEwQ,QAAAA,KAAK,EAAE,KAAKsG,MAAd;IAAsB9U,QAAAA,QAAQ,EAAE,KAAK2U,SAArC;IAAgDlG,QAAAA,QAAQ,EAAE;IAA1D,OAAP;IAA2E;;;OAAxG;IAOAzQ,EAAAA,qBAAA,kBAAA;IANA;;;;;;aAMA;IAAsB,aAAO,KAAK2W,SAAL,IAAkB,KAAKG,MAAL,CAAYhV,GAA9B,IAAqC,KAAK6U,SAAL,IAAkB,KAAKG,MAAL,CAAY/U,GAA1E;IAAgF;;;OAAtG;IAOA/B,EAAAA,qBAAA,gBAAA;IANA;;;;;;aAMA;IACE,UAAMoL,QAAQ,GAAG,KAAKkF,SAAtB;IACA,aAAOlF,QAAQ,GACXA,QAAQ,CAACsB,UAAT,GACEtB,QAAQ,CAAC0F,QAAT,CAAkBnH,KADpB,GAEEyB,QAAQ,CAAC0F,QAAT,CAAkBlH,MAHT,GAIX,CAJJ;IAKD;;;OAPD;IAiBA5J,EAAAA,qBAAA,oBAAA;IARA;;;;;;;;aAQA;IACE,UAAMoL,QAAQ,GAAG,KAAKkF,SAAtB;IACA,UAAMtO,QAAQ,GAAG,KAAK2U,SAAL,GAAiB,KAAKE,OAAvC;IACA,UAAMvD,aAAa,GAAG,KAAKC,iBAAL,CAAuB,KAAKoD,SAA5B,CAAtB;;IAEA,UAAI,CAACvL,QAAD,IAAa,CAACkI,aAAlB,EAAiC;IAC/B,eAAO2D,GAAP;IACD;;IAED,UAAMC,YAAY,GAAG5D,aAAa,CAACtF,KAAnC;IACA,UAAMmJ,QAAQ,GAAGD,YAAY,CAAClV,QAAb,GAAwBkV,YAAY,CAAC5O,MAAtD;IACA,UAAM8O,UAAU,GAAGhM,QAAQ,CAACY,OAAT,CAAiBD,UAAjB,CAA4B7F,MAA/C;IAEM,UAAAwD,KAAqC,KAAK8G,KAA1C;IAAA,UAAO6G,SAAS,SAAhB;IAAA,UAAuBC,SAAS,SAAhC;IACN,UAAMzD,SAAS,GAAG,KAAKA,SAAvB;;IAEA,UAAI7R,QAAQ,KAAKmV,QAAjB,EAA2B;IACzB,eAAOD,YAAY,CAAC9I,KAApB;IACD;;IAED,UAAIpM,QAAQ,GAAGmV,QAAf,EAAyB;IACvB,YAAMtE,SAAS,GAAGqE,YAAY,CAACvO,IAAb,EAAlB;IACA,YAAI2F,YAAY,GAAGuE,SAAS,GACxBA,SAAS,CAAC7Q,QAAV,GAAqB6Q,SAAS,CAACvK,MADP,GAExB+O,SAAS,GAAGD,UAAU,CAAC,CAAD,CAF1B,CAFuB;;IAOvB,YAAI9I,YAAY,GAAG6I,QAAnB,EAA6B;IAC3B7I,UAAAA,YAAY,IAAIuF,SAAhB;IACD;;IAED,eAAOqD,YAAY,CAAC9I,KAAb,GAAqB,CAArB,GAAyB1F,WAAW,CAAC1G,QAAD,EAAWsM,YAAX,EAAyB6I,QAAzB,CAA3C;IACD,OAZD,MAYO;IACL,YAAMI,SAAS,GAAGL,YAAY,CAACtO,IAAb,EAAlB;IACA,YAAI4O,YAAY,GAAGD,SAAS,GACxBA,SAAS,CAACvV,QAAV,GAAqBuV,SAAS,CAACjP,MADP,GAExBgP,SAAS,GAAGF,UAAU,CAAC,CAAD,CAF1B,CAFK;;IAOL,YAAII,YAAY,GAAGL,QAAnB,EAA6B;IAC3BK,UAAAA,YAAY,IAAI3D,SAAhB;IACD;;IAED,eAAOqD,YAAY,CAAC9I,KAAb,GAAqB1F,WAAW,CAAC1G,QAAD,EAAWmV,QAAX,EAAqBK,YAArB,CAAvC;IACD;IACF;;;OA7CD;IAqDAxX,EAAAA,qBAAA,iBAAA;IANA;;IACA;;;;;aAKA;IAAqB,aAAO,KAAK0W,MAAZ;IAAqB;IAE1C;aACA,UAAiB9U,GAAjB;IACE,WAAK8U,MAAL,GAAc9U,GAAd;IACD;;;OALD;IAkCA;;;;;;;;;;;IAUO,cAAA,GAAP,UAAYwJ,QAAZ;IACE,SAAKkF,SAAL,GAAiBlF,QAAjB;IAEA,QAAMqM,UAAU,GAAGrM,QAAQ,CAAC0F,QAAT,CAAkBxJ,OAArC;IAEAtC,IAAAA,cAAc,CAACyS,UAAU,CAACC,iBAAZ,EAA+B,6CAA/B,CAAd;IACA,SAAKzO,GAAL,GAAWwO,UAAU,CAACC,iBAAtB;;IACA,SAAKC,sBAAL;;IAEA,WAAO,IAAP;IACD,GAVM;IAYP;;;;;;;IAKO,iBAAA,GAAP;IACE,SAAKrH,SAAL,GAAiB,IAAjB;;IACA,SAAKV,oBAAL;;IACA,WAAO,IAAP;IACD,GAJM;IAMP;;;;;;;;;;;IASa,gBAAA,GAAb,UAAoBvH,GAApB;;;;;;IACQ2M,YAAAA,OAAO,GAAG,KAAK2B,SAAf;IAEN,iBAAKA,SAAL,GAAiBtO,GAAjB;IACA;;kBAAM,KAAKuP,qBAAL,GAAN;;;IAAAlO,YAAAA,OAAA;;IACA,iBAAKmO,eAAL;;IACA,iBAAKC,cAAL,CAAoB9C,OAApB,EAA6B3M,GAA7B;;IACA,iBAAK0P,eAAL;;;;;;;;IACD,GARY;IAUb;;;;;;;;;;IAQO,uBAAA,GAAP,UAAqBC,MAArB;IACE,WAAO,KAAKhB,QAAL,CAAcgB,MAAM,CAAC5J,KAAP,GAAe,CAA7B,KAAmC,IAA1C;IACD,GAFM;IAIP;;;;;;;;;;IAQO,uBAAA,GAAP,UAAqB4J,MAArB;IACE,WAAO,KAAKhB,QAAL,CAAcgB,MAAM,CAAC5J,KAAP,GAAe,CAA7B,KAAmC,IAA1C;IACD,GAFM;IAIP;;;;;;;;;;IAQO,4BAAA,GAAP,UAA0BJ,KAA1B;IACE,QAAM6H,UAAU,GAAG7H,KAAK,CAACwC,KAAzB;IAEA,WAAO,CAAC,KAAKmG,SAAL,GAAiBd,UAAU,CAAC/T,GAA7B,KAAqC+T,UAAU,CAAC9T,GAAX,GAAiB8T,UAAU,CAAC/T,GAAjE,CAAP;IACD,GAJM;IAMP;;;;;;;;;;IAQO,mCAAA,GAAP,UAAiCE,QAAjC;IACE,QAAMiW,OAAO,GAAG,KAAKjB,QAArB;IACA,QAAMkB,wBAAwB,GAAGD,OAAO,CAAClE,MAAR,CAAe,UAAAiE,MAAA;IAAU,aAAAA,MAAM,CAAChK,KAAP,CAAamK,eAAb,CAA6BnW,QAA7B,EAAuC,IAAvC,CAAA;IAA4C,KAArE,CAAjC;IAEA,WAAOkW,wBAAwB,CAAClE,MAAzB,CAAgC,UAACoE,OAAD,EAA8BJ,MAA9B;IACrC,UAAI,CAACI,OAAL,EAAc,OAAOJ,MAAP;IAEd,aAAO3S,IAAI,CAAC6O,GAAL,CAASkE,OAAO,CAACpW,QAAR,GAAmBA,QAA5B,IAAwCqD,IAAI,CAAC6O,GAAL,CAAS8D,MAAM,CAAChW,QAAP,GAAkBA,QAA3B,CAAxC,GACHoW,OADG,GAEHJ,MAFJ;IAGD,KANM,EAMJ,IANI,CAAP;IAOD,GAXM;IAaP;;;;;;;;;;IAQO,2BAAA,GAAP,UAAyBhW,QAAzB;IACE,QAAMiW,OAAO,GAAG,KAAKjB,QAArB;IAEA,QAAIiB,OAAO,CAACxP,MAAR,IAAkB,CAAtB,EAAyB,OAAO,IAAP;IAEzB,QAAI4P,QAAQ,GAAGlE,QAAf;;IACA,SAAK,IAAImE,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGL,OAAO,CAACxP,MAA5C,EAAoD6P,SAAS,EAA7D,EAAiE;IAC/D,UAAMN,MAAM,GAAGC,OAAO,CAACK,SAAD,CAAtB;IACA,UAAMC,IAAI,GAAGlT,IAAI,CAAC6O,GAAL,CAAS8D,MAAM,CAAChW,QAAP,GAAkBA,QAA3B,CAAb;;IAEA,UAAIuW,IAAI,GAAGF,QAAX,EAAqB;IACnB;IACA,eAAOJ,OAAO,CAACK,SAAS,GAAG,CAAb,CAAd;IACD;;IAEDD,MAAAA,QAAQ,GAAGE,IAAX;IACD;;;IAGD,WAAON,OAAO,CAACA,OAAO,CAACxP,MAAR,GAAiB,CAAlB,CAAd;IACD,GApBM;IAsBP;;;;;;;;IAMO,kCAAA,GAAP,UAAgCzG,QAAhC;IACE,QAAMwO,KAAK,GAAG,KAAKsG,MAAnB;IACA,WAAO3R,KAAK,CAACnD,QAAD,EAAWwO,KAAK,CAAC1O,GAAjB,EAAsB0O,KAAK,CAACzO,GAA5B,CAAZ;IACD,GAHM;IAKP;;;;;;;;IAMO,kBAAA,GAAP,UAAgBiM,KAAhB;IACE,QAAMwC,KAAK,GAAG,KAAKsG,MAAnB;IAEA,QAAI9I,KAAK,CAACwF,OAAV,EAAmB,OAAO,KAAP;IAEnB,QAAM2D,QAAQ,GAAGnJ,KAAK,CAAChM,QAAvB;IAEA,WAAOmV,QAAQ,IAAI3G,KAAK,CAAC1O,GAAlB,IAAyBqV,QAAQ,IAAI3G,KAAK,CAACzO,GAAlD;IACD,GARM;IAUP;;;;;;;;IAMO,gBAAA,GAAP,UAAciM,KAAd;IACE,QAAMwK,YAAY,GAAG,KAAKA,YAA1B;;IAEA,WAAOxK,KAAK,CAACyK,YAAN,CAAmBD,YAAY,CAAC1W,GAAhC,EAAqC0W,YAAY,CAACzW,GAAlD,EAAuD,KAAvD,CAAP;IACD,GAJM;IAMP;;;;;;;;IAMO,wBAAA,GAAP;IACE,QAAM8D,KAAK,GAAG,KAAK6Q,MAAnB;IAEA,QAAMgC,QAAQ,GAAG,OAAO7S,KAAP,KAAiB,QAAjB,GACZA,KAAqC,CAACoH,MAD1B,GAEbpH,KAFJ;IAIA,SAAK+Q,SAAL,GAAiBhR,UAAU,CAAC8S,QAAD,EAAW,KAAK5S,IAAhB,CAA3B;IAEA,WAAO,IAAP;IACD,GAVM;IAYP;;;;;;;;;;;IASO,uBAAA,GAAP;IACE,QAAMsF,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAMzC,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAAjC;IAEA,SAAKmJ,QAAL,GAAgBnJ,MAAM,CAACrM,GAAP,CAAW,UAACwM,KAAD,EAAQI,KAAR;IAAkB,aAAA,IAAIuK,WAAJ,CAAgB;IAC3DvK,QAAAA,KAAK,OADsD;IAE3DpM,QAAAA,QAAQ,EAAEgM,KAAK,CAAChM,QAF2C;IAG3DgM,QAAAA,KAAK;IAHsD,OAAhB,CAAA;IAI3C,KAJc,CAAhB;IAMA,WAAO,IAAP;IACD,GAXM;IAaP;;;;;;;;;;;IASO,8BAAA,GAAP;IACE,QAAM5C,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAM6C,WAAW,GAAG/H,QAAQ,CAACY,OAAT,CAAiBmH,WAArC;IAEA,QAAI,CAAC/H,QAAQ,CAACsB,UAAV,IAAwB,CAACtB,QAAQ,CAACwN,QAAlC,IAA8C,CAACzF,WAAnD,EAAgE;IAEhE/H,IAAAA,QAAQ,CAAC0F,QAAT,CAAkB+H,OAAlB,CAA0B;IACxBjP,MAAAA,MAAM,EAAEuJ,WAAW,CAACvJ;IADI,KAA1B;IAGD,GATM;;IAWA,sBAAA,GAAP;IACE,QAAMwB,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAMwI,gBAAgB,GAAG1N,QAAQ,CAACyC,MAAT,CAAgBkG,MAAhB,CAAuB,UAAA/F,KAAA;IAAS,aAAA,CAACA,KAAK,CAAC+K,QAAP;IAAe,KAA/C,CAAzB;IACA,QAAM/W,QAAQ,GAAG,KAAK2U,SAAtB;IAEA,SAAKE,OAAL,GAAeiC,gBAAgB,CAC5B/E,MADY,CACL,UAAA/F,KAAA;IAAS,aAAAA,KAAK,CAAChM,QAAN,GAAiBgM,KAAK,CAAC1F,MAAvB,GAAgCtG,QAAhC;IAAwC,KAD5C,EAEZgS,MAFY,CAEL,UAAC1L,MAAD,EAAS0F,KAAT;IAAmB,aAAA1F,MAAM,GAAG0F,KAAK,CAACgL,mBAAf;IAAkC,KAFhD,EAEkD,CAFlD,CAAf;;IAIA,SAAKjB,eAAL;IACD,GAVM;IAYP;;;;;;;;IAMO,+BAAA,GAAP;IACE,SAAKkB,mBAAL,GAA2B;IAAEtQ,MAAAA,IAAI,EAAE,KAAR;IAAeC,MAAAA,IAAI,EAAE;IAArB,KAA3B;IACA,WAAO,IAAP;IACD,GAHM;;IAKG,8BAAA,GAAV;IACE,SAAK+N,SAAL,GAAiB,CAAjB;IACA,SAAKC,SAAL,GAAiB,CAAjB;IACA,SAAKC,OAAL,GAAe,CAAf;IACA,SAAKC,MAAL,GAAc;IAAEhV,MAAAA,GAAG,EAAE,CAAP;IAAUC,MAAAA,GAAG,EAAE;IAAf,KAAd;IACA,SAAKgV,cAAL,GAAsB,EAAtB;IACA,SAAKC,QAAL,GAAgB,EAAhB;IACA,SAAKiC,mBAAL,GAA2B;IAAEtQ,MAAAA,IAAI,EAAE,KAAR;IAAeC,MAAAA,IAAI,EAAE;IAArB,KAA3B;IACD,GARS;;IAUM,+BAAA,GAAhB;;;;;;;;;IACQwC,YAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAA9B;IACAzC,YAAAA,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAA3B;IAEAqL,YAAAA,gBAAgB,GAAGrL,MAAM,CAACkG,MAAP,CAAc,UAAA/F,KAAA;IAAS,qBAAAjO,KAAI,CAACoZ,MAAL,CAAYnL,KAAZ,CAAA;IAAkB,aAAzC,CAAnB;IACAoL,YAAAA,iBAAiB,GAAG,KAAKrC,cAAzB;IACN,iBAAKA,cAAL,GAAsBmC,gBAAtB;IAEMG,YAAAA,KAAK,GAAYH,gBAAgB,CAACnF,MAAjB,CAAwB,UAAA/F,KAAA;IAAS,qBAAA,CAAChG,QAAQ,CAACoR,iBAAD,EAAoBpL,KAApB,CAAT;IAAmC,aAApE,CAAjB;IACAwF,YAAAA,OAAO,GAAY4F,iBAAiB,CAACrF,MAAlB,CAAyB,UAAA/F,KAAA;IAAS,qBAAA,CAAChG,QAAQ,CAACkR,gBAAD,EAAmBlL,KAAnB,CAAT;IAAkC,aAApE,CAAnB;sBAEFqL,KAAK,CAAC5Q,MAAN,GAAe,CAAf,IAAoB+K,OAAO,CAAC/K,MAAR,GAAiB,IAArC;;oBAAA;IACF;;kBAAM2C,QAAQ,CAACG,QAAT,CAAkBsJ,MAAlB,GAAN;;;IAAAnL,YAAAA,OAAA;;IAEA0B,YAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACe,cAA1B,EAA0C;IACzDqW,cAAAA,KAAK,OADoD;IAEzD7F,cAAAA,OAAO,SAFkD;IAGzD8F,cAAAA,aAAa,EAAEJ;IAH0C,aAA1C,CAAjB;;;;;;;;;;IAMH,GApBe;;IAsBN,yBAAA,GAAV;IACE,QAAMK,kBAAkB,GAAG,KAAKN,mBAAhC;IAEA,QAAIM,kBAAkB,CAAC5Q,IAAnB,IAA2B4Q,kBAAkB,CAAC3Q,IAAlD,EAAwD;IAExD,QAAMwC,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAMzC,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAAjC;;IAEA,QAAIA,MAAM,CAACpF,MAAP,IAAiB,CAArB,EAAwB;IACtB,UAAI,CAAC8Q,kBAAkB,CAAC5Q,IAAxB,EAA8B;IAC5ByC,QAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACc,UAA1B,EAAsC;IAAEsJ,UAAAA,SAAS,EAAE/I,SAAS,CAACH;IAAvB,SAAtC,CAAjB;IACAoW,QAAAA,kBAAkB,CAAC5Q,IAAnB,GAA0B,IAA1B;IACD;;IACD,UAAI,CAAC4Q,kBAAkB,CAAC3Q,IAAxB,EAA8B;IAC5BwC,QAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACc,UAA1B,EAAsC;IAAEsJ,UAAAA,SAAS,EAAE/I,SAAS,CAACD;IAAvB,SAAtC,CAAjB;IACAkW,QAAAA,kBAAkB,CAAC3Q,IAAnB,GAA0B,IAA1B;IACD;;IAED;IACD;;IAED,QAAMsF,cAAc,GAAG,KAAKyI,SAA5B;IACA,QAAM6C,UAAU,GAAG,KAAK1T,IAAxB;IACA,QAAM2T,WAAW,GAAG,KAAK3C,MAAzB;IACA,QAAM4C,kBAAkB,GAAGtO,QAAQ,CAACsO,kBAApC;IAEA,QAAMC,UAAU,GAAGzL,cAAc,GAAG,KAAK0I,SAAzC;IACA,QAAMgD,UAAU,GAAGD,UAAU,GAAGH,UAAhC;IAEA,QAAMK,UAAU,GAAGhM,MAAM,CAAC,CAAD,CAAzB;IACA,QAAMiM,SAAS,GAAGjM,MAAM,CAACA,MAAM,CAACpF,MAAP,GAAgB,CAAjB,CAAxB;;IAEA,QAAI,CAAC8Q,kBAAkB,CAAC5Q,IAAxB,EAA8B;IAC5B,UAAMoR,cAAc,GAAGF,UAAU,CAACrJ,KAAX,CAAiB1O,GAAxC;;IAEA,UAAI6X,UAAU,IAAKI,cAAc,GAAGL,kBAAhC,IAAuDxL,cAAc,IAAKuL,WAAW,CAAC3X,GAAZ,GAAkB4X,kBAAhG,EAAqH;IACnHtO,QAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACc,UAA1B,EAAsC;IAAEsJ,UAAAA,SAAS,EAAE/I,SAAS,CAACH;IAAvB,SAAtC,CAAjB;IACAoW,QAAAA,kBAAkB,CAAC5Q,IAAnB,GAA0B,IAA1B;IACD;IACF;;IAED,QAAI,CAAC4Q,kBAAkB,CAAC3Q,IAAxB,EAA8B;IAC5B,UAAMoR,aAAa,GAAGF,SAAS,CAACtJ,KAAV,CAAgBzO,GAAtC;;IAEA,UAAI6X,UAAU,IAAKI,aAAa,GAAGN,kBAA/B,IAAsDxL,cAAc,IAAKuL,WAAW,CAAC1X,GAAZ,GAAkB2X,kBAA/F,EAAoH;IAClHtO,QAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACc,UAA1B,EAAsC;IAAEsJ,UAAAA,SAAS,EAAE/I,SAAS,CAACD;IAAvB,SAAtC,CAAjB;IACAkW,QAAAA,kBAAkB,CAAC3Q,IAAnB,GAA0B,IAA1B;IACD;IACF;IACF,GAjDS;;IAmDA,wBAAA,GAAV,UAAyBoM,OAAzB,EAA0CiF,MAA1C;IACE,QAAM7O,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAME,KAAK,GAAG,KAAKsG,MAAnB;IAEA,QAAMoD,eAAe,GAAGlF,OAAO,GAAGxE,KAAK,CAAC1O,GAAhB,IAAuBkT,OAAO,GAAGxE,KAAK,CAACzO,GAA/D;IACA,QAAMoY,cAAc,GAAGF,MAAM,GAAGzJ,KAAK,CAAC1O,GAAf,IAAsBmY,MAAM,GAAGzJ,KAAK,CAACzO,GAA5D;IAEA,QAAI,CAACmY,eAAD,IAAoBC,cAAxB,EAAwC;IAExC,QAAM9N,SAAS,GAAG4N,MAAM,IAAIzJ,KAAK,CAAC1O,GAAhB,GAAsBwB,SAAS,CAACH,IAAhC,GAAuCG,SAAS,CAACD,IAAnE;IAEA+H,IAAAA,QAAQ,CAACQ,OAAT,CAAiB,IAAID,gBAAJ,CAAmB1J,MAAM,CAACgB,UAA1B,EAAsC;IACrDoJ,MAAAA,SAAS;IAD4C,KAAtC,CAAjB;IAGD,GAdS;;IAgBA,yBAAA,GAAV;IACE,QAAMjI,EAAE,GAAG,KAAK6E,GAAhB;IACA,QAAMmC,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IAEA,QAAM8J,cAAc,GAAG,KAAKzD,SAAL,GAAiB,KAAKC,SAAtB,GAAkC,KAAKC,OAA9D;IAEAzS,IAAAA,EAAE,CAAC2F,KAAH,CAAS,KAAK0M,UAAd,IAA4BrL,QAAQ,CAACsB,UAAT,GACxB,eAAa,CAAC0N,cAAd,QADwB,GAExB,kBAAgB,CAACA,cAAjB,QAFJ;IAGD,GATS;;IA4BZ,eAAA;IAAC,GA1lBD;;ICdA;;;;;IAIA;;;IAA2Bza,EAAAA,iCAAA;;IAA3B,uBAAA;;IAoBC;IAnBC;;;;;;;;;;;;;IASO,qBAAA,GAAP;;;IACE,QAAMyL,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAM/E,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;IAEA,QAAMsO,UAAU,GAAGtO,QAAQ,CAAC8O,QAAT,CAAkB,CAAlB,CAAnB;IACA,QAAMP,SAAS,GAAGvO,QAAQ,CAAC8O,QAAT,CAAkB9O,QAAQ,CAACC,UAAT,GAAsB,CAAxC,CAAlB;IAEA,SAAKsL,MAAL,GAAc;IAAEhV,MAAAA,GAAG,EAAE,MAAA+X,UAAU,SAAV,IAAAA,UAAU,WAAV,SAAA,GAAAA,UAAU,CAAE7X,QAAZ,UAAA,iBAAA,KAAA,GAAwB,CAA/B;IAAkCD,MAAAA,GAAG,EAAE,MAAA+X,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE9X,QAAX,UAAA,iBAAA,KAAA,GAAuB;IAA9D,KAAd;IACA,WAAO,IAAP;IACD,GATM;;IAUT,qBAAA;IApBA,EAA2BsY,SAA3B;;ICcA;;;;;IAIA;;;IAA6B3a,EAAAA,mCAAA;;IAA7B,yBAAA;IAAA,wEAAA;;IACUI,IAAAA,qBAAA,GAA0B,CAA1B;IACAA,IAAAA,sBAAA,GAA4B,KAA5B;;IAgNT;;;IA9MCC,EAAAA,qBAAA,kBAAA;aAAA;IAAsB,aAAO,KAAK6W,OAAL,GAAe,KAAK0D,eAA3B;IAA6C;;;OAAnE;IACAva,EAAAA,qBAAA,yBAAA;aAAA;IAA6B,aAAO;IAAEwQ,QAAAA,KAAK,EAAE,KAAKsG,MAAd;IAAsB9U,QAAAA,QAAQ,EAAE,KAAK2U,SAArC;IAAgDlG,QAAAA,QAAQ,EAAE,KAAK+J;IAA/D,OAAP;IAA2F;;;OAAxH;;IAEO,uBAAA,GAAP,UAAqBxC,MAArB;IACE,QAAI,CAAC,KAAKwC,gBAAN,IAA0BxC,MAAM,CAAC5J,KAAP,KAAiB,CAA/C,EAAkD,OAAOtO,gBAAA,CAAMuV,aAAN,KAAA,KAAA,EAAoB2C,MAApB,CAAP;IAElD,QAAMC,OAAO,GAAG,KAAKjB,QAArB;IACA,QAAMnD,SAAS,GAAG,KAAKA,SAAvB;IACA,QAAM4G,UAAU,GAAGxC,OAAO,CAACA,OAAO,CAACxP,MAAR,GAAiB,CAAlB,CAA1B;IAEA,WAAO,IAAIkQ,WAAJ,CAAgB;IACrBvK,MAAAA,KAAK,EAAEqM,UAAU,CAACrM,KADG;IAErBpM,MAAAA,QAAQ,EAAEyY,UAAU,CAACzY,QAAX,GAAsB6R,SAFX;IAGrB7F,MAAAA,KAAK,EAAEyM,UAAU,CAACzM;IAHG,KAAhB,CAAP;IAKD,GAZM;;IAcA,uBAAA,GAAP,UAAqBgK,MAArB;IACE,QAAMC,OAAO,GAAG,KAAKjB,QAArB;IAEA,QAAI,CAAC,KAAKwD,gBAAN,IAA0BxC,MAAM,CAAC5J,KAAP,KAAiB6J,OAAO,CAACxP,MAAR,GAAiB,CAAhE,EAAmE,OAAO3I,gBAAA,CAAMsV,aAAN,KAAA,KAAA,EAAoB4C,MAApB,CAAP;IAEnE,QAAMnE,SAAS,GAAG,KAAKA,SAAvB;IACA,QAAM6G,WAAW,GAAGzC,OAAO,CAAC,CAAD,CAA3B;IAEA,WAAO,IAAIU,WAAJ,CAAgB;IACrBvK,MAAAA,KAAK,EAAEsM,WAAW,CAACtM,KADE;IAErBpM,MAAAA,QAAQ,EAAE0Y,WAAW,CAAC1Y,QAAZ,GAAuB6R,SAFZ;IAGrB7F,MAAAA,KAAK,EAAE0M,WAAW,CAAC1M;IAHE,KAAhB,CAAP;IAKD,GAbM;;IAeA,mCAAA,GAAP,UAAiChM,QAAjC;IACE,QAAI,CAAC,KAAKwY,gBAAV,EAA4B,OAAO1a,gBAAA,CAAMiW,yBAAN,KAAA,KAAA,EAAgC/T,QAAhC,CAAP;IAE5B,QAAMwO,KAAK,GAAG,KAAKsG,MAAnB;IACA,QAAM6D,eAAe,GAAGvS,iBAAiB,CAACpG,QAAD,EAAWwO,KAAK,CAAC1O,GAAjB,EAAsB0O,KAAK,CAACzO,GAA5B,CAAzC;;IACA,QAAM6Y,aAAa,GAAG9a,gBAAA,CAAMiW,yBAAN,KAAA,KAAA,EAAgC4E,eAAhC,CAAtB;;IAEA,QAAI,CAACC,aAAL,EAAoB,OAAO,IAAP;IAEpB,QAAM/G,SAAS,GAAG,KAAKA,SAAvB;;IAEA,QAAI7R,QAAQ,GAAGwO,KAAK,CAAC1O,GAArB,EAA0B;IACxB,UAAM+Y,SAAS,GAAG,CAACxV,IAAI,CAACyV,KAAL,CAAW,CAACtK,KAAK,CAAC1O,GAAN,GAAYE,QAAb,IAAyB6R,SAApC,CAAD,GAAkD,CAApE;IAEA,aAAO,IAAI8E,WAAJ,CAAgB;IACrBvK,QAAAA,KAAK,EAAEwM,aAAa,CAACxM,KADA;IAErBpM,QAAAA,QAAQ,EAAE4Y,aAAa,CAAC5Y,QAAd,GAAyB6R,SAAS,GAAGgH,SAF1B;IAGrB7M,QAAAA,KAAK,EAAE4M,aAAa,CAAC5M;IAHA,OAAhB,CAAP;IAKD,KARD,MAQO,IAAIhM,QAAQ,GAAGwO,KAAK,CAACzO,GAArB,EAA0B;IAC/B,UAAM8Y,SAAS,GAAGxV,IAAI,CAACyV,KAAL,CAAW,CAAC9Y,QAAQ,GAAGwO,KAAK,CAACzO,GAAlB,IAAyB8R,SAApC,IAAiD,CAAnE;IAEA,aAAO,IAAI8E,WAAJ,CAAgB;IACrBvK,QAAAA,KAAK,EAAEwM,aAAa,CAACxM,KADA;IAErBpM,QAAAA,QAAQ,EAAE4Y,aAAa,CAAC5Y,QAAd,GAAyB6R,SAAS,GAAGgH,SAF1B;IAGrB7M,QAAAA,KAAK,EAAE4M,aAAa,CAAC5M;IAHA,OAAhB,CAAP;IAKD;;IAED,WAAO4M,aAAP;IACD,GA9BM;;IAgCA,kCAAA,GAAP,UAAgC5Y,QAAhC;IACE;IACA,WAAO,KAAKwY,gBAAL,GACHxY,QADG,GAEHlC,gBAAA,CAAMsT,wBAAN,KAAA,KAAA,EAA+BpR,QAA/B,CAFJ;IAGD,GALM;;IAOA,kBAAA,GAAP,UAAgBgM,KAAhB;IACE,QAAIA,KAAK,CAACwF,OAAV,EAAmB,OAAO,KAAP;IAEnB,WAAO,KAAKgH,gBAAL;IAAA,MAEH,IAFG,GAGH1a,gBAAA,CAAM2T,QAAN,KAAA,KAAA,EAAezF,KAAf,CAHJ;IAID,GAPM;;IASA,gBAAA,GAAP,UAAcA,KAAd;IACE,QAAMwC,KAAK,GAAG,KAAKsG,MAAnB;IACA,QAAMjD,SAAS,GAAG,KAAKA,SAAvB;IACA,QAAM2E,YAAY,GAAG,KAAKA,YAA1B;;IACA,QAAMuC,qBAAqB,GAAGjb,gBAAA,CAAMqZ,MAAN,KAAA,KAAA,EAAanL,KAAb,CAA9B;;IAEA,QAAI,CAAC,KAAKwM,gBAAV,EAA4B;IAC1B,aAAOO,qBAAP;IACD;;;IAGD,QAAIvC,YAAY,CAAC1W,GAAb,GAAmB0O,KAAK,CAAC1O,GAA7B,EAAkC;IAChC,aAAOiZ,qBAAqB,IAAI/M,KAAK,CAACyK,YAAN,CAAmBD,YAAY,CAAC1W,GAAb,GAAmB+R,SAAtC,EAAiD2E,YAAY,CAACzW,GAAb,GAAmB8R,SAApE,EAA+E,KAA/E,CAAhC;IACD,KAFD,MAEO,IAAI2E,YAAY,CAACzW,GAAb,GAAmByO,KAAK,CAACzO,GAA7B,EAAkC;IACvC,aAAOgZ,qBAAqB,IAAI/M,KAAK,CAACyK,YAAN,CAAmBD,YAAY,CAAC1W,GAAb,GAAmB+R,SAAtC,EAAiD2E,YAAY,CAACzW,GAAb,GAAmB8R,SAApE,EAA+E,KAA/E,CAAhC;IACD;;IAED,WAAOkH,qBAAP;IACD,GAlBM;IAoBP;;;;;;;;;;;IASO,qBAAA,GAAP;IACE,QAAM3P,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAM/E,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;IAEA,QAAMsC,MAAM,GAAGtC,QAAQ,CAACsC,MAAxB;;IACA,QAAIA,MAAM,CAACpF,MAAP,IAAiB,CAArB,EAAwB;IACtB,WAAKmH,oBAAL;;IACA,aAAO,IAAP;IACD;;IAED,QAAMiK,UAAU,GAAGhM,MAAM,CAAC,CAAD,CAAzB;IACA,QAAMiM,SAAS,GAAGjM,MAAM,CAACA,MAAM,CAACpF,MAAP,GAAgB,CAAjB,CAAxB;IACA,QAAMsR,cAAc,GAAGF,UAAU,CAACrJ,KAAX,CAAiB1O,GAAjB,GAAuB+X,UAAU,CAACmB,MAAX,CAAkBrS,IAAhE;IACA,QAAMqR,aAAa,GAAGF,SAAS,CAACtJ,KAAV,CAAgBzO,GAAhB,GAAsB+X,SAAS,CAACkB,MAAV,CAAiBpS,IAA7D;IAEA,QAAMqS,WAAW,GAAG,KAAKnV,IAAzB;IACA,QAAMoV,YAAY,GAAGlB,aAAa,GAAGD,cAArC;IAEA,QAAMoB,kBAAkB,GAAGtN,MAAM,CAC9BuN,KADwB,CAClB,UAAApN,KAAA;IAAS,aAAAkN,YAAY,GAAGlN,KAAK,CAAClI,IAArB,IAA6BmV,WAA7B;IAAwC,KAD/B,CAA3B;IAEA,SAAKT,gBAAL,GAAwBW,kBAAxB;;IAEA,QAAIA,kBAAJ,EAAwB;IACtB,WAAKrE,MAAL,GAAc;IAAEhV,QAAAA,GAAG,EAAEiY,cAAP;IAAuBhY,QAAAA,GAAG,EAAEiY;IAA5B,OAAd;IAEAnM,MAAAA,MAAM,CAAC9J,OAAP,CAAe,UAAAiK,KAAA;IAAS,eAAAA,KAAK,CAACqN,6BAAN,EAAA;IAAqC,OAA7D;IACD,KAJD,MAIO;IACL,WAAKvE,MAAL,GAAc;IAAEhV,QAAAA,GAAG,EAAE+X,UAAU,CAAC7X,QAAlB;IAA4BD,QAAAA,GAAG,EAAE+X,SAAS,CAAC9X;IAA3C,OAAd;IACD;;IAED,SAAKsZ,qBAAL;;IAEA,WAAO,IAAP;IACD,GAjCM;;IAmCM,gBAAA,GAAb,UAAoBjT,GAApB;;;;;;IACQ+C,YAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAA9B;IACA0E,YAAAA,OAAO,GAAG,KAAK2B,SAAf;sBAEFtO,GAAG,KAAK2M,UAAR;;oBAAA;IAAwB;;kBAAMlV,gBAAA,CAAMyO,MAAN,KAAA,KAAA,EAAalG,GAAb,EAAN;;;IAAP;;kBAAOqB,OAAA,GAAP;;;IAEfmE,YAAAA,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAA3B;IACA0N,YAAAA,OAAO,GAAG1N,MAAM,CAACrM,GAAP,CAAW,UAAAwM,KAAA;IAAS,qBAAAA,KAAK,CAACwN,MAAN,CAAaxG,OAAb,EAAsB3M,GAAtB,CAAA;IAA0B,aAA9C,CAAV;IAEN,iBAAKsO,SAAL,GAAiBtO,GAAjB;qBAEIkT,OAAO,CAACE,IAAR,CAAa,UAAAC,SAAA;IAAa,qBAAAA,SAAA;IAAS,aAAnC,GAAA;;oBAAA;;IACF,iBAAKJ,qBAAL;;IACA;;kBAAMlQ,QAAQ,CAACG,QAAT,CAAkBsJ,MAAlB,GAAN;;;IAAAnL,YAAAA,OAAA;;;;;IAGK;;kBAAM5J,gBAAA,CAAMyO,MAAN,KAAA,KAAA,EAAalG,GAAb,EAAN;;;IAAP;;kBAAOqB,OAAA,GAAP;;;;IACD,GAjBY;;IAmBH,yBAAA,GAAV;IACE,QAAMtF,EAAE,GAAG,KAAK6E,GAAhB;IACA,QAAMmC,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IAEA,QAAM8J,cAAc,GAAG,KAAKzD,SAAL,GAAiB,KAAKC,SAAtB,GAAkC,KAAKC,OAAvC,GAAiD,KAAK0D,eAA7E;IAEAnW,IAAAA,EAAE,CAAC2F,KAAH,CAAS,KAAK0M,UAAd,IAA4BrL,QAAQ,CAACsB,UAAT,GACxB,eAAa,CAAC0N,cAAd,QADwB,GAExB,kBAAgB,CAACA,cAAjB,QAFJ;IAGD,GATS;;IAWA,8BAAA,GAAV;IACEta,IAAAA,gBAAA,CAAM8P,oBAAN,KAAA,KAAA;;IACA,SAAK2K,eAAL,GAAuB,CAAvB;IACA,SAAKC,gBAAL,GAAwB,KAAxB;IACD,GAJS;;IAMF,2BAAA,GAAR,UAA0B3M,MAA1B;IACE,WAAOA,MAAM,CAACmG,MAAP,CAAc,UAAC2H,GAAD,EAAc3N,KAAd;IAA+B,aAAA2N,GAAG,GAAG3N,KAAK,CAACgL,mBAAZ;IAA+B,KAA5E,EAA8E,CAA9E,CAAP;IACD,GAFO;;IAIA,+BAAA,GAAR;IACE,QAAI,CAAC,KAAKwB,gBAAV,EAA4B;IAC1B,WAAKD,eAAL,GAAuB,CAAvB;IACA;IACD;;IAED,QAAMnP,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAMsL,WAAW,GAAY,EAA7B;IACA,QAAMC,WAAW,GAAY,EAA7B;IAEAzQ,IAAAA,QAAQ,CAACyC,MAAT,CACGkG,MADH,CACU,UAAA/F,KAAA;IAAS,aAAAA,KAAK,CAACuN,OAAN;IAAa,KADhC,EAEGxX,OAFH,CAEW,UAAAiK,KAAA;IACP,UAAIA,KAAK,CAAC8N,eAAN,KAA0BxY,SAAS,CAACH,IAAxC,EAA8C;IAC5CyY,QAAAA,WAAW,CAACjU,IAAZ,CAAiBqG,KAAjB;IACD,OAFD,MAEO;IACL6N,QAAAA,WAAW,CAAClU,IAAZ,CAAiBqG,KAAjB;IACD;IACF,KARH;IAUA,SAAKuM,eAAL,GAAuB,KAAKwB,iBAAL,CAAuBH,WAAvB,IAAsC,KAAKG,iBAAL,CAAuBF,WAAvB,CAA7D;IACD,GArBO;;IAsBV,uBAAA;IAlNA,EAA6BvB,SAA7B;;ICpBA;;;;;IAIA;;;IAA0B3a,EAAAA,gCAAA;;IAA1B,sBAAA;;IA8HC;IA7HC;;;;;;;;;;;;;IASO,qBAAA,GAAP;IACE,QAAMyL,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAM/E,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;IACA,QAAMyQ,QAAQ,GAAG,KAAKpF,SAAtB;IAEA,QAAMiD,UAAU,GAAGtO,QAAQ,CAAC8O,QAAT,CAAkB,CAAlB,CAAnB;IACA,QAAMP,SAAS,GAAGvO,QAAQ,CAAC8O,QAAT,CAAkB9O,QAAQ,CAACC,UAAT,GAAsB,CAAxC,CAAlB;;IAEA,QAAI,CAACqO,UAAD,IAAe,CAACC,SAApB,EAA+B;IAC7B,WAAKhD,MAAL,GAAc;IAAEhV,QAAAA,GAAG,EAAE,CAAP;IAAUC,QAAAA,GAAG,EAAE;IAAf,OAAd;IACA,aAAO,IAAP;IACD;;IAED,QAAMka,YAAY,GAAG,KAAKnW,IAA1B;IACA,QAAMiU,cAAc,GAAGF,UAAU,CAACrJ,KAAX,CAAiB1O,GAAxC;IACA,QAAMkY,aAAa,GAAGF,SAAS,CAACtJ,KAAV,CAAgBzO,GAAtC;IACA,QAAMma,aAAa,GAAGlC,aAAa,GAAGD,cAAtC;IACA,QAAMoC,eAAe,GAAGF,YAAY,GAAGC,aAAvC;;IAEA,QAAIC,eAAJ,EAAqB;IACnB,WAAKrF,MAAL,GAAc;IAAEhV,QAAAA,GAAG,EAAEiY,cAAc,GAAGiC,QAAxB;IAAkCja,QAAAA,GAAG,EAAEiY,aAAa,GAAGiC,YAAhB,GAA+BD;IAAtE,OAAd;IACD,KAFD,MAEO;IACL,WAAKlF,MAAL,GAAc;IAAEhV,QAAAA,GAAG,EAAE+X,UAAU,CAAC7X,QAAlB;IAA4BD,QAAAA,GAAG,EAAE+X,SAAS,CAAC9X;IAA3C,OAAd;IACD;;IAED,WAAO,IAAP;IACD,GA1BM;;IA4BA,uBAAA,GAAP;IAAA,oBAAA;;IACE,QAAMoJ,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,QAAjB,CAApC;IACA,QAAMzC,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAAjC;;IAEA,QAAIA,MAAM,CAACpF,MAAP,IAAiB,CAArB,EAAwB;IACtB,WAAKuO,QAAL,GAAgB,EAAhB;IACA,aAAO,IAAP;IACD;;IAED,QAAMxG,KAAK,GAAG,KAAKsG,MAAnB;IACA,QAAMsF,eAAe,GAAGvO,MAAM,CAACkG,MAAP,CAAc,UAAA/F,KAAA;IAAS,aAAAjO,KAAI,CAAC0T,QAAL,CAAczF,KAAd,CAAA;IAAoB,KAA3C,CAAxB;;IAEA,QAAIoO,eAAe,CAAC3T,MAAhB,GAAyB,CAA7B,EAAgC;IAC9B,UAAM4T,wBAAwB,GAAGD,eAAe,CAAC,CAAD,CAAf,CAAmBpa,QAAnB,KAAgCwO,KAAK,CAAC1O,GAAvE;IACA,UAAMwa,uBAAuB,GAAGF,eAAe,CAACA,eAAe,CAAC3T,MAAhB,GAAyB,CAA1B,CAAf,CAA4CzG,QAA5C,KAAyDwO,KAAK,CAACzO,GAA/F;IACA,UAAMwa,aAAW,GAAGF,wBAAwB,GAAG,CAAH,GAAO,CAAnD;IAEA,UAAMG,UAAU,GAAGJ,eAAe,CAAC5a,GAAhB,CAAoB,UAACwM,KAAD,EAAQtH,GAAR;IAAgB,eAAA,IAAIiS,WAAJ,CAAgB;IACrEvK,UAAAA,KAAK,EAAE1H,GAAG,GAAG6V,aADwD;IAErEva,UAAAA,QAAQ,EAAEgM,KAAK,CAAChM,QAFqD;IAGrEgM,UAAAA,KAAK;IAHgE,SAAhB,CAAA;IAIrD,OAJiB,CAAnB;;IAMA,UAAIqO,wBAAJ,EAA8B;IAC5BG,QAAAA,UAAU,CAACC,MAAX,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,IAAI9D,WAAJ,CAAgB;IACtCvK,UAAAA,KAAK,EAAE,CAD+B;IAEtCpM,UAAAA,QAAQ,EAAEwO,KAAK,CAAC1O,GAFsB;IAGtCkM,UAAAA,KAAK,EAAEH,MAAM,CAACuO,eAAe,CAAC,CAAD,CAAf,CAAmBhO,KAAnB,GAA2B,CAA5B;IAHyB,SAAhB,CAAxB;IAKD;;IAED,UAAIkO,uBAAJ,EAA6B;IAC3BE,QAAAA,UAAU,CAAC7U,IAAX,CAAgB,IAAIgR,WAAJ,CAAgB;IAC9BvK,UAAAA,KAAK,EAAEoO,UAAU,CAAC/T,MADY;IAE9BzG,UAAAA,QAAQ,EAAEwO,KAAK,CAACzO,GAFc;IAG9BiM,UAAAA,KAAK,EAAEH,MAAM,CAACuO,eAAe,CAACA,eAAe,CAAC3T,MAAhB,GAAyB,CAA1B,CAAf,CAA4C2F,KAA5C,GAAoD,CAArD;IAHiB,SAAhB,CAAhB;IAKD;;IAED,WAAK4I,QAAL,GAAgBwF,UAAhB;IACD,KA5BD,MA4BO,IAAIhM,KAAK,CAAC1O,GAAN,KAAc0O,KAAK,CAACzO,GAAxB,EAA6B;IAClC;IACA,UAAM2a,iBAAiB,GAAG,KAAKC,iBAAL,CAAuBnM,KAAK,CAAC1O,GAA7B,EAAkC+L,MAAlC,CAA1B;;IACA,UAAM+O,UAAU,GAAGF,iBAAiB,CAACtO,KAAlB,KAA4BP,MAAM,CAACpF,MAAP,GAAgB,CAA5C,GACfiU,iBAAiB,CAAC/T,IAAlB,EADe,GAEf+T,iBAFJ;IAGA,UAAMG,UAAU,GAAGD,UAAU,CAAChU,IAAX,EAAnB;IAEA,WAAKoO,QAAL,GAAgB,CACd,IAAI2B,WAAJ,CAAgB;IACdvK,QAAAA,KAAK,EAAE,CADO;IAEdpM,QAAAA,QAAQ,EAAEwO,KAAK,CAAC1O,GAFF;IAGdkM,QAAAA,KAAK,EAAE4O;IAHO,OAAhB,CADc,EAMd,IAAIjE,WAAJ,CAAgB;IACdvK,QAAAA,KAAK,EAAE,CADO;IAEdpM,QAAAA,QAAQ,EAAEwO,KAAK,CAACzO,GAFF;IAGdiM,QAAAA,KAAK,EAAE6O;IAHO,OAAhB,CANc,CAAhB;IAYD,KApBM,MAoBA;IACL,WAAK7F,QAAL,GAAgB,CAAC,IAAI2B,WAAJ,CAAgB;IAC/BvK,QAAAA,KAAK,EAAE,CADwB;IAE/BpM,QAAAA,QAAQ,EAAEwO,KAAK,CAAC1O,GAFe;IAG/BkM,QAAAA,KAAK,EAAE,KAAK2O,iBAAL,CAAuBnM,KAAK,CAAC1O,GAA7B,EAAkC+L,MAAlC;IAHwB,OAAhB,CAAD,CAAhB;IAKD;;IAED,WAAO,IAAP;IACD,GArEM;;IAuEC,2BAAA,GAAR,UAA0BxF,GAA1B,EAAuCwF,MAAvC;IACE,QAAIwK,QAAQ,GAAGlE,QAAf;;IACA,SAAK,IAAI2I,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAGjP,MAAM,CAACpF,MAAzC,EAAiDqU,QAAQ,EAAzD,EAA6D;IAC3D,UAAM9O,KAAK,GAAGH,MAAM,CAACiP,QAAD,CAApB;IACA,UAAMvE,IAAI,GAAGlT,IAAI,CAAC6O,GAAL,CAASlG,KAAK,CAAChM,QAAN,GAAiBqG,GAA1B,CAAb;;IAEA,UAAIkQ,IAAI,GAAGF,QAAX,EAAqB;IACnB;IACA,eAAOxK,MAAM,CAACiP,QAAQ,GAAG,CAAZ,CAAb;IACD;;IAEDzE,MAAAA,QAAQ,GAAGE,IAAX;IACD;;;IAGD,WAAO1K,MAAM,CAACA,MAAM,CAACpF,MAAP,GAAgB,CAAjB,CAAb;IACD,GAhBO;;IAiBV,oBAAA;IA9HA,EAA0B6R,SAA1B;;ICdA;;;;;;;;;;;;;ICQA;;;IAAA,+BAAA;;;;IACS,+BAAA,GAAP,UAA6BlP,QAA7B;IACE;IACAA,IAAAA,QAAQ,CAACyC,MAAT,CAAgB9J,OAAhB,CAAwB,UAAAiK,KAAA;IAAS,aAAAA,KAAK,CAAC+O,WAAN,EAAA;IAAmB,KAApD;IACD,GAHM;;IAIT,6BAAA;IAAC,GALD;;ICSA;;;;;IAIA;;;IA0CE;;;;IAIA,mBAAA,CAAmBrT,EAAnB;YAAmByI,qBAGW;YAF5BsD;YAAA5P,KAAK,mBAAG3C,KAAK,CAACE;YACd4Z;YAAAC,QAAQ,mBAAG,IAAIC,oBAAJ;;IAEX,SAAKxG,MAAL,GAAc7Q,KAAd;IACA,SAAKyK,SAAL,GAAiB,IAAjB;IACA,SAAK6M,kBAAL,GAA0BF,QAA1B;IACA,SAAKG,OAAL,GAAe,EAAf;IACD;;;IArCDpd,EAAAA,qBAAA,kBAAA;IARA;;IACA;;;;;;;aAOA;IAAsB,aAAO,KAAKod,OAAZ;IAAsB;;;OAA5C;IAOApd,EAAAA,qBAAA,sBAAA;IANA;;;;;;aAMA;IAA0B,aAAO,KAAKod,OAAL,CAAa3U,MAApB;IAA6B;;;OAAvD;IAQAzI,EAAAA,qBAAA,iBAAA;IANA;;IACA;;;;;aAKA;IAAqB,aAAO,KAAK0W,MAAZ;IAAqB;IAE1C;aACA,UAAiB9U,GAAjB;IACE,WAAK8U,MAAL,GAAc9U,GAAd;;IAEA,UAAMyb,UAAU,GAAG,KAAKC,cAAL,EAAnB;;IACA,WAAKF,OAAL,CAAarZ,OAAb,CAAqB,UAAAiK,KAAA;IAAWA,QAAAA,KAAK,CAACnI,KAAN,GAAcwX,UAAd;IAA2B,OAA3D;IACD;;;OARD;IA2CA;;;;;;;;IAOO,cAAA,GAAP,UAAYjS,QAAZ;IACE,SAAKkF,SAAL,GAAiBlF,QAAjB;;IACA,SAAKmS,cAAL;;IAEA,WAAO,IAAP;IACD,GALM;IAOP;;;;;;;IAKO,iBAAA,GAAP;IACE,SAAKjN,SAAL,GAAiB,IAAjB;IACA,SAAK8M,OAAL,GAAe,EAAf;IACD,GAHM;IAKP;;;;;;;;IAMO,kBAAA,GAAP,UAAgBhP,KAAhB;IACE,WAAO,KAAKgP,OAAL,CAAahP,KAAb,KAAuB,IAA9B;IACD,GAFM;IAIP;;;;;;;;IAMO,yBAAA,GAAP;IACE,SAAKgP,OAAL,CAAarZ,OAAb,CAAqB,UAAAiK,KAAA;IAAS,aAAAA,KAAK,CAAC9D,MAAN,EAAA;IAAc,KAA5C;;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;;;;;;IASO,qBAAA,GAAP;IAAA,oBAAA;;IAAmB,kBAAA;;aAAA,YAAArG,uBAAAA;IAAA2Z,MAAAA,SAAA,gBAAA;;;IAIjB,QAAM3P,MAAM,GAAG,KAAKuP,OAApB;IACA,QAAMhS,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IAEQ,QAAAtE,OAAO,GAAKZ,QAAQ,QAApB;;IACR,QAAMvF,KAAK,GAAG,KAAKyX,cAAL,EAAd;;IAEA,QAAMG,iBAAiB,GAAGD,KAAK,CAACxJ,MAAN,CAAa,UAAC0J,WAAD,EAAcC,IAAd;;;IACrC,UAAMC,YAAY,GAAG7V,wBAAwB,CAAC4V,IAAI,CAACvP,KAAN,EAAaP,MAAM,CAACpF,MAApB,CAA7C;IACA,UAAMoV,YAAY,GAAGhQ,MAAM,CAACnI,KAAP,CAAakY,YAAb,CAArB;IACA,UAAME,cAAc,GAAGH,IAAI,CAACpW,QAAL,CAAc/F,GAAd,CAAkB,UAAA4C,EAAA;IAAM,eAAArE,KAAI,CAACge,YAAL,CAAkB3Z,EAAlB,EAAsB;IAAEgK,UAAAA,KAAK,EAAEwP,YAAT;IAAuB/X,UAAAA,KAAK,OAA5B;IAA8BuF,UAAAA,QAAQ;IAAtC,SAAtB,CAAA;IAA+D,OAAvF,CAAvB;IAEAyC,MAAAA,MAAM,CAAC4O,MAAP,MAAA,CAAA5O,MAAA,iBAAc+P,cAAc,aAAME,gBAAlC;;IAGAA,MAAAA,cAAc,CAAC/Z,OAAf,CAAuB,UAAAiK,KAAA;IAAS,eAAAA,KAAK,CAAC9D,MAAN,EAAA;IAAc,OAA9C;;IAEA,UAAM8T,YAAY,GAAGje,KAAI,CAACke,gBAAL,CAAsBH,cAAtB,CAArB;;;IAGAD,MAAAA,YAAY,CAAC9Z,OAAb,CAAqB,UAAAiK,KAAA;IACnBA,QAAAA,KAAK,CAACkQ,aAAN,CAAoBJ,cAAc,CAACrV,MAAnC;IACAuF,QAAAA,KAAK,CAACmQ,gBAAN,CAAuBH,YAAvB;IACD,OAHD;;IAMAje,MAAAA,KAAI,CAACqe,oBAAL,CAA0BN,cAA1B,EAA0C,MAAAD,YAAY,CAAC,CAAD,CAAZ,UAAA,iBAAA,KAAA,GAAmB,IAA7D;;IAEA,sDAAWH,wBAAgBI,gBAA3B;IACD,KAtByB,EAsBvB,EAtBuB,CAA1B;IAwBA,QAAIL,iBAAiB,CAAChV,MAAlB,IAA4B,CAAhC,EAAmC,OAAO,EAAP;;IAGnC,SAAK4V,uBAAL;;IAEA,SAAK,KAAKxJ,MAAL,EAAL;IAGA;;IACA,QAAI4I,iBAAiB,CAAChV,MAAlB,GAA2B,CAA3B,IAAgC,CAACuD,OAAO,CAACgH,SAA7C,EAAwD;IACtD,WAAKhH,OAAO,CAACsS,WAAR,CAAoBtS,OAAO,CAACmH,WAAR,IAAuBsK,iBAAiB,CAAC,CAAD,CAA5D,EAAiE;IACpE/O,QAAAA,QAAQ,EAAE;IAD0D,OAAjE,EAEF6P,KAFE,CAEI;IAAM,eAAA,KAAK,CAAL;IAAM,OAFhB,CAAL;IAGD;;IAEDnT,IAAAA,QAAQ,CAAC6B,MAAT,CAAgBuR,YAAhB;IAEA,WAAOf,iBAAP;IACD,GApDM;IAsDP;;;;;;;;;;;IASO,qBAAA,GAAP;IAAA,oBAAA;;IAAmB,kBAAA;;aAAA,YAAA5Z,uBAAAA;IAAA2Z,MAAAA,SAAA,gBAAA;;;IACjB,QAAM3P,MAAM,GAAG,KAAKuP,OAApB;IACA,QAAMhS,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IAEQ,QAAArD,MAAM,GAAc7B,QAAQ,OAA5B;IAAA,QAAQY,OAAO,GAAKZ,QAAQ,QAA5B;IACR,QAAM+H,WAAW,GAAGnH,OAAO,CAACmH,WAA5B;IACA,QAAMsL,WAAW,GAAGzS,OAAO,CAACyS,WAA5B;IAEA,QAAMC,gBAAgB,GAAGlB,KAAK,CAACxJ,MAAN,CAAa,UAACR,OAAD,EAAUmK,IAAV;IAC5B,UAAAvP,KAAK,GAAkBuP,IAAI,MAA3B;IAAA,UAAOgB,WAAW,GAAKhB,IAAI,YAA3B;IACR,UAAMiB,WAAW,GAAG7W,wBAAwB,CAACqG,KAAD,EAAQP,MAAM,CAACpF,MAAf,CAA5C;IAEA,UAAMoW,YAAY,GAAGhR,MAAM,CAACnI,KAAP,CAAakZ,WAAW,GAAGD,WAA3B,CAArB;IACA,UAAMG,aAAa,GAAGjR,MAAM,CAAC4O,MAAP,CAAcmC,WAAd,EAA2BD,WAA3B,CAAtB;IAEA,UAAIG,aAAa,CAACrW,MAAd,IAAwB,CAA5B,EAA+B,OAAO,EAAP;;IAG/B,UAAMsW,WAAW,GAAGhf,KAAI,CAACke,gBAAL,CAAsBa,aAAtB,CAApB;;IACAD,MAAAA,YAAY,CAAC9a,OAAb,CAAqB,UAAAiK,KAAA;IACnBA,QAAAA,KAAK,CAACgR,aAAN,CAAoBF,aAAa,CAACrW,MAAlC;IACAuF,QAAAA,KAAK,CAACiR,gBAAN,CAAuBF,WAAvB;IACD,OAHD;;IAKAhf,MAAAA,KAAI,CAACmf,oBAAL,CAA0BJ,aAA1B;;;IAGAA,MAAAA,aAAa,CAAC/a,OAAd,CAAsB,UAAAiK,KAAA;IAAS,eAAAA,KAAK,CAACuD,OAAN,EAAA;IAAe,OAA9C;;IAGAxR,MAAAA,KAAI,CAACse,uBAAL;;IAEA,UAAIrW,QAAQ,CAAC8W,aAAD,EAAgB3L,WAAhB,CAAZ,EAA0C;IACxCnH,QAAAA,OAAO,CAACmT,WAAR;IACD;;IAED,sDAAW3L,oBAAYsL,eAAvB;IACD,KA7BwB,EA6BtB,EA7BsB,CAAzB;IA+BA,SAAK,KAAKjK,MAAL,EAAL;;IAGA,QAAI6J,gBAAgB,CAACjW,MAAjB,GAA0B,CAA1B,IAA+B,CAACuD,OAAO,CAACgH,SAA5C,EAAuD;IACrD,UAAMsC,WAAW,GAAGtN,QAAQ,CAAC0W,gBAAD,EAAmBvL,WAAnB,CAAR,GACftF,MAAM,CAAC4Q,WAAD,CAAN,IAAuB5Q,MAAM,CAACA,MAAM,CAACpF,MAAP,GAAgB,CAAjB,CADd,GAEhB0K,WAFJ;;IAIA,UAAImC,WAAJ,EAAiB;IACf,aAAKtJ,OAAO,CAACsS,WAAR,CAAoBhJ,WAApB,EAAiC;IACpC5G,UAAAA,QAAQ,EAAE;IAD0B,SAAjC,EAEF6P,KAFE,CAEI;IAAM,iBAAA,KAAK,CAAL;IAAM,SAFhB,CAAL;IAGD,OAJD,MAIO;IACL;IACA,aAAKtR,MAAM,CAACsB,MAAP,CAAc,CAAd,CAAL;IACD;IACF;;IAEDnD,IAAAA,QAAQ,CAAC6B,MAAT,CAAgBuR,YAAhB;IAEA,WAAOE,gBAAP;IACD,GA5DM;;IA8DG,wBAAA,GAAV;IACE,QAAM7Y,KAAK,GAAG,KAAK6Q,MAAnB;IAEA,WAAO,OAAO7Q,KAAP,KAAiB,QAAjB,GACFA,KAAoC,CAACmI,KADnC,GAEHnI,KAFJ;IAGD,GANS;;IAQA,0BAAA,GAAV,UAA2BgI,MAA3B;IACE,QAAMgM,UAAU,GAAGhM,MAAM,CAAC,CAAD,CAAzB;IACA,QAAMiM,SAAS,GAAGjM,MAAM,CAACA,MAAM,CAACpF,MAAP,GAAgB,CAAjB,CAAxB;IAEA,QAAM2W,UAAU,GAAGtF,SAAS,CAACkB,MAAV,CAAiBpS,IAAjB,GAAwBiR,UAAU,CAACmB,MAAX,CAAkBrS,IAA7D;IAEA,WAAQmR,SAAS,CAACtJ,KAAV,CAAgBzO,GAAhB,GAAsB8X,UAAU,CAACrJ,KAAX,CAAiB1O,GAAxC,GAA+Csd,UAAtD;IACD,GAPS;;IASA,iCAAA,GAAV;IACE,QAAMhU,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IACQ,QAAArD,MAAM,GAAc7B,QAAQ,OAA5B;IAAA,QAAQY,OAAO,GAAKZ,QAAQ,QAA5B;IAER6B,IAAAA,MAAM,CAACoS,WAAP;IACApS,IAAAA,MAAM,CAACqS,aAAP;IACArS,IAAAA,MAAM,CAACsS,qBAAP;IACAvT,IAAAA,OAAO,CAACwT,WAAR;IACD,GARS;;IASZ,iBAAA;IAAC,GAxRD;;ICNA;;;IA2NE;;;;;;IAMA,gBAAA,CAAmB9V,EAAnB;YACE0E,KAAK;YACLvI,KAAK;YACLuF,QAAQ;IAER,SAAK4K,MAAL,GAAc5H,KAAd;IACA,SAAKkC,SAAL,GAAiBlF,QAAjB;IAEA,SAAKsL,MAAL,GAAc7Q,KAAd;IAEA,SAAK4Z,QAAL,GAAgB,KAAhB;;IACA,SAAKC,oBAAL;IACD;;;IA9MD1f,EAAAA,qBAAA,iBAAA;IANA;;;;;;aAMA;IAAqB,aAAO,KAAKgW,MAAZ;IAAqB;;;OAA1C;IAOAhW,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IAAwB,aAAO,KAAKiW,IAAL,GAAY,KAAKW,SAAxB;IAAoC;;;OAA5D;IASA5W,EAAAA,qBAAA,gBAAA;IARA;;;;;;;;aAQA;IAAoB,aAAO,KAAK2f,KAAZ;IAAoB;;;OAAxC;IASA3f,EAAAA,qBAAA,+BAAA;IARA;;;;;;;;aAQA;IAAmC,aAAO,KAAK2f,KAAL,GAAa,KAAKC,OAAL,CAAajX,IAA1B,GAAiC,KAAKiX,OAAL,CAAahX,IAArD;IAA4D;;;OAA/F;IAOA5I,EAAAA,qBAAA,kBAAA;IANA;;;;;;aAMA;IAAsB,aAAO,KAAKmJ,OAAZ;IAAsB;;;OAA5C;IAWAnJ,EAAAA,qBAAA,kBAAA;IAVA;;;;;;;;;;aAUA;IAAsB,aAAO,KAAK4f,OAAZ;IAAsB;;;OAA5C;IAOA5f,EAAAA,qBAAA,yBAAA;IANA;;;;;;aAMA;IAA6B,aAAO,KAAK4W,SAAZ;IAAwB;;;OAArD;IAOA5W,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;IAAuB,aAAO,KAAKyf,QAAZ;IAAuB;;;OAA9C;IAgBAzf,EAAAA,qBAAA,iBAAA;IARA;;;;;;;;aAQA;IAAqB,aAAO;IAAE8B,QAAAA,GAAG,EAAE,KAAKmU,IAAZ;IAAkBlU,QAAAA,GAAG,EAAE,KAAKkU,IAAL,GAAY,KAAK0J;IAAxC,OAAP;IAAyD;;;OAA9E;IAOA3f,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;IAAuB,aAAO,KAAK6f,QAAZ;IAAuB;;;OAA9C;IAOA7f,EAAAA,qBAAA,2BAAA;IANA;;;;;;aAMA;IAA+B,aAAO,KAAK8f,gBAAZ;IAA+B;;;OAA9D;IAOA9f,EAAAA,qBAAA,kBAAA;IANA;;;;;;aAMA;IACE,UAAM8b,eAAe,GAAG,KAAKgE,gBAA7B;IACA,UAAMC,eAAe,GAAG,KAAKzP,SAAL,CAAerD,MAAf,CAAsB4G,SAA9C;IAEA,aAAOiI,eAAe,KAAKxY,SAAS,CAACC,IAA9B,IAAsC,CAAC,KAAKsc,QAA5C,GACH,CADG,GAEH/D,eAAe,KAAKxY,SAAS,CAACH,IAA9B,GACE,CAAC4c,eADH,GAEEA,eAJN;IAKD;;;OATD;IAiBA/f,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IACE,UAAMoL,QAAQ,GAAG,KAAKkF,SAAtB;IAEA,aAAO,KAAKlC,KAAL,GAAahD,QAAQ,CAAC6B,MAAT,CAAgB+S,QAApC;IACD;;;OAJD;IAYAhgB,EAAAA,qBAAA,0BAAA;IANA;;;;;;aAMA;IACE,UAAMgC,QAAQ,GAAG,KAAKA,QAAL,GAAgB,KAAKsG,MAAtC;IACA,UAAM2X,aAAa,GAAG,KAAKrJ,SAA3B;IACA,UAAM3J,MAAM,GAAG,KAAKqD,SAAL,CAAerD,MAA9B;IACA,UAAMiT,MAAM,GAAGjT,MAAM,CAACjL,QAAtB;;IAEA,UAAIke,MAAM,KAAKle,QAAf,EAAyB;IACvB,eAAO,CAAP;IACD;;IAED,UAAIke,MAAM,GAAGle,QAAb,EAAuB;IACrB,YAAMme,gBAAgB,GAAGne,QAAQ,IAAIiL,MAAM,CAACnH,IAAP,GAAcmH,MAAM,CAACgT,aAAzB,CAAR,GAAkDA,aAA3E;IAEA,eAAO,CAACvX,WAAW,CAACwX,MAAD,EAASle,QAAT,EAAmBme,gBAAnB,CAAnB;IACD,OAJD,MAIO;IACL,YAAMC,gBAAgB,GAAGpe,QAAQ,IAAIiL,MAAM,CAACgT,aAAP,GAAuB,KAAKN,KAA5B,GAAoCM,aAAxC,CAAjC;IAEA,eAAO,IAAIvX,WAAW,CAACwX,MAAD,EAASE,gBAAT,EAA2Bpe,QAA3B,CAAtB;IACD;IACF;;;OAnBD;IA2BAhC,EAAAA,qBAAA,wBAAA;IANA;;;;;;aAMA;IACE,UAAMwQ,KAAK,GAAG,KAAKA,KAAnB;IACA,UAAM1K,IAAI,GAAG,KAAK6Z,KAAlB;IACA,UAAMrX,MAAM,GAAG,KAAKA,MAApB;IACA,UAAMkQ,YAAY,GAAG,KAAKlI,SAAL,CAAerD,MAAf,CAAsBuL,YAA3C;IAEA,UAAM6H,aAAa,GAAG;IACpBve,QAAAA,GAAG,EAAE0O,KAAK,CAAC1O,GAAN,GAAYwG,MADG;IAEpBvG,QAAAA,GAAG,EAAEyO,KAAK,CAACzO,GAAN,GAAYuG;IAFG,OAAtB;;IAKA,UAAI+X,aAAa,CAACte,GAAd,IAAqByW,YAAY,CAAC1W,GAAlC,IAAyCue,aAAa,CAACve,GAAd,IAAqB0W,YAAY,CAACzW,GAA/E,EAAoF;IAClF,eAAO,CAAP;IACD;;IAED,UAAIkZ,WAAW,GAAGnV,IAAlB;;IAEA,UAAI0S,YAAY,CAAC1W,GAAb,GAAmBue,aAAa,CAACve,GAArC,EAA0C;IACxCmZ,QAAAA,WAAW,IAAIzC,YAAY,CAAC1W,GAAb,GAAmBue,aAAa,CAACve,GAAhD;IACD;;IACD,UAAI0W,YAAY,CAACzW,GAAb,GAAmBse,aAAa,CAACte,GAArC,EAA0C;IACxCkZ,QAAAA,WAAW,IAAIoF,aAAa,CAACte,GAAd,GAAoByW,YAAY,CAACzW,GAAhD;IACD;;IAED,aAAOkZ,WAAW,GAAGnV,IAArB;IACD;;;OAzBD;IAiCA9F,EAAAA,qBAAA,iBAAA;IANA;;IACA;;;;;aAKA;IAAqB,aAAO,KAAK0W,MAAZ;IAAqB;IAE1C;aACA,UAAiB9U,GAAjB;IAA+C,WAAK8U,MAAL,GAAc9U,GAAd;IAAoB;;;OAHnE;IAqCA;;;;;;;IAMO,gBAAA,GAAP;IACE,QAAMwC,EAAE,GAAG,KAAKkD,OAAhB;IACA,QAAM6C,OAAO,GAAGtB,QAAQ,CAACzE,EAAD,CAAxB;IACA,QAAMgH,QAAQ,GAAG,KAAKkF,SAAtB;IACA,QAAM5D,UAAU,GAAGtB,QAAQ,CAACsB,UAA5B;IACA,QAAMmG,SAAS,GAAGzH,QAAQ,CAACG,QAAT,CAAkBsC,MAAlB,CAAyB,KAAKmI,MAAL,GAAc,CAAvC,CAAlB;IAEA,SAAK2J,KAAL,GAAajT,UAAU,GAAGtI,EAAE,CAACgG,WAAN,GAAoBhG,EAAE,CAACiG,YAA9C;IAEA,SAAKuV,OAAL,GAAelT,UAAU,GACrB;IACA/D,MAAAA,IAAI,EAAE1B,UAAU,CAACkD,OAAO,CAACmW,UAAR,IAAsB,GAAvB,CADhB;IAEA1X,MAAAA,IAAI,EAAE3B,UAAU,CAACkD,OAAO,CAACoW,WAAR,IAAuB,GAAxB;IAFhB,KADqB,GAInB;IACF5X,MAAAA,IAAI,EAAE1B,UAAU,CAACkD,OAAO,CAACqW,SAAR,IAAqB,GAAtB,CADd;IAEF5X,MAAAA,IAAI,EAAE3B,UAAU,CAACkD,OAAO,CAACsW,YAAR,IAAwB,GAAzB;IAFd,KAJN;IASA,SAAKxK,IAAL,GAAYpD,SAAS,GACjBA,SAAS,CAACrC,KAAV,CAAgBzO,GAAhB,GAAsB8Q,SAAS,CAACmI,MAAV,CAAiBpS,IAAvC,GAA8C,KAAKgX,OAAL,CAAajX,IAD1C,GAEjB,KAAKiX,OAAL,CAAajX,IAFjB;IAIA,SAAKQ,OAAL,GAAeuD,UAAU,GAAGtI,EAAE,CAACiG,YAAN,GAAqB,KAAKsV,KAAnD;;IAEA,SAAKe,eAAL;;IAEA,WAAO,IAAP;IACD,GA3BM;IA6BP;;;;;;;;IAMO,kBAAA,GAAP,UAAgBpZ,OAAhB;IACE,WAAO,KAAKA,OAAL,CAAa2G,QAAb,CAAsB3G,OAAtB,CAAP;IACD,GAFM;IAIP;;;;;;;IAKO,iBAAA,GAAP;IACE,SAAKoY,oBAAL;;IACA,SAAKD,QAAL,GAAgB,IAAhB;IACD,GAHM;IAKP;;;;;;;;;IAOO,yBAAA,GAAP,UAAuBpX,GAAvB,EAAoCsY,aAApC;IAAoC,gCAAA,EAAA;IAAAA,MAAAA,qBAAA;;;IAClC,WAAO,KAAKlI,YAAL,CAAkBpQ,GAAlB,EAAuBA,GAAvB,EAA4BsY,aAA5B,CAAP;IACD,GAFM;IAIP;;;;;;;;;;IAQO,sBAAA,GAAP,UAAoB7e,GAApB,EAAiCC,GAAjC,EAA8C4e,aAA9C;IAA8C,gCAAA,EAAA;IAAAA,MAAAA,qBAAA;;;IAC5C,QAAM3F,MAAM,GAAG,KAAK4E,OAApB;IACA,QAAM/J,UAAU,GAAG,KAAKrF,KAAxB;;IAEA,QAAImQ,aAAJ,EAAmB;IACjB9K,MAAAA,UAAU,CAAC/T,GAAX,IAAkBkZ,MAAM,CAACrS,IAAzB;IACAkN,MAAAA,UAAU,CAAC9T,GAAX,IAAkBiZ,MAAM,CAACpS,IAAzB;IACD;;IAED,WAAO7G,GAAG,IAAI8T,UAAU,CAAC/T,GAAlB,IAAyBA,GAAG,IAAI+T,UAAU,CAAC9T,GAAlD;IACD,GAVM;IAYP;;;;;;;;IAMO,eAAA,GAAP,UAAa2M,QAAb;IACE,WAAO,KAAK4B,SAAL,CAAesQ,MAAf,CAAsB,KAAK5K,MAA3B,EAAmCtH,QAAnC,CAAP;IACD,GAFM;IAIP;;;;;;;;;IAOO,cAAA,GAAP;IACE,QAAMN,KAAK,GAAG,KAAK4H,MAAnB;IACA,QAAM5K,QAAQ,GAAG,KAAKkF,SAAtB;IACA,QAAM/E,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;IACA,QAAMC,UAAU,GAAGD,QAAQ,CAACC,UAA5B;IAEA,QAAIA,UAAU,KAAK,CAAnB,EAAsB,OAAO,IAAP;IAEtB,WAAOJ,QAAQ,CAACsI,eAAT,GACHnI,QAAQ,CAAC8O,QAAT,CAAkBjM,KAAK,KAAK,CAAV,GAAc5C,UAAU,GAAG,CAA3B,GAA+B4C,KAAK,GAAG,CAAzD,CADG,GAEH7C,QAAQ,CAAC8O,QAAT,CAAkBjM,KAAK,GAAG,CAA1B,CAFJ;IAGD,GAXM;IAaP;;;;;;;;;IAOO,cAAA,GAAP;IACE,QAAMA,KAAK,GAAG,KAAK4H,MAAnB;IACA,QAAM5K,QAAQ,GAAG,KAAKkF,SAAtB;IACA,QAAM/E,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;IACA,QAAMC,UAAU,GAAGD,QAAQ,CAACC,UAA5B;IAEA,QAAIA,UAAU,KAAK,CAAnB,EAAsB,OAAO,IAAP;IAEtB,WAAOJ,QAAQ,CAACsI,eAAT,GACHnI,QAAQ,CAAC8O,QAAT,CAAkBjM,KAAK,KAAK5C,UAAU,GAAG,CAAvB,GAA2B,CAA3B,GAA+B4C,KAAK,GAAG,CAAzD,CADG,GAEH7C,QAAQ,CAAC8O,QAAT,CAAkBjM,KAAK,GAAG,CAA1B,CAFJ;IAGD,GAXM;IAaP;;;;;;;;;;IAQO,uBAAA,GAAP,UAAqBxM,GAArB;IACE,SAAKoU,MAAL,IAAe3Q,IAAI,CAACtD,GAAL,CAASH,GAAT,EAAc,CAAd,CAAf;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;;;;;IAQO,uBAAA,GAAP,UAAqBA,GAArB;IACE,SAAKoU,MAAL,IAAe3Q,IAAI,CAACtD,GAAL,CAASH,GAAT,EAAc,CAAd,CAAf;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;;;;;IAQO,0BAAA,GAAP,UAAwBA,GAAxB;IACE,SAAKif,OAAL,CAAaxb,IAAI,CAACtD,GAAL,CAASH,GAAT,EAAc,CAAd,CAAb;;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;;;;;IAQO,0BAAA,GAAP,UAAwBA,GAAxB;IACE,SAAKif,OAAL,CAAa,CAACxb,IAAI,CAACtD,GAAL,CAASH,GAAT,EAAc,CAAd,CAAd;;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;IAIO,gBAAA,GAAP,UAAcoT,OAAd,EAA+BiF,MAA/B;IACE,QAAM6B,eAAe,GAAG,KAAKgE,gBAA7B;IACA,QAAMgB,cAAc,GAAG,KAAKC,eAA5B;IAEA,QAAIjF,eAAe,KAAKxY,SAAS,CAACC,IAA9B,IAAsC0W,MAAM,KAAKjF,OAArD,EAA8D,OAAO,KAAP;IAE9D,QAAMgM,WAAW,GAAG,KAAKnB,QAAzB;;IAEA,QAAI5F,MAAM,GAAGjF,OAAb,EAAsB;IACpB,UAAI8L,cAAc,IAAI9L,OAAlB,IAA6B8L,cAAc,IAAI7G,MAAnD,EAA2D;IACzD,aAAK4F,QAAL,GAAgB/D,eAAe,KAAKxY,SAAS,CAACD,IAA9C;IACD;IACF,KAJD,MAIO;IACL,UAAIyd,cAAc,IAAI9L,OAAlB,IAA6B8L,cAAc,IAAI7G,MAAnD,EAA2D;IACzD,aAAK4F,QAAL,GAAgB/D,eAAe,KAAKxY,SAAS,CAACD,IAA9C;IACD;IACF;;IAED,WAAO2d,WAAW,KAAK,KAAKnB,QAA5B;IACD,GAnBM;IAqBP;;;;;IAGO,uCAAA,GAAP;IACE,QAAMzU,QAAQ,GAAG,KAAKkF,SAAtB;;IAEA,QAAI,CAAClF,QAAQ,CAACsI,eAAd,EAA+B;IAC7B,WAAKoM,gBAAL,GAAwBxc,SAAS,CAACC,IAAlC;IACA,WAAKsc,QAAL,GAAgB,KAAhB;IACA,aAAO,IAAP;IACD;;IAED,QAAM5S,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IACA,QAAMgU,QAAQ,GAAGhU,MAAM,CAACuD,KAAxB;IACA,QAAM0Q,gBAAgB,GAAGjU,MAAM,CAACgT,aAAhC;IACA,QAAMkB,eAAe,GAAGlU,MAAM,CAACuL,YAA/B;IACA,QAAM4I,cAAc,GAAGD,eAAe,CAACpf,GAAhB,GAAsBof,eAAe,CAACrf,GAA7D;IAEA,QAAMuf,cAAc,GAAGJ,QAAQ,CAACnf,GAAT,GAAeof,gBAAtC;IACA,QAAMI,cAAc,GAAGL,QAAQ,CAAClf,GAAT,GAAemf,gBAAf,GAAkCE,cAAzD;IAEA,QAAMG,oBAAoB,GAAG,KAAK9I,YAAL,CAAkB6I,cAAc,GAAGF,cAAnC,EAAmDE,cAAnD,EAAmE,KAAnE,CAA7B;IACA,QAAME,oBAAoB,GAAG,KAAK/I,YAAL,CAAkB4I,cAAlB,EAAkCA,cAAc,GAAGD,cAAnD,EAAmE,KAAnE,CAA7B;IAEA,SAAKvB,QAAL,GAAgB,KAAhB;;IACA,QAAI0B,oBAAJ,EAA0B;IACxB,WAAKzB,gBAAL,GAAwBxc,SAAS,CAACH,IAAlC;IACA,WAAK4d,eAAL,GAAuB,KAAKvQ,KAAL,CAAWzO,GAAX,GAAiBkf,QAAQ,CAACnf,GAA1B,GAAgCmf,QAAQ,CAAClf,GAAzC,GAA+Cmf,gBAAtE;IACA,WAAK1F,MAAL,CAAYrH,QAAZ,EAAsBlH,MAAM,CAACjL,QAA7B;IACD,KAJD,MAIO,IAAIwf,oBAAJ,EAA0B;IAC/B,WAAK1B,gBAAL,GAAwBxc,SAAS,CAACD,IAAlC;IACA,WAAK0d,eAAL,GAAuB,KAAKvQ,KAAL,CAAW1O,GAAX,GAAiBmf,QAAQ,CAAClf,GAA1B,GAAgCqf,cAAhC,GAAiDF,gBAAxE;IACA,WAAK1F,MAAL,CAAY,CAACrH,QAAb,EAAuBlH,MAAM,CAACjL,QAA9B;IACD,KAJM,MAIA;IACL,WAAK8d,gBAAL,GAAwBxc,SAAS,CAACC,IAAlC;IACA,WAAKwd,eAAL,GAAuB,CAAvB;IACD;;IAED,WAAO,IAAP;IACD,GApCM;;IAsCC,iBAAA,GAAR,UAAgBnf,GAAhB;IACE,SAAKqU,IAAL,IAAarU,GAAb;IAEA,WAAO,IAAP;IACD,GAJO;;IAMA,yBAAA,GAAR;IACE,SAAKgV,SAAL,GAAiBhR,UAAU,CAAC,KAAK8Q,MAAN,EAAc,KAAKiJ,KAAnB,CAA3B;IACD,GAFO;;IAIA,8BAAA,GAAR;IACE,SAAKA,KAAL,GAAa,CAAb;IACA,SAAK1J,IAAL,GAAY,CAAZ;IACA,SAAK2J,OAAL,GAAe;IAAEjX,MAAAA,IAAI,EAAE,CAAR;IAAWC,MAAAA,IAAI,EAAE;IAAjB,KAAf;IACA,SAAKO,OAAL,GAAe,CAAf;IACA,SAAKyN,SAAL,GAAiB,CAAjB;IACA,SAAKiJ,QAAL,GAAgB,KAAhB;IACA,SAAKkB,eAAL,GAAuB,CAAvB;IACA,SAAKjB,gBAAL,GAAwBxc,SAAS,CAACC,IAAlC;IACD,GATO;;IAUV,cAAA;IAAC,GA7gBD;;ICLA;;;;;IAIA;;;IAA2B5D,EAAAA,iCAAA;IAczB;;;;;;;;;IAOA,uBAAA,CAAmB8hB,OAAnB;IAAA,gBACE3hB,WAAA,KAAA,EAAM2hB,OAAN,SADF;;IAGE1hB,IAAAA,KAAI,CAACkJ,GAAL,GAAWwY,OAAO,CAACrd,EAAnB;IACArE,IAAAA,KAAI,CAAC2hB,SAAL,GAAiB,IAAjB;;IACD;;;IAhBD1hB,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;IAAuB,aAAO,KAAKiJ,GAAZ;IAAkB;;;OAAzC;IAEAjJ,EAAAA,qBAAA,oBAAA;aAAA;IAAwB,aAAO,KAAK0hB,SAAZ;IAAwB;;;OAAhD;;IAgBO,qBAAA,GAAP;IACE,SAAKA,SAAL,GAAiB,IAAjB;IACD,GAFM;;IAIA,qBAAA,GAAP;IACE,SAAKA,SAAL,GAAiB,KAAjB;IACD,GAFM;;IAGT,qBAAA;IAnCA,EAA2BC,MAA3B;;ICJA;;;;IAGA;;;IAA8BhiB,EAAAA,oCAAA;;IAA9B,0BAAA;;IA+GC;;;;;IA7Gc,gBAAA,GAAb;;;;IACQsd,QAAAA,QAAQ,GAAG,KAAKE,kBAAhB;IACA/R,QAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAA9B;IACAsR,QAAAA,QAAQ,GAAGxW,QAAQ,CAAC6B,MAAT,CAAgB3F,OAA3B;IACAua,QAAAA,iBAAiB,GAAG,KAAKzE,OAAL,CAAarJ,MAAb,CAAoB,UAAA/F,KAAA;IAAS,iBAAAA,KAAK,CAAC1G,OAAN,CAAcwa,aAAd,KAAgCF,QAAhC;IAAwC,SAArE,CAApB;IAEN3E,QAAAA,QAAQ,CAAC8E,qBAAT,CAA+B3W,QAA/B;IACM4W,QAAAA,eAAe,GAAG,KAAKC,0BAAL,EAAlB;;IAEN,aAAK/C,oBAAL,CAA0B2C,iBAAiB,CAAC9N,MAAlB,CAAyB,UAAA/F,KAAA;IAAS,iBAAA,CAACA,KAAK,CAAC+K,QAAP;IAAe,SAAjD,CAA1B;;IACA,aAAKqF,oBAAL,CAA0B4D,eAAe,CAACjO,MAAhB,CAAuB,UAAA/F,KAAA;IAAS,iBAAAA,KAAK,CAAC1G,OAAN,CAAcwa,aAAd,KAAgCF,QAAhC;IAAwC,SAAxE,CAA1B,EAAqG,IAArG;;IACA,aAAKM,uBAAL,CAA6BF,eAA7B;;;;;;;IACD,GAZY;;;IAeA,8BAAA,GAAb;;;;IACQ5W,QAAAA,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAA9B;IACArD,QAAAA,MAAM,GAAG7B,QAAQ,CAAC6B,MAAlB;IACAkV,QAAAA,aAAa,GAAGlV,MAAM,CAAC3F,OAAvB;IACA8a,QAAAA,QAAQ,GAAG3d,QAAQ,CAAC4d,sBAAT,EAAX;;IAEN,aAAKjF,OAAL,CAAarZ,OAAb,CAAqB,UAAAiK,KAAA;IAAS,iBAAAoU,QAAQ,CAACE,WAAT,CAAqBtU,KAAK,CAAC1G,OAA3B,CAAA;IAAmC,SAAjE;;IAEA,aAAKib,0BAAL;;IAEAJ,QAAAA,aAAa,CAACG,WAAd,CAA0BF,QAA1B;;;;;;IACD,GAXY;;IAaH,wBAAA,GAAV;IACE,QAAMhX,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IAEA,QAAM6R,aAAa,GAAG/W,QAAQ,CAAC6B,MAAT,CAAgB3F,OAAtC;;IAGA9B,IAAAA,SAAO,CAAC2c,aAAa,CAACK,UAAf,CAAP,CAAkCze,OAAlC,CAA0C,UAAA0e,IAAA;IACxC,UAAIA,IAAI,CAAC5d,QAAL,KAAkBC,IAAI,CAAC4d,SAA3B,EAAsC;IACpCP,QAAAA,aAAa,CAACra,WAAd,CAA0B2a,IAA1B;IACD;IACF,KAJD;;IAMA,QAAM5c,KAAK,GAAG,KAAKyX,cAAL,EAAd;;IACA,QAAMqF,YAAY,GAAGnd,SAAO,CAAC2c,aAAa,CAACva,QAAf,CAA5B;IAEA,SAAKwV,OAAL,GAAeuF,YAAY,CAACnhB,GAAb,CACb,UAAC4C,EAAD,EAAkBgK,KAAlB;IAAoC,aAAA,IAAIwU,YAAJ,CAAiB;IAAExX,QAAAA,QAAQ,UAAV;IAAYhH,QAAAA,EAAE,IAAd;IAAgBgK,QAAAA,KAAK,OAArB;IAAuBvI,QAAAA,KAAK;IAA5B,OAAjB,CAAA;IAAgD,KADvE,CAAf;IAGD,GAlBS;;IAoBA,sBAAA,GAAV,UAAuBzB,EAAvB,EAAwCqd,OAAxC;IACE,WAAO,IAAImB,YAAJ;IAAmBxe,MAAAA,EAAE;WAAKqd,QAA1B,CAAP;IACD,GAFS;;IAIA,8BAAA,GAAV,UAA+B5T,MAA/B,EAAgDgV,WAAhD;IACE,QAAMzX,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IACA,QAAMrD,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IACA,QAAMkV,aAAa,GAAGlV,MAAM,CAAC3F,OAA7B;IACA,QAAMwb,kBAAkB,GAAG,CAAAD,WAAW,SAAX,IAAAA,WAAW,WAAX,SAAA,GAAAA,WAAW,CAAEvb,OAAb,KAAwB,IAAnD;IACA,QAAM8a,QAAQ,GAAG3d,QAAQ,CAAC4d,sBAAT,EAAjB;IAEAxU,IAAAA,MAAM,CAAC9J,OAAP,CAAe,UAAAiK,KAAA;IAAS,aAAAoU,QAAQ,CAACE,WAAT,CAAqBtU,KAAK,CAAC1G,OAA3B,CAAA;IAAmC,KAA3D;IACA6a,IAAAA,aAAa,CAACY,YAAd,CAA2BX,QAA3B,EAAqCU,kBAArC;IAEA,WAAO,IAAP;IACD,GAXS;;IAaA,8BAAA,GAAV,UAA+BjV,MAA/B;IACE,QAAMzC,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IACA,QAAM6R,aAAa,GAAG/W,QAAQ,CAAC6B,MAAT,CAAgB3F,OAAtC;IAEAuG,IAAAA,MAAM,CAAC9J,OAAP,CAAe,UAAAiK,KAAA;IACbmU,MAAAA,aAAa,CAACra,WAAd,CAA0BkG,KAAK,CAAC1G,OAAhC;IACD,KAFD;IAIA,WAAO,IAAP;IACD,GATS;;IAWF,iCAAA,GAAR,UAAgCuG,MAAhC;IACE,QAAMzC,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IACA,QAAMsR,QAAQ,GAAGxW,QAAQ,CAAC6B,MAAT,CAAgB3F,OAAjC;;IAGA,QAAM0b,cAAc,GAAGC,2BAAIpV,QAAJ,CAAYqV,OAAZ,EAAvB;;IACAF,IAAAA,cAAc,CAACjf,OAAf,CAAuB,UAACiK,KAAD,EAAQtH,GAAR;IACrB,UAAM6Q,SAAS,GAAGyL,cAAc,CAACtc,GAAG,GAAG,CAAP,CAAhC;IACA,UAAMyc,WAAW,GAAG5L,SAAS,GAAGA,SAAS,CAACjQ,OAAb,GAAuB,IAApD;;IAEA,UAAI0G,KAAK,CAAC1G,OAAN,CAAc8b,kBAAd,KAAqCD,WAAzC,EAAsD;IACpDvB,QAAAA,QAAQ,CAACmB,YAAT,CAAsB/U,KAAK,CAAC1G,OAA5B,EAAqC6b,WAArC;IACD;IACF,KAPD;IAQD,GAdO;;IAgBA,oCAAA,GAAR;IACE,QAAM/X,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IACA,QAAM6R,aAAa,GAAG/W,QAAQ,CAAC6B,MAAT,CAAgB3F,OAAtC;;IAGA,WAAO6a,aAAa,CAACta,UAArB,EAAiC;IAC/Bsa,MAAAA,aAAa,CAACra,WAAd,CAA0Bqa,aAAa,CAACta,UAAxC;IACD;IACF,GARO;;IAUA,oCAAA,GAAR;IACE,QAAMuD,QAAQ,GAAG9F,mBAAmB,CAAC,KAAKgL,SAAN,EAAiB,UAAjB,CAApC;IACA,QAAMzC,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAAjC;IAEA,WAAOA,MAAM,CAACkG,MAAP,CAAc,UAAA/F,KAAA;IAAS,aAAAA,KAAK,CAAC+K,QAAN;IAAc,KAArC,EACJsK,IADI,CACC,UAACC,CAAD,EAAIC,CAAJ;IAAU,aAACD,CAAC,CAACthB,QAAF,GAAashB,CAAC,CAAChb,MAAhB,IAA2Bib,CAAC,CAACvhB,QAAF,GAAauhB,CAAC,CAACjb,MAA1C,CAAA;IAAiD,KAD5D,CAAP;IAED,GANO;;IAOV,wBAAA;IA/GA,EAA8Bkb,WAA9B;;ICLA;;;;IAGA;;;IAAwC7jB,EAAAA,qCAAA;;IAAxC,2BAAA;;IAUC;;;;;IARW,8BAAA,GAAV,UAA+BkO,MAA/B,EAAgDgV,WAAhD;IAEC,GAFS;;;IAKA,8BAAA,GAAV,UAA+BhV,MAA/B;IAEC,GAFS;;IAGZ,yBAAA;IAVA,EAAwC2V,WAAxC;;ICHA;;;IAAA,mCAAA;;;;IACS,+BAAA,GAAP,UAA6BpY,QAA7B;IACE,QAAMyC,MAAM,GAAGzC,QAAQ,CAACG,QAAT,CAAkBsC,MAAjC;IACA,QAAMZ,MAAM,GAAG7B,QAAQ,CAAC6B,MAAxB;IAEA,QAAMwW,cAAc,GAAGxW,MAAM,CAACqM,aAAP,CAAqBtF,MAArB,CAA4B,UAAC0P,QAAD,EAAW1V,KAAX;IACjD0V,MAAAA,QAAQ,CAAC1V,KAAK,CAACI,KAAP,CAAR,GAAwB,IAAxB;IACA,aAAOsV,QAAP;IACD,KAHsB,EAGpB,EAHoB,CAAvB;IAKA7V,IAAAA,MAAM,CAAC9J,OAAP,CAAe,UAAAiK,KAAA;IACb,UAAIA,KAAK,CAACI,KAAN,IAAeqV,cAAnB,EAAmC;IACjCzV,QAAAA,KAAK,CAAC+O,WAAN;IACD,OAFD,MAEO,IAAI,CAAC3R,QAAQ,CAACgB,OAAd,EAAuB;IAC5B;IACA;IACA4B,QAAAA,KAAK,CAAC2V,WAAN;IACD;IACF,KARD;IAUA1W,IAAAA,MAAM,CAACuR,YAAP;IACD,GApBM;;IAqBT,iCAAA;IAAC,GAtBD;;ICRA;;;;;;;;;;;;;;IC8EA;;;;;;;;;;IAMuB7e,EAAAA,6BAAA;IAocrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BA,mBAAA,CAAmBikB,IAAnB,EAA+Cla,EAA/C;YAA+CyI,qBAuBjB;YAtB5BsD;YAAA5P,KAAK,mBAAG3C,KAAK,CAACE;YACd4Z;YAAA6G,YAAY,mBAAG;YACfC;YAAApX,UAAU,mBAAG;YACbqX;YAAAtT,QAAQ,mBAAG;YACXuT;YAAAC,KAAK,mBAAG;YACRC;YAAAtL,QAAQ,mBAAG;YACXuL;YAAAzK,kBAAkB,mBAAG;YACrB0K;YAAA1T,YAAY,mBAAG;YACf2T;YAAA3V,QAAQ,mBAAG;YACX4V;YAAA1T,MAAM,mBAAG,UAAAxL,CAAA;IAAK,aAAA,IAAIC,IAAI,CAACkf,GAAL,CAAS,IAAInf,CAAb,EAAgB,CAAhB,CAAJ;IAAsB;YACpCof;YAAAzT,SAAS,mBAAG,CAAC,OAAD,EAAU,OAAV;YACZ0T;YAAAC,QAAQ,mBAAG;YACXC;YAAAzP,SAAS,mBAAG;YACZ0P;YAAAjU,aAAa,mBAAG;YAChBkU;YAAA3e,MAAM,mBAAG;YACT4e;YAAA9T,qBAAqB,mBAAG;YACxB+T;YAAAC,kBAAkB,mBAAG;YACrBC;YAAAC,aAAa,mBAAG;YAChBC;YAAAC,iBAAiB,mBAAG;YACpBC;YAAAC,QAAQ,mBAAG;YACXC;YAAAC,UAAU,mBAAG;YACbC;YAAAC,cAAc,mBAAG;;IAtBnB,gBAwBE5lB,WAAA,KAAA,SAxBF;IA0bA;;;;;;;;;;IAQOC,IAAAA,YAAA,GAAS;;;;;;IACR+Q,cAAAA,QAAQ,GAAG,KAAK6U,SAAhB;IACApa,cAAAA,QAAQ,GAAG,KAAKqa,SAAhB;IACA3Y,cAAAA,MAAM,GAAG,KAAK4Y,OAAd;IACA7Z,cAAAA,OAAO,GAAG,KAAK8Z,QAAf;IAEA3S,cAAAA,WAAW,GAAGnH,OAAO,CAACmH,WAAtB;IACA4S,cAAAA,SAAS,GAAGjV,QAAQ,CAACnH,KAArB;IACAqc,cAAAA,UAAU,GAAGlV,QAAQ,CAAClH,MAAtB;IACAqc,cAAAA,mBAAmB,GAAG9S,WAAW,GACnClG,MAAM,CAACiZ,kBAAP,CAA0B/S,WAA1B,CADmC,GAEnC,CAFE;IAIN,mBAAKvH,OAAL,CAAa,IAAID,gBAAJ,CAAmB1J,MAAM,CAACE,aAA1B,EAAyC;IACpDwH,gBAAAA,KAAK,EAAEoc,SAD6C;IAEpDnc,gBAAAA,MAAM,EAAEoc,UAF4C;IAGpD1e,gBAAAA,OAAO,EAAEwJ,QAAQ,CAACxJ;IAHkC,eAAzC,CAAb;IAMAwJ,cAAAA,QAAQ,CAAC5G,MAAT;IACA;;oBAAMqB,QAAQ,CAAC4a,oBAAT,GAAN;;;IAAAzc,cAAAA,OAAA;;;IACA6B,cAAAA,QAAQ,CAAC6a,eAAT;IACA;;oBAAM7a,QAAQ,CAACsJ,MAAT,GAAN;;;IAAAnL,cAAAA,OAAA;;IACAuD,cAAAA,MAAM,CAACoZ,cAAP;IACApZ,cAAAA,MAAM,CAACoS,WAAP;IACApS,cAAAA,MAAM,CAACqS,aAAP;uBAEItT,OAAO,CAACgH,WAAR;;sBAAA;;;;;;IAGF;;oBAAMhH,OAAO,CAACsa,cAAR,CAAuBL,mBAAvB,EAAN;;;IAAAvc,cAAAA,OAAA;;IACAsC,cAAAA,OAAO,CAACwT,WAAR;;;;IAGIxV,cAAAA,QAAQ,GAAG8G,QAAQ,CAACnH,KAApB;IACAM,cAAAA,SAAS,GAAG6G,QAAQ,CAAClH,MAArB;IACA2c,cAAAA,WAAW,GAAGvc,QAAQ,KAAK+b,SAAb,IAA0B9b,SAAS,KAAK+b,UAAtD;IAEN,mBAAKpa,OAAL,CAAa,IAAID,gBAAJ,CAAmB1J,MAAM,CAACG,YAA1B,EAAwC;IACnDuH,gBAAAA,KAAK,EAAEmH,QAAQ,CAACnH,KADmC;IAEnDC,gBAAAA,MAAM,EAAEkH,QAAQ,CAAClH,MAFkC;IAGnDjB,gBAAAA,IAAI,EAAE;IACJgB,kBAAAA,KAAK,EAAEoc,SADH;IAEJnc,kBAAAA,MAAM,EAAEoc;IAFJ,iBAH6C;IAOnDO,gBAAAA,WAAW,aAPwC;IAQnDjf,gBAAAA,OAAO,EAAEwJ,QAAQ,CAACxJ;IARiC,eAAxC,CAAb;;;;;;;IAUD,KAhDM;;IAqNCvH,IAAAA,8BAAA,GAA2B,UAACsR,CAAD;IACjC,UAAItR,KAAI,CAAC+lB,QAAL,CAAc9S,SAAlB,EAA6B;IAC3B3B,QAAAA,CAAC,CAACmV,cAAF;IACD;IACF,KAJO;;;IA5nBNzmB,IAAAA,KAAI,CAAC0mB,YAAL,GAAoB,KAApB;IACA1mB,IAAAA,KAAI,CAAC2mB,QAAL,GAAgB,EAAhB;;IAGA3mB,IAAAA,KAAI,CAAC2W,MAAL,GAAc7Q,KAAd;IACA9F,IAAAA,KAAI,CAAC4mB,aAAL,GAAqB9C,YAArB;IACA9jB,IAAAA,KAAI,CAAC6mB,WAAL,GAAmBla,UAAnB;IACA3M,IAAAA,KAAI,CAAC8mB,SAAL,GAAiBpW,QAAjB;IACA1Q,IAAAA,KAAI,CAAC+mB,MAAL,GAAc7C,KAAd;IACAlkB,IAAAA,KAAI,CAACgnB,SAAL,GAAiBnO,QAAjB;IACA7Y,IAAAA,KAAI,CAACinB,mBAAL,GAA2BtN,kBAA3B;IACA3Z,IAAAA,KAAI,CAACknB,aAAL,GAAqBvW,YAArB;IACA3Q,IAAAA,KAAI,CAACmnB,SAAL,GAAiBxY,QAAjB;IACA3O,IAAAA,KAAI,CAAConB,OAAL,GAAevW,MAAf;IACA7Q,IAAAA,KAAI,CAACqnB,UAAL,GAAkBrW,SAAlB;IACAhR,IAAAA,KAAI,CAACsnB,SAAL,GAAiB3C,QAAjB;IACA3kB,IAAAA,KAAI,CAACunB,UAAL,GAAkBpS,SAAlB;IACAnV,IAAAA,KAAI,CAACwnB,cAAL,GAAsB5W,aAAtB;IACA5Q,IAAAA,KAAI,CAACynB,OAAL,GAAethB,MAAf;IACAnG,IAAAA,KAAI,CAAC0nB,sBAAL,GAA8BzW,qBAA9B;IACAjR,IAAAA,KAAI,CAAC2nB,mBAAL,GAA2B1C,kBAA3B;IACAjlB,IAAAA,KAAI,CAAC4nB,cAAL,GAAsBzC,aAAtB;IACAnlB,IAAAA,KAAI,CAAC6nB,kBAAL,GAA0BxC,iBAA1B;IACArlB,IAAAA,KAAI,CAAC8nB,WAAL,GAAmBrC,UAAnB;IACAzlB,IAAAA,KAAI,CAAC+nB,SAAL,GAAiBxC,QAAjB;IACAvlB,IAAAA,KAAI,CAACgoB,eAAL,GAAuBrC,cAAvB;;IAGA3lB,IAAAA,KAAI,CAAC4lB,SAAL,GAAiB,IAAIqC,QAAJ,CAAa7jB,UAAU,CAACyf,IAAD,CAAvB,CAAjB;IACA7jB,IAAAA,KAAI,CAAC6lB,SAAL,GAAiB7lB,KAAI,CAACkoB,eAAL,EAAjB;IACAloB,IAAAA,KAAI,CAAC8lB,OAAL,GAAe9lB,KAAI,CAACmoB,aAAL,EAAf;IACAnoB,IAAAA,KAAI,CAAC+lB,QAAL,GAAgB/lB,KAAI,CAACooB,cAAL,EAAhB;;IAEA,QAAIpoB,KAAI,CAAC+nB,SAAT,EAAoB;IAClB,WAAK/nB,KAAI,CAACkT,IAAL,EAAL;IACD;;;IACF;;;IAreDjT,EAAAA,qBAAA,mBAAA;IAXA;;IACA;;;;;;;;;;aAUA;IAAuB,aAAO,KAAK8lB,QAAZ;IAAuB;;;OAA9C;IAYA9lB,EAAAA,qBAAA,kBAAA;IAXA;;;;;;;;;;;aAWA;IAAsB,aAAO,KAAK6lB,OAAZ;IAAsB;;;OAA5C;IAWA7lB,EAAAA,qBAAA,oBAAA;IAVA;;;;;;;;;;aAUA;IAAwB,aAAO,KAAK4lB,SAAZ;IAAwB;;;OAAhD;IAQA5lB,EAAAA,qBAAA,oBAAA;IAPA;;;;;;;aAOA;IAAwB,aAAO,KAAK2lB,SAAZ;IAAwB;;;OAAhD;IAWA3lB,EAAAA,qBAAA,uBAAA;IAVA;;IACA;;;;;;;;;aASA;IAA2B,aAAO,KAAKymB,YAAZ;IAA2B;;;OAAtD;IAUAzmB,EAAAA,qBAAA,2BAAA;IATA;;;;;;;;;aASA;IAA+B,aAAO,KAAK6lB,OAAL,CAAanU,aAAb,CAA2BjB,QAAlC;IAA6C;;;OAA5E;IAQAzQ,EAAAA,qBAAA,iBAAA;IAPA;;;;;;;aAOA;IAAqB,aAAO,KAAK8lB,QAAL,CAAcrH,WAArB;IAAmC;;;OAAxD;IAOAze,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;IAAuB,aAAO,KAAK2lB,SAAL,CAAere,OAAtB;IAAgC;;;OAAvD;IAQAtH,EAAAA,qBAAA,wBAAA;IAPA;;;;;;;aAOA;IAA4B,aAAO,KAAK8lB,QAAL,CAAc3S,WAArB;IAAmC;;;OAA/D;IAQAnT,EAAAA,qBAAA,kBAAA;IAPA;;;;;;;aAOA;IAAsB,aAAO,KAAK4lB,SAAL,CAAe/X,MAAtB;IAA+B;;;OAArD;IAOA7N,EAAAA,qBAAA,sBAAA;IANA;;;;;;aAMA;IAA0B,aAAO,KAAK4lB,SAAL,CAAepa,UAAtB;IAAmC;;;OAA7D;IAQAxL,EAAAA,qBAAA,yBAAA;IAPA;;;;;;;aAOA;IAA6B,aAAO,KAAK6lB,OAAL,CAAavM,aAApB;IAAoC;;;OAAjE;IAOAtZ,EAAAA,qBAAA,qBAAA;IANA;;;;;;aAMA;IAAyB,aAAO,KAAK8lB,QAAL,CAAc9S,SAArB;IAAiC;;;OAA1D;IAOAhT,EAAAA,qBAAA,mBAAA;IANA;;;;;;aAMA;IAAuB,aAAO,KAAK8lB,QAAL,CAAc1Z,OAArB;IAA+B;;;OAAtD;IAOApM,EAAAA,qBAAA,yBAAA;IANA;;;;;;aAMA;IAA6B,aAAO,KAAK0mB,QAAZ;IAAuB;;;OAApD;IA+BA1mB,EAAAA,qBAAA,iBAAA;IA7BA;IACA;;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;aA2BA;IAAqB,aAAO,KAAK0W,MAAZ;IAAqB;IAqN1C;IACA;aACA,UAAiB9U,GAAjB;IACE,WAAK8U,MAAL,GAAc9U,GAAd;IACA,WAAKgkB,SAAL,CAAe/f,KAAf,GAAuBjE,GAAvB;IACA,WAAKikB,OAAL,CAAahgB,KAAb,GAAqBjE,GAArB;IACD;;;OA3ND;IAOA5B,EAAAA,qBAAA,wBAAA;IANA;;;;;;aAMA;IAA4B,aAAO,KAAK2mB,aAAZ;IAA4B;aAsNxD,UAAwB/kB,GAAxB;IAAgE,WAAK+kB,aAAL,GAAqB/kB,GAArB;IAA2B;;;OAtN3F;IAOA5B,EAAAA,qBAAA,sBAAA;IANA;;;;;;aAMA;IAA0B,aAAO,KAAK4mB,WAAZ;IAA0B;aAgNpD,UAAsBhlB,GAAtB;IAA4D,WAAKglB,WAAL,GAAmBhlB,GAAnB;IAAyB;;;OAhNrF;IAOA5B,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IAAwB,aAAO,KAAK6mB,SAAZ;IAAwB;aA0MhD,UAAoBjlB,GAApB;IAAwD,WAAKilB,SAAL,GAAiBjlB,GAAjB;IAAuB;;;OA1M/E;IASA5B,EAAAA,qBAAA,iBAAA;IARA;;;;;;;;aAQA;IAAqB,aAAO,KAAK8mB,MAAZ;IAAqB;aAkM1C,UAAiBllB,GAAjB;IAAkD,WAAKklB,MAAL,GAAcllB,GAAd;IAAoB;;;OAlMtE;IAOA5B,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IAAwB,aAAO,KAAK+mB,SAAZ;IAAwB;aA4LhD,UAAoBnlB,GAApB;IAAwD,WAAKmlB,SAAL,GAAiBnlB,GAAjB;IAAuB;;;OA5L/E;IAQA5B,EAAAA,qBAAA,8BAAA;IAPA;;IACA;;;;;;aAMA;IAAkC,aAAO,KAAKgnB,mBAAZ;IAAkC;;;OAApE;IAQAhnB,EAAAA,qBAAA,wBAAA;IAPA;;IACA;;;;;;aAMA;IAA4B,aAAO,KAAKinB,aAAZ;IAA4B;IA6KxD;aACA,UAAwBrlB,GAAxB;IAAgE,WAAKqlB,aAAL,GAAqBrlB,GAArB;IAA2B;;;OA9K3F;IAQA5B,EAAAA,qBAAA,kBAAA;IAPA;;;;;;;aAOA;IAAsB,aAAO,KAAKmnB,OAAZ;IAAsB;aAuK5C,UAAkBvlB,GAAlB;IAAoD,WAAKulB,OAAL,GAAevlB,GAAf;IAAqB;;;OAvKzE;IAOA5B,EAAAA,qBAAA,oBAAA;IANA;;;;;;aAMA;IAAwB,aAAO,KAAKknB,SAAZ;IAAwB;aAiKhD,UAAoBtlB,GAApB;IAAwD,WAAKslB,SAAL,GAAiBtlB,GAAjB;IAAuB;;;OAjK/E;IAUA5B,EAAAA,qBAAA,qBAAA;IATA;;IACA;;;;;;;;aAQA;IAAyB,aAAO,KAAKonB,UAAZ;IAAyB;IAwJlD;aACA,UAAqBxlB,GAArB;IAA0D,WAAKwlB,UAAL,GAAkBxlB,GAAlB;IAAwB;;;OAzJlF;IA+BA5B,EAAAA,qBAAA,oBAAA;IA9BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aA8BA;IAAwB,aAAO,KAAKqnB,SAAZ;IAAwB;aA2HhD,UAAoBzlB,GAApB;IAAwD,WAAKylB,SAAL,GAAiBzlB,GAAjB;IAAuB;;;OA3H/E;IAOA5B,EAAAA,qBAAA,qBAAA;IANA;;;;;;aAMA;IAAyB,aAAO,KAAKsnB,UAAZ;IAAyB;aAqHlD,UAAqB1lB,GAArB;IAA0D,WAAK0lB,UAAL,GAAkB1lB,GAAlB;IAAwB;;;OArHlF;IAOA5B,EAAAA,qBAAA,yBAAA;IANA;;;;;;aAMA;IAA6B,aAAO,KAAKunB,cAAZ;IAA6B;aA+G1D,UAAyB3lB,GAAzB;IAAkE,WAAK2lB,cAAL,GAAsB3lB,GAAtB;IAA4B;;;OA/G9F;IAgCA5B,EAAAA,qBAAA,kBAAA;IA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aA+BA;IAAsB,aAAO,KAAKwnB,OAAZ;IAAsB;aAgF5C,UAAkB5lB,GAAlB;IAAoD,WAAK4lB,OAAL,GAAe5lB,GAAf;IAAqB;;;OAhFzE;IAOA5B,EAAAA,qBAAA,iCAAA;IANA;;;;;;aAMA;IAAqC,aAAO,KAAKynB,sBAAZ;IAAqC;aA0E1E,UAAiC7lB,GAAjC;IAAkF,WAAK6lB,sBAAL,GAA8B7lB,GAA9B;IAAoC;;;OA1EtH;IAOA5B,EAAAA,qBAAA,8BAAA;IANA;;;;;;aAMA;IAAkC,aAAO,KAAK0nB,mBAAZ;IAAkC;aAoEpE,UAA8B9lB,GAA9B;IAA4E,WAAK8lB,mBAAL,GAA2B9lB,GAA3B;IAAiC;;;OApE7G;IAOA5B,EAAAA,qBAAA,yBAAA;IANA;;;;;;aAMA;IAA6B,aAAO,KAAK2nB,cAAZ;IAA6B;aA8D1D,UAAyB/lB,GAAzB;IAAkE,WAAK+lB,cAAL,GAAsB/lB,GAAtB;IAA4B;;;OA9D9F;IAQA5B,EAAAA,qBAAA,6BAAA;IAPA;;IACA;;;;;;aAMA;IAAiC,aAAO,KAAK4nB,kBAAZ;IAAiC;IAuDlE;aACA,UAA6BhmB,GAA7B;IAA0E,WAAKgmB,kBAAL,GAA0BhmB,GAA1B;IAAgC;;;OAxD1G;IASA5B,EAAAA,qBAAA,oBAAA;IARA;;IACA;;;;;;;aAOA;IAAwB,aAAO,KAAK8nB,SAAZ;IAAwB;;;OAAhD;IASA9nB,EAAAA,qBAAA,sBAAA;IARA;;;;;;;;aAQA;IAA0B,aAAO,KAAK6nB,WAAZ;IAA0B;IAuCpD;aACA,UAAsBjmB,GAAtB;IAA4D,WAAKimB,WAAL,GAAmBjmB,GAAnB;IAAyB;;;OAxCrF;IASA5B,EAAAA,qBAAA,0BAAA;IARA;;;;;;;;aAQA;IAA8B,aAAO,KAAK+nB,eAAZ;IAA8B;;;OAA5D;IA8HA;;;;;;;;;IAQa,cAAA,GAAb;;;;;;;;;IACE,gBAAI,KAAKtB,YAAT,EAAuB;;iBAAA;IAEjBxZ,YAAAA,MAAM,GAAG,KAAK4Y,OAAd;IACAta,YAAAA,QAAQ,GAAG,KAAKqa,SAAhB;IACA5Z,YAAAA,OAAO,GAAG,KAAK8Z,QAAf;IACAhV,YAAAA,QAAQ,GAAG,KAAK6U,SAAhB;IAEN1Y,YAAAA,MAAM,CAACgG,IAAP,CAAY,IAAZ;IACA1H,YAAAA,QAAQ,CAAC0H,IAAT,CAAc,IAAd;IACAjH,YAAAA,OAAO,CAACiH,IAAR,CAAa,IAAb;IAEA;;kBAAM,KAAK/I,MAAL,GAAN;;;IAAAR,YAAAA,OAAA;;;IAGA,iBAAK0e,mBAAL;;IAEA,gBAAI,KAAKP,WAAT,EAAsB;IACpB/e,cAAAA,MAAM,CAACuf,gBAAP,CAAwB,QAAxB,EAAkC,KAAKne,MAAvC;IACD;;IACD,gBAAI,KAAKwd,mBAAT,EAA8B;IAC5B5W,cAAAA,QAAQ,CAACxJ,OAAT,CAAiB+gB,gBAAjB,CAAkC,OAAlC,EAA2C,KAAKC,wBAAhD;IACD;;IACD,gBAAI,KAAKX,cAAT,EAAyB;IACvB,mBAAKY,YAAL;IACD;;IAED,iBAAK7B,QAAL,CAAc3iB,OAAd,CAAsB,UAAAykB,MAAA;IAAU,qBAAAA,MAAM,CAACvV,IAAP,CAAYlT,KAAZ,CAAA;IAAiB,aAAjD;;;IAGA,iBAAK0mB,YAAL,GAAoB,IAApB;IACA,iBAAK7a,OAAL,CAAa,IAAID,gBAAJ,CAAmB1J,MAAM,CAACC,KAA1B,CAAb;IAEA;;iBAAA;;;;IACD,GAlCY;IAoCb;;;;;;;IAKO,iBAAA,GAAP;IACE,QAAI,CAAC,KAAKukB,YAAV,EAAwB;IAExB,SAAKnU,GAAL;IACAxJ,IAAAA,MAAM,CAAC2f,mBAAP,CAA2B,QAA3B,EAAqC,KAAKve,MAA1C;;IACA,SAAKyb,SAAL,CAAere,OAAf,CAAuBmhB,mBAAvB,CAA2C,OAA3C,EAAoD,KAAKH,wBAAzD;;IAEA,SAAKxC,QAAL,CAAcvU,OAAd;;IACA,SAAKsU,OAAL,CAAatU,OAAb;;IACA,SAAKqU,SAAL,CAAerU,OAAf;;IAEA,SAAKmV,QAAL,CAAc3iB,OAAd,CAAsB,UAAAykB,MAAA;IAAU,aAAAA,MAAM,CAACjX,OAAP,EAAA;IAAgB,KAAhD;;IAEA,SAAKkV,YAAL,GAAoB,KAApB;IACD,GAdM;IAgBP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiCO,cAAA,GAAP,UAAY/X,QAAZ;;;IAAY,2BAAA,EAAA;IAAAA,MAAAA,WAAmB,KAAKwY,SAAxB;;;IACV,WAAO,KAAKtG,MAAL,CAAY,MAAA,MAAA,MAAA,KAAKkF,QAAL,CAAc3S,WAAd,UAAA,iBAAA,SAAA,MAA2BxK,MAA3B,UAAA,iBAAA,SAAA,MAAmCyF,KAAnC,UAAA,iBAAA,KAAA,GAA4C,CAAC,CAAzD,EAA4DM,QAA5D,EAAsEpL,SAAS,CAACH,IAAhF,CAAP;IACD,GAFM;IAIP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAkCO,cAAA,GAAP,UAAYuL,QAAZ;;;IAAY,2BAAA,EAAA;IAAAA,MAAAA,WAAmB,KAAKwY,SAAxB;;;IACV,WAAO,KAAKtG,MAAL,CAAY,MAAA,MAAA,MAAA,KAAKkF,QAAL,CAAc3S,WAAd,UAAA,iBAAA,SAAA,MAA2BvK,MAA3B,UAAA,iBAAA,SAAA,MAAmCwF,KAAnC,UAAA,iBAAA,KAAA,GAA4C,KAAKwX,SAAL,CAAepa,UAAvE,EAAmFkD,QAAnF,EAA6FpL,SAAS,CAACD,IAAvG,CAAP;IACD,GAFM;IAIP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAoCO,gBAAA,GAAP,UAAc+K,KAAd,EAA6BM,QAA7B,EAAgErC,SAAhE;IAA6B,2BAAA,EAAA;IAAAqC,MAAAA,WAAmB,KAAKwY,SAAxB;;;IAAmC,4BAAA,EAAA;IAAA7a,MAAAA,YAAuC/I,SAAS,CAACC,IAAjD;;;IAC9D,QAAMgI,QAAQ,GAAG,KAAKqa,SAAtB;IACA,QAAMpa,UAAU,GAAGD,QAAQ,CAACC,UAA5B;IAEA,QAAMwC,KAAK,GAAGzC,QAAQ,CAAC8O,QAAT,CAAkBjM,KAAlB,CAAd;;IAEA,QAAI,CAACJ,KAAL,EAAY;IACV,aAAO6D,OAAO,CAACC,MAAR,CAAe,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAchE,kBAAd,CAAiCwN,KAAjC,EAAwC,CAAxC,EAA2C5C,UAAU,GAAG,CAAxD,CAAlB,EAA8E5G,IAAA,CAAWhE,kBAAzF,CAAf,CAAP;IACD;;IAED,QAAI,KAAKklB,QAAL,CAAc9S,SAAlB,EAA6B;IAC3B,aAAOnB,OAAO,CAACC,MAAR,CAAe,IAAI5R,aAAJ,CAAkB0E,OAAA,CAAc3D,yBAAhC,EAA2D2D,IAAA,CAAW3D,yBAAtE,CAAf,CAAP;IACD;;IAED,WAAO,KAAK6kB,QAAL,CAAcxH,WAAd,CAA0BtQ,KAA1B,EAAiC;IACtCU,MAAAA,QAAQ,UAD8B;IAEtCrC,MAAAA,SAAS;IAF6B,KAAjC,CAAP;IAID,GAlBM;IAoBP;;;;;;;;;;;;;;IAYO,kBAAA,GAAP,UAAgB+B,KAAhB;IACE,WAAO,KAAKwX,SAAL,CAAevL,QAAf,CAAwBjM,KAAxB,CAAP;IACD,GAFM;IAIP;;;;;;;IAKO,qBAAA,GAAP;IACE,SAAK0X,QAAL,CAActU,MAAd;;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;;IAKO,sBAAA,GAAP;IACE,SAAKsU,QAAL,CAAcrU,OAAd;;IACA,WAAO,IAAP;IACD,GAHM;IAKP;;;;;;;;;;;;;IAWO,mBAAA,GAAP,UAAiB/H,EAAjB;;;YAAiBsT,qBAUZ;YATH8G;YAAA1V,KAAK,mBAAG;YACR2V;YAAA/hB,QAAQ,mBAAG;YACXgiB;YAAA0E,gBAAgB,mBAAG;YACnBxE;YAAAyE,iBAAiB,mBAAG;;IAOpB,QAAM1b,MAAM,GAAG,KAAK4Y,OAApB;IACA,QAAMhY,MAAM,GAAG8a,iBAAiB,GAAG,KAAKrP,aAAR,GAAwB,KAAKzL,MAA7D;IAEA,QAAM+a,MAAM,GAAW;IACrB/a,MAAAA,MAAM,EAAEA,MAAM,CAACrM,GAAP,CAAW,UAAAwM,KAAA;IACjB,YAAM6a,SAAS,GAAwB;IAAEza,UAAAA,KAAK,EAAEJ,KAAK,CAACI;IAAf,SAAvC;;IAEA,YAAIsa,gBAAJ,EAAsB;IACpBG,UAAAA,SAAS,CAACC,IAAV,GAAiB9a,KAAK,CAAC1G,OAAN,CAAcyhB,SAA/B;IACD;;IAED,eAAOF,SAAP;IACD,OARO;IADa,KAAvB;;IAYA,QAAIza,KAAJ,EAAW;IACTwa,MAAAA,MAAM,CAACxa,KAAP,GAAe,KAAKA,KAApB;IACD;;IACD,QAAIpM,QAAJ,EAAc;IACZ,UAAMsR,aAAa,GAAGrG,MAAM,CAACsG,iBAAP,CAAyBtG,MAAM,CAACjL,QAAhC,CAAtB;;IAEA,UAAIsR,aAAJ,EAAmB;IACjBsV,QAAAA,MAAM,CAAC5mB,QAAP,GAAkB;IAChBgM,UAAAA,KAAK,EAAEsF,aAAa,CAACtF,KAAd,CAAoBI,KADX;IAEhBwH,UAAAA,eAAe,EAAE3I,MAAM,CAACiZ,kBAAP,CAA0B5S,aAAa,CAACtF,KAAxC;IAFD,SAAlB;IAID;IAEF;;IAED,QAAI2a,iBAAJ,EAAuB;IACrB,UAAMrP,aAAa,GAAG,KAAKA,aAA3B;IAEAsP,MAAAA,MAAM,CAACI,aAAP,GAAuB,MAAA,MAAA1P,aAAa,CAAC,CAAD,CAAb,UAAA,iBAAA,SAAA,MAAkBlL,KAAlB,UAAA,iBAAA,KAAA,GAA2B,CAAlD;IACD;;IAED,WAAOwa,MAAP;IACD,GAhDM;IAkDP;;;;;;;;IAMO,mBAAA,GAAP,UAAiBA,MAAjB;;;IACE,QAAI,CAAC,KAAKnC,YAAV,EAAwB;IACtB,YAAM,IAAIvmB,aAAJ,CAAkB0E,OAAA,CAAczD,eAAhC,EAAiDyD,IAAA,CAAWzD,eAA5D,CAAN;IACD;;IAGC,QAAAiN,KAAK,GAIHwa,MAAM,MAJR;IAAA,QACA5mB,QAAQ,GAGN4mB,MAAM,SAJR;IAAA,QAEAI,aAAa,GAEXJ,MAAM,cAJR;IAAA,QAGA/a,MAAM,GACJ+a,MAAM,OAJR;IAMF,QAAMrd,QAAQ,GAAG,KAAKqa,SAAtB;IACA,QAAM5Z,OAAO,GAAG,KAAK8Z,QAArB;;IAGA,QAAI,CAAA,MAAAjY,MAAM,CAAC,CAAD,CAAN,UAAA,iBAAA,SAAA,MAAWib,IAAX,KAAmB,CAAC,KAAKf,eAA7B,EAA8C;IAC5Cxc,MAAAA,QAAQ,CAAC0d,WAAT,CAAqB;IAAE7a,QAAAA,KAAK,EAAE,CAAT;IAAYuQ,QAAAA,WAAW,EAAE,KAAK9Q,MAAL,CAAYpF;IAArC,OAArB;IACA8C,MAAAA,QAAQ,CAAC2d,WAAT,CAAqB;IAAE9a,QAAAA,KAAK,EAAE,CAAT;IAAY7G,QAAAA,QAAQ,EAAEF,YAAY,CAACwG,MAAM,CAACrM,GAAP,CAAW,UAAAwM,KAAA;IAAS,iBAAAA,KAAK,CAAC8a,IAAN;IAAW,SAA/B,CAAD;IAAlC,OAArB;IACD;;IAED,QAAI1a,KAAJ,EAAW;IACT,UAAM+a,UAAU,GAAGH,aAAa,GAC5B5a,KAAK,GAAG4a,aADoB,GAE5B5a,KAFJ;IAIA,WAAK,KAAKwS,MAAL,CAAYuI,UAAZ,EAAwB,CAAxB,EAA2B5K,KAA3B,CAAiC;IAAM,eAAA,KAAK,CAAL;IAAM,OAA7C,CAAL;IACD;;IAED,QAAIvc,QAAQ,IAAI,KAAKqlB,SAAL,KAAmB7jB,SAAS,CAACE,WAA7C,EAA0D;IAChD,UAAAsK,KAAK,GAAsBhM,QAAQ,MAAnC;IAAA,UAAO4T,eAAe,GAAK5T,QAAQ,gBAAnC;IACR,UAAMmnB,UAAU,GAAGH,aAAa,GAC5Bhb,KAAK,GAAGgb,aADoB,GAE5Bhb,KAFJ;IAGA,UAAM6H,UAAU,GAAGtK,QAAQ,CAACsC,MAAT,CAAgBsb,UAAhB,EAA4B3Y,KAA/C;IACA,UAAM4Y,YAAY,GAAGvT,UAAU,CAAC/T,GAAX,GAAiB,CAAC+T,UAAU,CAAC9T,GAAX,GAAiB8T,UAAU,CAAC/T,GAA7B,IAAoC8T,eAA1E;IAEA,WAAK5J,OAAO,CAAC2C,cAAR,CAAuBya,YAAvB,EAAqC,CAArC,EAAwC7K,KAAxC,CAA8C;IAAM,eAAA,KAAK,CAAL;IAAM,OAA1D,CAAL;IACD;IACF,GAvCM;IAyCP;;;;;;;;;IAOO,oBAAA,GAAP;;;IAAA,oBAAA;;IAAkB,oBAAA;;aAAA,YAAA1a,uBAAAA;IAAAwlB,MAAAA,WAAA,gBAAA;;;IAChB,QAAI,KAAK5C,YAAT,EAAuB;IACrB4C,MAAAA,OAAO,CAACtlB,OAAR,CAAgB,UAAA4Z,IAAA;IAAQ,eAAAA,IAAI,CAAC1K,IAAL,CAAUlT,KAAV,CAAA;IAAe,OAAvC;IACD;;IAED,KAAA2J,KAAA,KAAKgd,QAAL,EAAc/e,IAAd,MAAA,GAAA,6BAAsB0hB,SAAtB;;IAEA,WAAO,IAAP;IACD,GARM;IAUP;;;;;;;;;IAOO,uBAAA,GAAP;IAAA,oBAAA;;IAAqB,oBAAA;;aAAA,YAAAxlB,uBAAAA;IAAAwlB,MAAAA,WAAA,gBAAA;;;IACnBA,IAAAA,OAAO,CAACtlB,OAAR,CAAgB,UAAA4Z,IAAA;IACd,UAAM2L,UAAU,GAAG/gB,SAAS,CAACxI,KAAI,CAAC2mB,QAAN,EAAgB,UAAA9kB,GAAA;IAAO,eAAAA,GAAG,KAAK+b,IAAR;IAAY,OAAnC,CAA5B;;IAEA,UAAI2L,UAAU,IAAI,CAAlB,EAAqB;IACnB3L,QAAAA,IAAI,CAACpM,OAAL;;IACAxR,QAAAA,KAAI,CAAC2mB,QAAL,CAAcjK,MAAd,CAAqB6M,UAArB,EAAiC,CAAjC;IACD;IACF,KAPD;IASA,WAAO,IAAP;IACD,GAXM;IAuEP;;;;;;;;;;;;;;;;;;;;;;IAoBO,gBAAA,GAAP,UAAchiB,OAAd;IACE,WAAO,KAAKiiB,MAAL,CAAY,KAAK3D,SAAL,CAAepa,UAA3B,EAAuClE,OAAvC,CAAP;IACD,GAFM;IAIP;;;;;;;;;;;;;;;;;;;;;;;IAqBO,iBAAA,GAAP,UAAeA,OAAf;IACE,WAAO,KAAKiiB,MAAL,CAAY,CAAZ,EAAejiB,OAAf,CAAP;IACD,GAFM;IAIP;;;;;;;;;;;;;;;;;;;;;;IAoBO,gBAAA,GAAP,UAAc8G,KAAd,EAA6B9G,OAA7B;IACE,QAAI,KAAKygB,eAAT,EAA0B;IACxB,YAAM,IAAI7nB,aAAJ,CAAkB0E,OAAA,CAAc1D,wBAAhC,EAA0D0D,IAAA,CAAW1D,wBAArE,CAAN;IACD;;IAED,WAAO,KAAK0kB,SAAL,CAAesD,WAAf,CAA2B;IAAE9a,MAAAA,KAAK,OAAP;IAAS7G,MAAAA,QAAQ,EAAEF,YAAY,CAACC,OAAD;IAA/B,KAA3B,CAAP;IACD,GANM;IAQP;;;;;;;;;;;IASO,gBAAA,GAAP,UAAc8G,KAAd,EAA6BuQ,WAA7B;IAA6B,8BAAA,EAAA;IAAAA,MAAAA,eAAA;;;IAC3B,QAAI,KAAKoJ,eAAT,EAA0B;IACxB,YAAM,IAAI7nB,aAAJ,CAAkB0E,OAAA,CAAc1D,wBAAhC,EAA0D0D,IAAA,CAAW1D,wBAArE,CAAN;IACD;;IAED,WAAO,KAAK0kB,SAAL,CAAeqD,WAAf,CAA2B;IAAE7a,MAAAA,KAAK,OAAP;IAASuQ,MAAAA,WAAW;IAApB,KAA3B,CAAP;IACD,GANM;;IAQC,wBAAA,GAAR;;;IACE,QAAM+F,QAAQ,GAAG,KAAK2C,SAAtB;IACA,QAAMmC,SAAS,GAAGxpB,MAAM,CAACiE,IAAP,CAAYT,SAAZ,EAAuBhC,GAAvB,CAA2B,UAAA0C,GAAA;IAAO,aAAAV,SAAS,CAACU,GAAD,CAAT;IAA2C,KAA7E,CAAlB;IAEA,QAAMulB,WAAW,GAAGrjB,KAAK,CAACC,OAAN,CAAcqe,QAAd,IAChBA,QAAQ,CAAC,CAAD,CADQ,GAEhBA,QAFJ;IAIA,QAAMgF,eAAe,GAAGtjB,KAAK,CAACC,OAAN,CAAcqe,QAAd,IACpB,MAAAA,QAAQ,CAAC,CAAD,CAAR,UAAA,iBAAA,KAAA,GAAe,EADK,GAEpB,EAFJ;;IAIA,QAAI,CAAC1c,QAAQ,CAACwhB,SAAD,EAAYC,WAAZ,CAAb,EAAuC;IACrC,YAAM,IAAIvpB,aAAJ,CAAkB0E,OAAA,CAAcjE,YAAd,CAA2B,UAA3B,EAAuCgpB,IAAI,CAACC,SAAL,CAAelF,QAAf,CAAvC,CAAlB,EAAoF9f,IAAA,CAAWjE,YAA/F,CAAN;IACD;;IAED,YAAQ8oB,WAAR;IACE,WAAKjmB,SAAS,CAACC,IAAf;IACE,eAAO,IAAIomB,WAAJ,EAAP;;IACF,WAAKrmB,SAAS,CAACE,WAAf;IACE,eAAO,IAAIomB,WAAJ,CAAgBJ,eAAhB,CAAP;IAJJ;IAMD,GAtBO;;IAwBA,uBAAA,GAAR;IACE,QAAMK,YAAY,GAAG;IAAElkB,MAAAA,KAAK,EAAE,KAAK6Q;IAAd,KAArB;;IAEA,QAAI,KAAKmQ,SAAT,EAAoB;IAClB,UAAI,KAAKC,MAAT,EAAiB;IACf;IACAkD,QAAAA,OAAO,CAACC,IAAR,CAAa,4EAAb;IACD;;IACD,aAAO,IAAIC,cAAJ,CAAmBH,YAAnB,CAAP;IACD,KAND,MAMO,IAAI,KAAKjD,MAAT,EAAiB;IACtB,aAAO,IAAIqD,WAAJ,CAAgBJ,YAAhB,CAAP;IACD,KAFM,MAEA;IACL,aAAO,IAAIK,YAAJ,CAAiBL,YAAjB,CAAP;IACD;IACF,GAdO;;IAgBA,yBAAA,GAAR;IACE,QAAMM,iBAAiB,GAAG,KAAKzC,kBAAL,GACtB,IAAI0C,wBAAJ,EADsB,GAEtB,IAAIpN,oBAAJ,EAFJ;IAIA,QAAMqN,eAAe,GAAG;IACtB1kB,MAAAA,KAAK,EAAE,KAAK6Q,MADU;IAEtBuG,MAAAA,QAAQ,EAAEoN;IAFY,KAAxB;IAKA,QAAM3E,cAAc,GAAG,KAAKqC,eAA5B;IAEA,WAAOrC,cAAc,GACjB,IAAKA,cAAc,CAACna,QAApB,2BAA0Cgf,kBAAoB7E,cAAc,CAAC6E,gBAA7E,CADiB,GAEjB,IAAIC,eAAJ,CAAoBD,eAApB,CAFJ;IAGD,GAfO;;IAiBA,6BAAA,GAAR;IACE,QAAMhf,QAAQ,GAAG,KAAKqa,SAAtB;IACA,QAAM5Z,OAAO,GAAG,KAAK8Z,QAArB;IACA,QAAM2E,YAAY,GAAGlf,QAAQ,CAAC8O,QAAT,CAAkB,KAAKsM,aAAvB,KAAyCpb,QAAQ,CAAC8O,QAAT,CAAkB,CAAlB,CAA9D;IAEA,QAAI,CAACoQ,YAAL,EAAmB;IAEnB,SAAKze,OAAO,CAACsS,WAAR,CAAoBmM,YAApB,EAAkC;IACrC/b,MAAAA,QAAQ,EAAE;IAD2B,KAAlC,CAAL;IAGD,GAVO;IA1mCR;;;;;;;;;;;;IAUcgc,EAAAA,gBAAA,GAAU,OAAV;IAinChB,iBAAA;IAAC,EA5nCsBC;;IC1EvB;;;;;IAIA;;;IAA8ChrB,EAAAA,kCAAA;IAG5C;;;;;;;;;IAOA,wBAAA,CAAmB8hB,OAAnB;IAAA,gBACE3hB,WAAA,KAAA,EAAM2hB,OAAN,SADF;;IAGE1hB,IAAAA,KAAI,CAAC6qB,kBAAL,GAA0BnJ,OAAO,CAACoJ,iBAAlC;;IACD;;IACH,sBAAA;IAfA,EAA8ClJ,MAA9C;;ICdA;;;;;;;;;;;;;;;ICAA;;;;IAYAhe,KAAK,CAAC+mB,QAAD,EAAWI,IAAX,CAAL;IACAnnB,KAAK,CAAC+mB,QAAD,EAAWpQ,MAAX,CAAL;IACA3W,KAAK,CAAC+mB,QAAD,EAAWlV,OAAX,CAAL;IACA7R,KAAK,CAAC+mB,QAAD,EAAWlH,QAAX,CAAL;IACA7f,KAAK,CAAC+mB,QAAD,EAAWK,SAAX,CAAL;;;;;;;;"}